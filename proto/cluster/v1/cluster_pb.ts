// @generated by protoc-gen-es v2.11.0 with parameter "target=ts"
// @generated from file cluster/v1/cluster.proto (package admiral.api.cluster.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv2";
import { enumDesc, fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv2";
import { file_admiral_common_v1_annotations } from "../../admiral/common/v1/annotations_pb";
import type { AccessToken } from "../../admiral/common/v1/token_pb";
import { file_admiral_common_v1_token } from "../../admiral/common/v1/token_pb";
import { file_buf_validate_validate } from "../../buf/validate/validate_pb";
import { file_google_api_annotations } from "../../google/api/annotations_pb";
import type { FieldMask, Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_field_mask, file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file cluster/v1/cluster.proto.
 */
export const file_cluster_v1_cluster: GenFile = /*@__PURE__*/
  fileDesc("ChhjbHVzdGVyL3YxL2NsdXN0ZXIucHJvdG8SFmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEiugMKB0NsdXN0ZXISFAoCaWQYASABKAlCCLpIBXIDsAEBEhsKCXRlbmFudF9pZBgCIAEoCUIIukgFcgOwAQESOAoEbmFtZRgDIAEoCUIqukgnciUYPzIhXlthLXpdKFthLXowLTktXXswLDYxfVthLXowLTldKT8kEh0KC2Rlc2NyaXB0aW9uGAQgASgJQgi6SAVyAxiACBI7CgZsYWJlbHMYBSADKAsyKy5hZG1pcmFsLmFwaS5jbHVzdGVyLnYxLkNsdXN0ZXIuTGFiZWxzRW50cnkSEwoLY2x1c3Rlcl91aWQYBiABKAkSQgoNaGVhbHRoX3N0YXR1cxgHIAEoDjIrLmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEuQ2x1c3RlckhlYWx0aFN0YXR1cxIuCgpjcmVhdGVkX2F0GAggASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBIuCgp1cGRhdGVkX2F0GAkgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBotCgtMYWJlbHNFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBIpgDCg1DbHVzdGVyU3RhdHVzEhMKC2s4c192ZXJzaW9uGAEgASgJEhIKCm5vZGVfY291bnQYAiABKAUSEwoLbm9kZXNfcmVhZHkYAyABKAUSFAoMcG9kX2NhcGFjaXR5GAQgASgFEhEKCXBvZF9jb3VudBgFIAEoBRIUCgxwb2RzX3J1bm5pbmcYBiABKAUSFAoMcG9kc19wZW5kaW5nGAcgASgFEhMKC3BvZHNfZmFpbGVkGAggASgFEh8KF2NwdV9jYXBhY2l0eV9taWxsaWNvcmVzGAkgASgDEhsKE2NwdV91c2VkX21pbGxpY29yZXMYCiABKAMSHQoVbWVtb3J5X2NhcGFjaXR5X2J5dGVzGAsgASgDEhkKEW1lbW9yeV91c2VkX2J5dGVzGAwgASgDEhcKD3dvcmtsb2Fkc190b3RhbBgNIAEoBRIZChF3b3JrbG9hZHNfaGVhbHRoeRgOIAEoBRIaChJ3b3JrbG9hZHNfZGVncmFkZWQYDyABKAUSFwoPd29ya2xvYWRzX2Vycm9yGBAgASgFIpYFCghXb3JrbG9hZBIKCgJpZBgBIAEoCRISCgpjbHVzdGVyX2lkGAIgASgJEhEKCW5hbWVzcGFjZRgDIAEoCRIMCgRuYW1lGAQgASgJEgwKBGtpbmQYBSABKAkSPAoGbGFiZWxzGAYgAygLMiwuYWRtaXJhbC5hcGkuY2x1c3Rlci52MS5Xb3JrbG9hZC5MYWJlbHNFbnRyeRJDCg1oZWFsdGhfc3RhdHVzGAcgASgOMiwuYWRtaXJhbC5hcGkuY2x1c3Rlci52MS5Xb3JrbG9hZEhlYWx0aFN0YXR1cxIVCg1zdGF0dXNfcmVhc29uGAggASgJEhgKEHJlcGxpY2FzX2Rlc2lyZWQYCSABKAUSFgoOcmVwbGljYXNfcmVhZHkYCiABKAUSGgoScmVwbGljYXNfYXZhaWxhYmxlGAsgASgFEh8KF2NwdV9yZXF1ZXN0c19taWxsaWNvcmVzGAwgASgDEh0KFWNwdV9saW1pdHNfbWlsbGljb3JlcxgNIAEoAxIbChNjcHVfdXNlZF9taWxsaWNvcmVzGA4gASgDEh0KFW1lbW9yeV9yZXF1ZXN0c19ieXRlcxgPIAEoAxIbChNtZW1vcnlfbGltaXRzX2J5dGVzGBAgASgDEhkKEW1lbW9yeV91c2VkX2J5dGVzGBEgASgDEjsKCmNvbnRhaW5lcnMYEiADKAsyJy5hZG1pcmFsLmFwaS5jbHVzdGVyLnYxLkNvbnRhaW5lclN0YXR1cxIzCg9sYXN0X3VwZGF0ZWRfYXQYEyABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wGi0KC0xhYmVsc0VudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCToCOAEiYwoPQ29udGFpbmVyU3RhdHVzEgwKBG5hbWUYASABKAkSDQoFaW1hZ2UYAiABKAkSFQoNcmVzdGFydF9jb3VudBgDIAEoBRINCgVzdGF0ZRgEIAEoCRINCgVyZWFkeRgFIAEoCCJACg9PYmplY3RSZWZlcmVuY2USDAoEa2luZBgBIAEoCRIRCgluYW1lc3BhY2UYAiABKAkSDAoEbmFtZRgDIAEoCSL1AQoNV29ya2xvYWRFdmVudBILCgN1aWQYASABKAkSDAoEdHlwZRgCIAEoCRIOCgZyZWFzb24YAyABKAkSOgoJcmVnYXJkaW5nGAQgASgLMicuYWRtaXJhbC5hcGkuY2x1c3Rlci52MS5PYmplY3RSZWZlcmVuY2USDwoHbWVzc2FnZRgFIAEoCRIuCgpmaXJzdF9zZWVuGAYgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBItCglsYXN0X3NlZW4YByABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEg0KBWNvdW50GAggASgFIugBChRDcmVhdGVDbHVzdGVyUmVxdWVzdBI4CgRuYW1lGAEgASgJQiq6SCdyJRg/MiFeW2Etel0oW2EtejAtOS1dezAsNjF9W2EtejAtOV0pPyQSHQoLZGVzY3JpcHRpb24YAiABKAlCCLpIBXIDGIAIEkgKBmxhYmVscxgDIAMoCzI4LmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEuQ3JlYXRlQ2x1c3RlclJlcXVlc3QuTGFiZWxzRW50cnkaLQoLTGFiZWxzRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgJOgI4ASJjChVDcmVhdGVDbHVzdGVyUmVzcG9uc2USMAoHY2x1c3RlchgBIAEoCzIfLmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEuQ2x1c3RlchIYChBwbGFpbl90ZXh0X3Rva2VuGAIgASgJIjEKEUdldENsdXN0ZXJSZXF1ZXN0EhwKCmNsdXN0ZXJfaWQYASABKAlCCLpIBXIDsAEBIkYKEkdldENsdXN0ZXJSZXNwb25zZRIwCgdjbHVzdGVyGAEgASgLMh8uYWRtaXJhbC5hcGkuY2x1c3Rlci52MS5DbHVzdGVyIkwKE0xpc3RDbHVzdGVyc1JlcXVlc3QSDgoGZmlsdGVyGAEgASgJEhEKCXBhZ2Vfc2l6ZRgCIAEoBRISCgpwYWdlX3Rva2VuGAMgASgJImIKFExpc3RDbHVzdGVyc1Jlc3BvbnNlEjEKCGNsdXN0ZXJzGAEgAygLMh8uYWRtaXJhbC5hcGkuY2x1c3Rlci52MS5DbHVzdGVyEhcKD25leHRfcGFnZV90b2tlbhgCIAEoCSKBAQoUVXBkYXRlQ2x1c3RlclJlcXVlc3QSOAoHY2x1c3RlchgBIAEoCzIfLmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEuQ2x1c3RlckIGukgDyAEBEi8KC3VwZGF0ZV9tYXNrGAIgASgLMhouZ29vZ2xlLnByb3RvYnVmLkZpZWxkTWFzayJJChVVcGRhdGVDbHVzdGVyUmVzcG9uc2USMAoHY2x1c3RlchgBIAEoCzIfLmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEuQ2x1c3RlciI0ChREZWxldGVDbHVzdGVyUmVxdWVzdBIcCgpjbHVzdGVyX2lkGAEgASgJQgi6SAVyA7ABASIXChVEZWxldGVDbHVzdGVyUmVzcG9uc2UiNwoXR2V0Q2x1c3RlclN0YXR1c1JlcXVlc3QSHAoKY2x1c3Rlcl9pZBgBIAEoCUIIukgFcgOwAQEixgEKGEdldENsdXN0ZXJTdGF0dXNSZXNwb25zZRJCCg1oZWFsdGhfc3RhdHVzGAEgASgOMisuYWRtaXJhbC5hcGkuY2x1c3Rlci52MS5DbHVzdGVySGVhbHRoU3RhdHVzEjUKBnN0YXR1cxgCIAEoCzIlLmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEuQ2x1c3RlclN0YXR1cxIvCgtyZXBvcnRlZF9hdBgDIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAinAIKGlJlcG9ydENsdXN0ZXJTdGF0dXNSZXF1ZXN0EhwKCmNsdXN0ZXJfaWQYASABKAlCCLpIBXIDsAEBEj0KBnN0YXR1cxgCIAEoCzIlLmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEuQ2x1c3RlclN0YXR1c0IGukgDyAEBEjkKCXdvcmtsb2FkcxgDIAMoCzImLmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEuV29ya2xvYWRTdGF0dXMSNQoGZXZlbnRzGAQgAygLMiUuYWRtaXJhbC5hcGkuY2x1c3Rlci52MS5Xb3JrbG9hZEV2ZW50Ei8KC3JlcG9ydGVkX2F0GAUgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCK2BAoOV29ya2xvYWRTdGF0dXMSEQoJbmFtZXNwYWNlGAEgASgJEgwKBG5hbWUYAiABKAkSDAoEa2luZBgDIAEoCRJCCgZsYWJlbHMYBCADKAsyMi5hZG1pcmFsLmFwaS5jbHVzdGVyLnYxLldvcmtsb2FkU3RhdHVzLkxhYmVsc0VudHJ5EhgKEHJlcGxpY2FzX2Rlc2lyZWQYBSABKAUSFgoOcmVwbGljYXNfcmVhZHkYBiABKAUSGgoScmVwbGljYXNfYXZhaWxhYmxlGAcgASgFEh8KF2NwdV9yZXF1ZXN0c19taWxsaWNvcmVzGAggASgDEh0KFWNwdV9saW1pdHNfbWlsbGljb3JlcxgJIAEoAxIbChNjcHVfdXNlZF9taWxsaWNvcmVzGAogASgDEh0KFW1lbW9yeV9yZXF1ZXN0c19ieXRlcxgLIAEoAxIbChNtZW1vcnlfbGltaXRzX2J5dGVzGAwgASgDEhkKEW1lbW9yeV91c2VkX2J5dGVzGA0gASgDEkMKDWhlYWx0aF9zdGF0dXMYDiABKA4yLC5hZG1pcmFsLmFwaS5jbHVzdGVyLnYxLldvcmtsb2FkSGVhbHRoU3RhdHVzEjsKCmNvbnRhaW5lcnMYDyADKAsyJy5hZG1pcmFsLmFwaS5jbHVzdGVyLnYxLkNvbnRhaW5lclN0YXR1cxotCgtMYWJlbHNFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBIkUKG1JlcG9ydENsdXN0ZXJTdGF0dXNSZXNwb25zZRILCgNhY2sYASABKAgSGQoRbmV4dF9wdXNoX3NlY29uZHMYAiABKAUiawoUTGlzdFdvcmtsb2Fkc1JlcXVlc3QSHAoKY2x1c3Rlcl9pZBgBIAEoCUIIukgFcgOwAQESDgoGZmlsdGVyGAIgASgJEhEKCXBhZ2Vfc2l6ZRgDIAEoBRISCgpwYWdlX3Rva2VuGAQgASgJImUKFUxpc3RXb3JrbG9hZHNSZXNwb25zZRIzCgl3b3JrbG9hZHMYASADKAsyIC5hZG1pcmFsLmFwaS5jbHVzdGVyLnYxLldvcmtsb2FkEhcKD25leHRfcGFnZV90b2tlbhgCIAEoCSKnAQobUmVwb3J0V29ya2xvYWRTdGF0dXNSZXF1ZXN0EhwKCmNsdXN0ZXJfaWQYASABKAlCCLpIBXIDsAEBEjkKCXdvcmtsb2FkcxgCIAMoCzImLmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEuV29ya2xvYWRTdGF0dXMSLwoLcmVwb3J0ZWRfYXQYAyABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wIisKHFJlcG9ydFdvcmtsb2FkU3RhdHVzUmVzcG9uc2USCwoDYWNrGAEgASgIIosBChlDcmVhdGVDbHVzdGVyVG9rZW5SZXF1ZXN0EhwKCmNsdXN0ZXJfaWQYASABKAlCCLpIBXIDsAEBEiAKDGRpc3BsYXlfbmFtZRgCIAEoCUIKukgHcgUQARj/ARIuCgpleHBpcmVzX2F0GAMgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCJsChpDcmVhdGVDbHVzdGVyVG9rZW5SZXNwb25zZRI0CgxhY2Nlc3NfdG9rZW4YASABKAsyHi5hZG1pcmFsLmNvbW1vbi52MS5BY2Nlc3NUb2tlbhIYChBwbGFpbl90ZXh0X3Rva2VuGAIgASgJIm8KGExpc3RDbHVzdGVyVG9rZW5zUmVxdWVzdBIcCgpjbHVzdGVyX2lkGAEgASgJQgi6SAVyA7ABARIRCglwYWdlX3NpemUYAiABKAUSEgoKcGFnZV90b2tlbhgDIAEoCRIOCgZmaWx0ZXIYBCABKAkiawoZTGlzdENsdXN0ZXJUb2tlbnNSZXNwb25zZRI1Cg1hY2Nlc3NfdG9rZW5zGAEgAygLMh4uYWRtaXJhbC5jb21tb24udjEuQWNjZXNzVG9rZW4SFwoPbmV4dF9wYWdlX3Rva2VuGAIgASgJIlIKFkdldENsdXN0ZXJUb2tlblJlcXVlc3QSHAoKY2x1c3Rlcl9pZBgBIAEoCUIIukgFcgOwAQESGgoIdG9rZW5faWQYAiABKAlCCLpIBXIDsAEBIk8KF0dldENsdXN0ZXJUb2tlblJlc3BvbnNlEjQKDGFjY2Vzc190b2tlbhgBIAEoCzIeLmFkbWlyYWwuY29tbW9uLnYxLkFjY2Vzc1Rva2VuIlUKGVJldm9rZUNsdXN0ZXJUb2tlblJlcXVlc3QSHAoKY2x1c3Rlcl9pZBgBIAEoCUIIukgFcgOwAQESGgoIdG9rZW5faWQYAiABKAlCCLpIBXIDsAEBIlIKGlJldm9rZUNsdXN0ZXJUb2tlblJlc3BvbnNlEjQKDGFjY2Vzc190b2tlbhgBIAEoCzIeLmFkbWlyYWwuY29tbW9uLnYxLkFjY2Vzc1Rva2VuKu4BChNDbHVzdGVySGVhbHRoU3RhdHVzEiUKIUNMVVNURVJfSEVBTFRIX1NUQVRVU19VTlNQRUNJRklFRBAAEiEKHUNMVVNURVJfSEVBTFRIX1NUQVRVU19QRU5ESU5HEAESIQodQ0xVU1RFUl9IRUFMVEhfU1RBVFVTX0hFQUxUSFkQAhIiCh5DTFVTVEVSX0hFQUxUSF9TVEFUVVNfREVHUkFERUQQAxIfChtDTFVTVEVSX0hFQUxUSF9TVEFUVVNfRVJST1IQBBIlCiFDTFVTVEVSX0hFQUxUSF9TVEFUVVNfVU5SRUFDSEFCTEUQBSqpAQoUV29ya2xvYWRIZWFsdGhTdGF0dXMSJgoiV09SS0xPQURfSEVBTFRIX1NUQVRVU19VTlNQRUNJRklFRBAAEiIKHldPUktMT0FEX0hFQUxUSF9TVEFUVVNfSEVBTFRIWRABEiMKH1dPUktMT0FEX0hFQUxUSF9TVEFUVVNfREVHUkFERUQQAhIgChxXT1JLTE9BRF9IRUFMVEhfU1RBVFVTX0VSUk9SEAMyoRIKCkNsdXN0ZXJBUEkSmAEKDUNyZWF0ZUNsdXN0ZXISLC5hZG1pcmFsLmFwaS5jbHVzdGVyLnYxLkNyZWF0ZUNsdXN0ZXJSZXF1ZXN0Gi0uYWRtaXJhbC5hcGkuY2x1c3Rlci52MS5DcmVhdGVDbHVzdGVyUmVzcG9uc2UiKqKXJA8KDWNsdXN0ZXI6d3JpdGWC0+STAhE6ASoiDC92MS9jbHVzdGVycxKYAQoKR2V0Q2x1c3RlchIpLmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEuR2V0Q2x1c3RlclJlcXVlc3QaKi5hZG1pcmFsLmFwaS5jbHVzdGVyLnYxLkdldENsdXN0ZXJSZXNwb25zZSIzopckDgoMY2x1c3RlcjpyZWFkgtPkkwIbEhkvdjEvY2x1c3RlcnMve2NsdXN0ZXJfaWR9ErEBChBHZXRDbHVzdGVyU3RhdHVzEi8uYWRtaXJhbC5hcGkuY2x1c3Rlci52MS5HZXRDbHVzdGVyU3RhdHVzUmVxdWVzdBowLmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEuR2V0Q2x1c3RlclN0YXR1c1Jlc3BvbnNlIjqilyQOCgxjbHVzdGVyOnJlYWSC0+STAiISIC92MS9jbHVzdGVycy97Y2x1c3Rlcl9pZH0vc3RhdHVzEpEBCgxMaXN0Q2x1c3RlcnMSKy5hZG1pcmFsLmFwaS5jbHVzdGVyLnYxLkxpc3RDbHVzdGVyc1JlcXVlc3QaLC5hZG1pcmFsLmFwaS5jbHVzdGVyLnYxLkxpc3RDbHVzdGVyc1Jlc3BvbnNlIiailyQOCgxjbHVzdGVyOnJlYWSC0+STAg4SDC92MS9jbHVzdGVycxKlAQoNVXBkYXRlQ2x1c3RlchIsLmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEuVXBkYXRlQ2x1c3RlclJlcXVlc3QaLS5hZG1pcmFsLmFwaS5jbHVzdGVyLnYxLlVwZGF0ZUNsdXN0ZXJSZXNwb25zZSI3opckDwoNY2x1c3Rlcjp3cml0ZYLT5JMCHjoBKjIZL3YxL2NsdXN0ZXJzL3tjbHVzdGVyLmlkfRKiAQoNRGVsZXRlQ2x1c3RlchIsLmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEuRGVsZXRlQ2x1c3RlclJlcXVlc3QaLS5hZG1pcmFsLmFwaS5jbHVzdGVyLnYxLkRlbGV0ZUNsdXN0ZXJSZXNwb25zZSI0opckDwoNY2x1c3Rlcjp3cml0ZYLT5JMCGyoZL3YxL2NsdXN0ZXJzL3tjbHVzdGVyX2lkfRK7AQoSQ3JlYXRlQ2x1c3RlclRva2VuEjEuYWRtaXJhbC5hcGkuY2x1c3Rlci52MS5DcmVhdGVDbHVzdGVyVG9rZW5SZXF1ZXN0GjIuYWRtaXJhbC5hcGkuY2x1c3Rlci52MS5DcmVhdGVDbHVzdGVyVG9rZW5SZXNwb25zZSI+opckDwoNY2x1c3Rlcjp3cml0ZYLT5JMCJToBKiIgL3YxL2NsdXN0ZXJzL3tjbHVzdGVyX2lkfS90b2tlbnMStAEKEUxpc3RDbHVzdGVyVG9rZW5zEjAuYWRtaXJhbC5hcGkuY2x1c3Rlci52MS5MaXN0Q2x1c3RlclRva2Vuc1JlcXVlc3QaMS5hZG1pcmFsLmFwaS5jbHVzdGVyLnYxLkxpc3RDbHVzdGVyVG9rZW5zUmVzcG9uc2UiOqKXJA4KDGNsdXN0ZXI6cmVhZILT5JMCIhIgL3YxL2NsdXN0ZXJzL3tjbHVzdGVyX2lkfS90b2tlbnMSuQEKD0dldENsdXN0ZXJUb2tlbhIuLmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEuR2V0Q2x1c3RlclRva2VuUmVxdWVzdBovLmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEuR2V0Q2x1c3RlclRva2VuUmVzcG9uc2UiRaKXJA4KDGNsdXN0ZXI6cmVhZILT5JMCLRIrL3YxL2NsdXN0ZXJzL3tjbHVzdGVyX2lkfS90b2tlbnMve3Rva2VuX2lkfRLNAQoSUmV2b2tlQ2x1c3RlclRva2VuEjEuYWRtaXJhbC5hcGkuY2x1c3Rlci52MS5SZXZva2VDbHVzdGVyVG9rZW5SZXF1ZXN0GjIuYWRtaXJhbC5hcGkuY2x1c3Rlci52MS5SZXZva2VDbHVzdGVyVG9rZW5SZXNwb25zZSJQopckDwoNY2x1c3Rlcjp3cml0ZYLT5JMCNzoBKiIyL3YxL2NsdXN0ZXJzL3tjbHVzdGVyX2lkfS90b2tlbnMve3Rva2VuX2lkfS9yZXZva2USxAEKE1JlcG9ydENsdXN0ZXJTdGF0dXMSMi5hZG1pcmFsLmFwaS5jbHVzdGVyLnYxLlJlcG9ydENsdXN0ZXJTdGF0dXNSZXF1ZXN0GjMuYWRtaXJhbC5hcGkuY2x1c3Rlci52MS5SZXBvcnRDbHVzdGVyU3RhdHVzUmVzcG9uc2UiRKKXJBUKDmNsdXN0ZXI6c3RhdHVzEgNhZ3SC0+STAiU6ASoiIC92MS9jbHVzdGVycy97Y2x1c3Rlcl9pZH0vc3RhdHVzEqsBCg1MaXN0V29ya2xvYWRzEiwuYWRtaXJhbC5hcGkuY2x1c3Rlci52MS5MaXN0V29ya2xvYWRzUmVxdWVzdBotLmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEuTGlzdFdvcmtsb2Fkc1Jlc3BvbnNlIj2ilyQOCgxjbHVzdGVyOnJlYWSC0+STAiUSIy92MS9jbHVzdGVycy97Y2x1c3Rlcl9pZH0vd29ya2xvYWRzEtEBChRSZXBvcnRXb3JrbG9hZFN0YXR1cxIzLmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEuUmVwb3J0V29ya2xvYWRTdGF0dXNSZXF1ZXN0GjQuYWRtaXJhbC5hcGkuY2x1c3Rlci52MS5SZXBvcnRXb3JrbG9hZFN0YXR1c1Jlc3BvbnNlIk6ilyQVCg5jbHVzdGVyOnN0YXR1cxIDYWd0gtPkkwIvOgEqIiovdjEvY2x1c3RlcnMve2NsdXN0ZXJfaWR9L3dvcmtsb2Fkcy9zdGF0dXNC0wEKGmNvbS5hZG1pcmFsLmFwaS5jbHVzdGVyLnYxQgxDbHVzdGVyUHJvdG9QAVosZ28uYWRtaXJhbC5pby9zZGsvcHJvdG8vY2x1c3Rlci92MTtjbHVzdGVydjGiAgNBQUOqAhZBZG1pcmFsLkFwaS5DbHVzdGVyLlYxygIWQWRtaXJhbFxBcGlcQ2x1c3RlclxWMeICIkFkbWlyYWxcQXBpXENsdXN0ZXJcVjFcR1BCTWV0YWRhdGHqAhlBZG1pcmFsOjpBcGk6OkNsdXN0ZXI6OlYxYgZwcm90bzM", [file_admiral_common_v1_annotations, file_admiral_common_v1_token, file_buf_validate_validate, file_google_api_annotations, file_google_protobuf_field_mask, file_google_protobuf_timestamp]);

/**
 * Cluster represents a registered Kubernetes cluster within a tenant.
 *
 * @generated from message admiral.api.cluster.v1.Cluster
 */
export type Cluster = Message<"admiral.api.cluster.v1.Cluster"> & {
  /**
   * Unique identifier for the cluster (UUID).
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * Tenant this cluster belongs to (UUID).
   *
   * @generated from field: string tenant_id = 2;
   */
  tenantId: string;

  /**
   * URL-safe, human-readable identifier (e.g., "prod-us-east-1"). Unique
   * within the tenant. Lowercase alphanumeric and hyphens only, must start
   * with a letter and end with an alphanumeric character (1-63 chars).
   *
   * @generated from field: string name = 3;
   */
  name: string;

  /**
   * Optional longer-form description of the cluster's purpose
   * (e.g., "Primary production cluster serving US East traffic").
   *
   * @generated from field: string description = 4;
   */
  description: string;

  /**
   * Arbitrary key-value labels for organizing and filtering clusters
   * (e.g., `{"region": "us-east-1", "cloud": "aws"}`).
   *
   * @generated from field: map<string, string> labels = 5;
   */
  labels: { [key: string]: string };

  /**
   * The Kubernetes kube-system namespace UID, bound at agent registration
   * using a first-write-wins strategy. Used to detect when a token is
   * accidentally deployed to a different physical cluster.
   *
   * @generated from field: string cluster_uid = 6;
   */
  clusterUid: string;

  /**
   * Derived health status based on agent connectivity and workload state.
   *
   * @generated from field: admiral.api.cluster.v1.ClusterHealthStatus health_status = 7;
   */
  healthStatus: ClusterHealthStatus;

  /**
   * When the cluster record was created.
   *
   * @generated from field: google.protobuf.Timestamp created_at = 8;
   */
  createdAt?: Timestamp;

  /**
   * When the cluster record was last updated.
   *
   * @generated from field: google.protobuf.Timestamp updated_at = 9;
   */
  updatedAt?: Timestamp;
};

/**
 * Describes the message admiral.api.cluster.v1.Cluster.
 * Use `create(ClusterSchema)` to create a new message.
 */
export const ClusterSchema: GenMessage<Cluster> = /*@__PURE__*/
  messageDesc(file_cluster_v1_cluster, 0);

/**
 * ClusterStatus contains the raw telemetry metrics for a cluster, as reported
 * by the K8s agent. This message is used in both the push payload
 * (ReportClusterStatusRequest) and the read response (GetClusterStatusResponse).
 *
 * Server-derived fields (health_status, agent connectivity) are NOT included
 * here â€” they live on the Cluster and Agent records respectively, and are
 * returned alongside this message in GetClusterStatusResponse.
 *
 * @generated from message admiral.api.cluster.v1.ClusterStatus
 */
export type ClusterStatus = Message<"admiral.api.cluster.v1.ClusterStatus"> & {
  /**
   * Kubernetes version reported by the agent (e.g., "1.29.2").
   *
   * @generated from field: string k8s_version = 1;
   */
  k8sVersion: string;

  /**
   * Total number of nodes in the cluster.
   *
   * @generated from field: int32 node_count = 2;
   */
  nodeCount: number;

  /**
   * Number of nodes in Ready condition.
   *
   * @generated from field: int32 nodes_ready = 3;
   */
  nodesReady: number;

  /**
   * Maximum number of pods the cluster can schedule.
   *
   * @generated from field: int32 pod_capacity = 4;
   */
  podCapacity: number;

  /**
   * Total number of pods across all namespaces.
   *
   * @generated from field: int32 pod_count = 5;
   */
  podCount: number;

  /**
   * Number of pods in Running phase.
   *
   * @generated from field: int32 pods_running = 6;
   */
  podsRunning: number;

  /**
   * Number of pods in Pending phase.
   *
   * @generated from field: int32 pods_pending = 7;
   */
  podsPending: number;

  /**
   * Number of pods in Failed phase.
   *
   * @generated from field: int32 pods_failed = 8;
   */
  podsFailed: number;

  /**
   * Total CPU capacity across all nodes, in millicores.
   *
   * @generated from field: int64 cpu_capacity_millicores = 9;
   */
  cpuCapacityMillicores: bigint;

  /**
   * Current CPU usage across all nodes, in millicores.
   *
   * @generated from field: int64 cpu_used_millicores = 10;
   */
  cpuUsedMillicores: bigint;

  /**
   * Total memory capacity across all nodes, in bytes.
   *
   * @generated from field: int64 memory_capacity_bytes = 11;
   */
  memoryCapacityBytes: bigint;

  /**
   * Current memory usage across all nodes, in bytes.
   *
   * @generated from field: int64 memory_used_bytes = 12;
   */
  memoryUsedBytes: bigint;

  /**
   * Total number of tracked workloads.
   *
   * @generated from field: int32 workloads_total = 13;
   */
  workloadsTotal: number;

  /**
   * Number of workloads in healthy state.
   *
   * @generated from field: int32 workloads_healthy = 14;
   */
  workloadsHealthy: number;

  /**
   * Number of workloads in degraded state.
   *
   * @generated from field: int32 workloads_degraded = 15;
   */
  workloadsDegraded: number;

  /**
   * Number of workloads in error state.
   *
   * @generated from field: int32 workloads_error = 16;
   */
  workloadsError: number;
};

/**
 * Describes the message admiral.api.cluster.v1.ClusterStatus.
 * Use `create(ClusterStatusSchema)` to create a new message.
 */
export const ClusterStatusSchema: GenMessage<ClusterStatus> = /*@__PURE__*/
  messageDesc(file_cluster_v1_cluster, 1);

/**
 * Workload represents a Kubernetes workload (Deployment, StatefulSet,
 * DaemonSet, etc.) as observed by the agent.
 *
 * @generated from message admiral.api.cluster.v1.Workload
 */
export type Workload = Message<"admiral.api.cluster.v1.Workload"> & {
  /**
   * Unique identifier for the workload within Admiral (UUID).
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * The cluster this workload belongs to (UUID).
   *
   * @generated from field: string cluster_id = 2;
   */
  clusterId: string;

  /**
   * Kubernetes namespace.
   *
   * @generated from field: string namespace = 3;
   */
  namespace: string;

  /**
   * Workload name.
   *
   * @generated from field: string name = 4;
   */
  name: string;

  /**
   * Kubernetes resource kind (e.g., "Deployment", "StatefulSet", "DaemonSet").
   *
   * @generated from field: string kind = 5;
   */
  kind: string;

  /**
   * Kubernetes labels on the workload.
   *
   * @generated from field: map<string, string> labels = 6;
   */
  labels: { [key: string]: string };

  /**
   * Derived health status.
   *
   * @generated from field: admiral.api.cluster.v1.WorkloadHealthStatus health_status = 7;
   */
  healthStatus: WorkloadHealthStatus;

  /**
   * Human-readable reason for the current status (e.g., "MinimumReplicasUnavailable").
   *
   * @generated from field: string status_reason = 8;
   */
  statusReason: string;

  /**
   * Number of desired replicas.
   *
   * @generated from field: int32 replicas_desired = 9;
   */
  replicasDesired: number;

  /**
   * Number of ready replicas.
   *
   * @generated from field: int32 replicas_ready = 10;
   */
  replicasReady: number;

  /**
   * Number of available replicas.
   *
   * @generated from field: int32 replicas_available = 11;
   */
  replicasAvailable: number;

  /**
   * CPU requests across all containers, in millicores.
   *
   * @generated from field: int64 cpu_requests_millicores = 12;
   */
  cpuRequestsMillicores: bigint;

  /**
   * CPU limits across all containers, in millicores.
   *
   * @generated from field: int64 cpu_limits_millicores = 13;
   */
  cpuLimitsMillicores: bigint;

  /**
   * Current CPU usage across all containers, in millicores.
   *
   * @generated from field: int64 cpu_used_millicores = 14;
   */
  cpuUsedMillicores: bigint;

  /**
   * Memory requests across all containers, in bytes.
   *
   * @generated from field: int64 memory_requests_bytes = 15;
   */
  memoryRequestsBytes: bigint;

  /**
   * Memory limits across all containers, in bytes.
   *
   * @generated from field: int64 memory_limits_bytes = 16;
   */
  memoryLimitsBytes: bigint;

  /**
   * Current memory usage across all containers, in bytes.
   *
   * @generated from field: int64 memory_used_bytes = 17;
   */
  memoryUsedBytes: bigint;

  /**
   * Status of individual containers in this workload.
   *
   * @generated from field: repeated admiral.api.cluster.v1.ContainerStatus containers = 18;
   */
  containers: ContainerStatus[];

  /**
   * When this workload's status was last updated.
   *
   * @generated from field: google.protobuf.Timestamp last_updated_at = 19;
   */
  lastUpdatedAt?: Timestamp;
};

/**
 * Describes the message admiral.api.cluster.v1.Workload.
 * Use `create(WorkloadSchema)` to create a new message.
 */
export const WorkloadSchema: GenMessage<Workload> = /*@__PURE__*/
  messageDesc(file_cluster_v1_cluster, 2);

/**
 * ContainerStatus describes the current state of a single container.
 *
 * @generated from message admiral.api.cluster.v1.ContainerStatus
 */
export type ContainerStatus = Message<"admiral.api.cluster.v1.ContainerStatus"> & {
  /**
   * Container name within the pod spec.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Container image reference (e.g., "registry.example.com/api:v2.1.4").
   *
   * @generated from field: string image = 2;
   */
  image: string;

  /**
   * Cumulative number of container restarts.
   *
   * @generated from field: int32 restart_count = 3;
   */
  restartCount: number;

  /**
   * Current container state (e.g., "running", "waiting", "terminated").
   *
   * @generated from field: string state = 4;
   */
  state: string;

  /**
   * Whether the container's readiness probe is passing.
   *
   * @generated from field: bool ready = 5;
   */
  ready: boolean;
};

/**
 * Describes the message admiral.api.cluster.v1.ContainerStatus.
 * Use `create(ContainerStatusSchema)` to create a new message.
 */
export const ContainerStatusSchema: GenMessage<ContainerStatus> = /*@__PURE__*/
  messageDesc(file_cluster_v1_cluster, 3);

/**
 * ObjectReference is a lightweight reference to a Kubernetes object.
 *
 * @generated from message admiral.api.cluster.v1.ObjectReference
 */
export type ObjectReference = Message<"admiral.api.cluster.v1.ObjectReference"> & {
  /**
   * Kubernetes resource kind (e.g., "Pod", "ReplicaSet").
   *
   * @generated from field: string kind = 1;
   */
  kind: string;

  /**
   * Kubernetes namespace.
   *
   * @generated from field: string namespace = 2;
   */
  namespace: string;

  /**
   * Object name.
   *
   * @generated from field: string name = 3;
   */
  name: string;
};

/**
 * Describes the message admiral.api.cluster.v1.ObjectReference.
 * Use `create(ObjectReferenceSchema)` to create a new message.
 */
export const ObjectReferenceSchema: GenMessage<ObjectReference> = /*@__PURE__*/
  messageDesc(file_cluster_v1_cluster, 4);

/**
 * WorkloadEvent represents a Kubernetes event related to a workload or its
 * child objects (pods, replicasets). Events are deduplicated by their K8s UID.
 *
 * @generated from message admiral.api.cluster.v1.WorkloadEvent
 */
export type WorkloadEvent = Message<"admiral.api.cluster.v1.WorkloadEvent"> & {
  /**
   * Kubernetes event UID, used for deduplication.
   *
   * @generated from field: string uid = 1;
   */
  uid: string;

  /**
   * Event type: "Normal" or "Warning".
   *
   * @generated from field: string type = 2;
   */
  type: string;

  /**
   * Short machine-readable reason (e.g., "BackOff", "FailedScheduling").
   *
   * @generated from field: string reason = 3;
   */
  reason: string;

  /**
   * The Kubernetes object this event is about.
   *
   * @generated from field: admiral.api.cluster.v1.ObjectReference regarding = 4;
   */
  regarding?: ObjectReference;

  /**
   * Human-readable event message.
   *
   * @generated from field: string message = 5;
   */
  message: string;

  /**
   * When this event was first observed.
   *
   * @generated from field: google.protobuf.Timestamp first_seen = 6;
   */
  firstSeen?: Timestamp;

  /**
   * When this event was most recently observed.
   *
   * @generated from field: google.protobuf.Timestamp last_seen = 7;
   */
  lastSeen?: Timestamp;

  /**
   * Number of times this event has occurred.
   *
   * @generated from field: int32 count = 8;
   */
  count: number;
};

/**
 * Describes the message admiral.api.cluster.v1.WorkloadEvent.
 * Use `create(WorkloadEventSchema)` to create a new message.
 */
export const WorkloadEventSchema: GenMessage<WorkloadEvent> = /*@__PURE__*/
  messageDesc(file_cluster_v1_cluster, 5);

/**
 * CreateClusterRequest contains the parameters for creating a new cluster.
 *
 * @generated from message admiral.api.cluster.v1.CreateClusterRequest
 */
export type CreateClusterRequest = Message<"admiral.api.cluster.v1.CreateClusterRequest"> & {
  /**
   * URL-safe, human-readable identifier (e.g., "prod-us-east-1"). Must be
   * unique within the tenant. Lowercase alphanumeric and hyphens only.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Optional longer-form description of the cluster's purpose.
   *
   * @generated from field: string description = 2;
   */
  description: string;

  /**
   * Arbitrary key-value labels for organizing and filtering clusters
   * (e.g., `{"region": "us-east-1", "cloud": "aws"}`).
   *
   * @generated from field: map<string, string> labels = 3;
   */
  labels: { [key: string]: string };
};

/**
 * Describes the message admiral.api.cluster.v1.CreateClusterRequest.
 * Use `create(CreateClusterRequestSchema)` to create a new message.
 */
export const CreateClusterRequestSchema: GenMessage<CreateClusterRequest> = /*@__PURE__*/
  messageDesc(file_cluster_v1_cluster, 6);

/**
 * CreateClusterResponse contains the newly created cluster and its initial
 * Agent Token (AGT).
 *
 * @generated from message admiral.api.cluster.v1.CreateClusterResponse
 */
export type CreateClusterResponse = Message<"admiral.api.cluster.v1.CreateClusterResponse"> & {
  /**
   * The created cluster. Health status will be PENDING until an agent connects
   * and calls AgentAPI.RegisterAgent.
   *
   * @generated from field: admiral.api.cluster.v1.Cluster cluster = 1;
   */
  cluster?: Cluster;

  /**
   * The raw Agent Token secret (e.g., "adm_agt_pL2mN5oQ8rS1..."). This value
   * is shown exactly once and cannot be retrieved again. Deploy this token to
   * the K8s agent for authentication.
   *
   * To create additional tokens (e.g., for rotation), use
   * AccessTokenAPI.CreateAgentToken.
   *
   * @generated from field: string plain_text_token = 2;
   */
  plainTextToken: string;
};

/**
 * Describes the message admiral.api.cluster.v1.CreateClusterResponse.
 * Use `create(CreateClusterResponseSchema)` to create a new message.
 */
export const CreateClusterResponseSchema: GenMessage<CreateClusterResponse> = /*@__PURE__*/
  messageDesc(file_cluster_v1_cluster, 7);

/**
 * GetClusterRequest identifies a cluster to retrieve.
 *
 * @generated from message admiral.api.cluster.v1.GetClusterRequest
 */
export type GetClusterRequest = Message<"admiral.api.cluster.v1.GetClusterRequest"> & {
  /**
   * The unique identifier of the cluster (UUID).
   *
   * @generated from field: string cluster_id = 1;
   */
  clusterId: string;
};

/**
 * Describes the message admiral.api.cluster.v1.GetClusterRequest.
 * Use `create(GetClusterRequestSchema)` to create a new message.
 */
export const GetClusterRequestSchema: GenMessage<GetClusterRequest> = /*@__PURE__*/
  messageDesc(file_cluster_v1_cluster, 8);

/**
 * GetClusterResponse contains the cluster record.
 *
 * @generated from message admiral.api.cluster.v1.GetClusterResponse
 */
export type GetClusterResponse = Message<"admiral.api.cluster.v1.GetClusterResponse"> & {
  /**
   * The cluster record, including server-derived health_status.
   *
   * @generated from field: admiral.api.cluster.v1.Cluster cluster = 1;
   */
  cluster?: Cluster;
};

/**
 * Describes the message admiral.api.cluster.v1.GetClusterResponse.
 * Use `create(GetClusterResponseSchema)` to create a new message.
 */
export const GetClusterResponseSchema: GenMessage<GetClusterResponse> = /*@__PURE__*/
  messageDesc(file_cluster_v1_cluster, 9);

/**
 * ListClustersRequest contains pagination and filter parameters.
 *
 * @generated from message admiral.api.cluster.v1.ListClustersRequest
 */
export type ListClustersRequest = Message<"admiral.api.cluster.v1.ListClustersRequest"> & {
  /**
   * Filter expression using the PEG filter DSL
   *
   * @generated from field: string filter = 1;
   */
  filter: string;

  /**
   * Maximum number of clusters to return per page.
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize: number;

  /**
   * Opaque pagination token from a previous response.
   *
   * @generated from field: string page_token = 3;
   */
  pageToken: string;
};

/**
 * Describes the message admiral.api.cluster.v1.ListClustersRequest.
 * Use `create(ListClustersRequestSchema)` to create a new message.
 */
export const ListClustersRequestSchema: GenMessage<ListClustersRequest> = /*@__PURE__*/
  messageDesc(file_cluster_v1_cluster, 10);

/**
 * ListClustersResponse contains a page of clusters.
 *
 * @generated from message admiral.api.cluster.v1.ListClustersResponse
 */
export type ListClustersResponse = Message<"admiral.api.cluster.v1.ListClustersResponse"> & {
  /**
   * The list of clusters.
   *
   * @generated from field: repeated admiral.api.cluster.v1.Cluster clusters = 1;
   */
  clusters: Cluster[];

  /**
   * Pagination token for the next page. Empty when there are no more results.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;
};

/**
 * Describes the message admiral.api.cluster.v1.ListClustersResponse.
 * Use `create(ListClustersResponseSchema)` to create a new message.
 */
export const ListClustersResponseSchema: GenMessage<ListClustersResponse> = /*@__PURE__*/
  messageDesc(file_cluster_v1_cluster, 11);

/**
 * UpdateClusterRequest contains the cluster fields to update.
 *
 * @generated from message admiral.api.cluster.v1.UpdateClusterRequest
 */
export type UpdateClusterRequest = Message<"admiral.api.cluster.v1.UpdateClusterRequest"> & {
  /**
   * The cluster with updated fields. The `id` field is required.
   * Only fields specified in `update_mask` are updated.
   *
   * @generated from field: admiral.api.cluster.v1.Cluster cluster = 1;
   */
  cluster?: Cluster;

  /**
   * The set of fields to update. If unset, all mutable fields are updated.
   * Supported fields: `name`, `description`, `labels`.
   *
   * @generated from field: google.protobuf.FieldMask update_mask = 2;
   */
  updateMask?: FieldMask;
};

/**
 * Describes the message admiral.api.cluster.v1.UpdateClusterRequest.
 * Use `create(UpdateClusterRequestSchema)` to create a new message.
 */
export const UpdateClusterRequestSchema: GenMessage<UpdateClusterRequest> = /*@__PURE__*/
  messageDesc(file_cluster_v1_cluster, 12);

/**
 * UpdateClusterResponse contains the updated cluster.
 *
 * @generated from message admiral.api.cluster.v1.UpdateClusterResponse
 */
export type UpdateClusterResponse = Message<"admiral.api.cluster.v1.UpdateClusterResponse"> & {
  /**
   * The updated cluster.
   *
   * @generated from field: admiral.api.cluster.v1.Cluster cluster = 1;
   */
  cluster?: Cluster;
};

/**
 * Describes the message admiral.api.cluster.v1.UpdateClusterResponse.
 * Use `create(UpdateClusterResponseSchema)` to create a new message.
 */
export const UpdateClusterResponseSchema: GenMessage<UpdateClusterResponse> = /*@__PURE__*/
  messageDesc(file_cluster_v1_cluster, 13);

/**
 * DeleteClusterRequest identifies a cluster to delete.
 *
 * @generated from message admiral.api.cluster.v1.DeleteClusterRequest
 */
export type DeleteClusterRequest = Message<"admiral.api.cluster.v1.DeleteClusterRequest"> & {
  /**
   * The unique identifier of the cluster to delete (UUID).
   * All associated agent tokens will be revoked.
   *
   * @generated from field: string cluster_id = 1;
   */
  clusterId: string;
};

/**
 * Describes the message admiral.api.cluster.v1.DeleteClusterRequest.
 * Use `create(DeleteClusterRequestSchema)` to create a new message.
 */
export const DeleteClusterRequestSchema: GenMessage<DeleteClusterRequest> = /*@__PURE__*/
  messageDesc(file_cluster_v1_cluster, 14);

/**
 * DeleteClusterResponse is empty on success.
 *
 * @generated from message admiral.api.cluster.v1.DeleteClusterResponse
 */
export type DeleteClusterResponse = Message<"admiral.api.cluster.v1.DeleteClusterResponse"> & {
};

/**
 * Describes the message admiral.api.cluster.v1.DeleteClusterResponse.
 * Use `create(DeleteClusterResponseSchema)` to create a new message.
 */
export const DeleteClusterResponseSchema: GenMessage<DeleteClusterResponse> = /*@__PURE__*/
  messageDesc(file_cluster_v1_cluster, 15);

/**
 * GetClusterStatusRequest identifies a cluster whose telemetry status to retrieve.
 *
 * @generated from message admiral.api.cluster.v1.GetClusterStatusRequest
 */
export type GetClusterStatusRequest = Message<"admiral.api.cluster.v1.GetClusterStatusRequest"> & {
  /**
   * The unique identifier of the cluster (UUID).
   *
   * @generated from field: string cluster_id = 1;
   */
  clusterId: string;
};

/**
 * Describes the message admiral.api.cluster.v1.GetClusterStatusRequest.
 * Use `create(GetClusterStatusRequestSchema)` to create a new message.
 */
export const GetClusterStatusRequestSchema: GenMessage<GetClusterStatusRequest> = /*@__PURE__*/
  messageDesc(file_cluster_v1_cluster, 16);

/**
 * GetClusterStatusResponse contains the server-derived health status and the
 * latest telemetry snapshot. If no agent has reported telemetry yet, the
 * health_status will be PENDING and status will be absent.
 *
 * @generated from message admiral.api.cluster.v1.GetClusterStatusResponse
 */
export type GetClusterStatusResponse = Message<"admiral.api.cluster.v1.GetClusterStatusResponse"> & {
  /**
   * Server-derived health status based on agent connectivity, node readiness,
   * and workload health.
   *
   * @generated from field: admiral.api.cluster.v1.ClusterHealthStatus health_status = 1;
   */
  healthStatus: ClusterHealthStatus;

  /**
   * Latest telemetry snapshot from the agent. Absent if no telemetry has
   * been reported yet.
   *
   * @generated from field: admiral.api.cluster.v1.ClusterStatus status = 2;
   */
  status?: ClusterStatus;

  /**
   * When the latest telemetry was reported by the agent.
   *
   * @generated from field: google.protobuf.Timestamp reported_at = 3;
   */
  reportedAt?: Timestamp;
};

/**
 * Describes the message admiral.api.cluster.v1.GetClusterStatusResponse.
 * Use `create(GetClusterStatusResponseSchema)` to create a new message.
 */
export const GetClusterStatusResponseSchema: GenMessage<GetClusterStatusResponse> = /*@__PURE__*/
  messageDesc(file_cluster_v1_cluster, 17);

/**
 * ReportClusterStatusRequest contains a combined telemetry payload from a K8s agent.
 * Admiral splits this into three storage tiers: current snapshot, time-series
 * metrics, and events.
 *
 * @generated from message admiral.api.cluster.v1.ReportClusterStatusRequest
 */
export type ReportClusterStatusRequest = Message<"admiral.api.cluster.v1.ReportClusterStatusRequest"> & {
  /**
   * The cluster this status report is for (UUID).
   *
   * @generated from field: string cluster_id = 1;
   */
  clusterId: string;

  /**
   * Cluster-level telemetry snapshot.
   *
   * @generated from field: admiral.api.cluster.v1.ClusterStatus status = 2;
   */
  status?: ClusterStatus;

  /**
   * Per-workload status snapshots.
   *
   * @generated from field: repeated admiral.api.cluster.v1.WorkloadStatus workloads = 3;
   */
  workloads: WorkloadStatus[];

  /**
   * Kubernetes events observed since the last push.
   *
   * @generated from field: repeated admiral.api.cluster.v1.WorkloadEvent events = 4;
   */
  events: WorkloadEvent[];

  /**
   * When the agent generated this report.
   *
   * @generated from field: google.protobuf.Timestamp reported_at = 5;
   */
  reportedAt?: Timestamp;
};

/**
 * Describes the message admiral.api.cluster.v1.ReportClusterStatusRequest.
 * Use `create(ReportClusterStatusRequestSchema)` to create a new message.
 */
export const ReportClusterStatusRequestSchema: GenMessage<ReportClusterStatusRequest> = /*@__PURE__*/
  messageDesc(file_cluster_v1_cluster, 18);

/**
 * WorkloadStatus is the agent-reported status for a single workload within
 * a telemetry push payload.
 *
 * @generated from message admiral.api.cluster.v1.WorkloadStatus
 */
export type WorkloadStatus = Message<"admiral.api.cluster.v1.WorkloadStatus"> & {
  /**
   * Kubernetes namespace.
   *
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * Workload name.
   *
   * @generated from field: string name = 2;
   */
  name: string;

  /**
   * Kubernetes resource kind (e.g., "Deployment", "StatefulSet").
   *
   * @generated from field: string kind = 3;
   */
  kind: string;

  /**
   * Kubernetes labels on the workload.
   *
   * @generated from field: map<string, string> labels = 4;
   */
  labels: { [key: string]: string };

  /**
   * Number of desired replicas.
   *
   * @generated from field: int32 replicas_desired = 5;
   */
  replicasDesired: number;

  /**
   * Number of ready replicas.
   *
   * @generated from field: int32 replicas_ready = 6;
   */
  replicasReady: number;

  /**
   * Number of available replicas.
   *
   * @generated from field: int32 replicas_available = 7;
   */
  replicasAvailable: number;

  /**
   * CPU requests across all containers, in millicores.
   *
   * @generated from field: int64 cpu_requests_millicores = 8;
   */
  cpuRequestsMillicores: bigint;

  /**
   * CPU limits across all containers, in millicores.
   *
   * @generated from field: int64 cpu_limits_millicores = 9;
   */
  cpuLimitsMillicores: bigint;

  /**
   * Current CPU usage across all containers, in millicores.
   *
   * @generated from field: int64 cpu_used_millicores = 10;
   */
  cpuUsedMillicores: bigint;

  /**
   * Memory requests across all containers, in bytes.
   *
   * @generated from field: int64 memory_requests_bytes = 11;
   */
  memoryRequestsBytes: bigint;

  /**
   * Memory limits across all containers, in bytes.
   *
   * @generated from field: int64 memory_limits_bytes = 12;
   */
  memoryLimitsBytes: bigint;

  /**
   * Current memory usage across all containers, in bytes.
   *
   * @generated from field: int64 memory_used_bytes = 13;
   */
  memoryUsedBytes: bigint;

  /**
   * Derived health status.
   *
   * @generated from field: admiral.api.cluster.v1.WorkloadHealthStatus health_status = 14;
   */
  healthStatus: WorkloadHealthStatus;

  /**
   * Status of individual containers.
   *
   * @generated from field: repeated admiral.api.cluster.v1.ContainerStatus containers = 15;
   */
  containers: ContainerStatus[];
};

/**
 * Describes the message admiral.api.cluster.v1.WorkloadStatus.
 * Use `create(WorkloadStatusSchema)` to create a new message.
 */
export const WorkloadStatusSchema: GenMessage<WorkloadStatus> = /*@__PURE__*/
  messageDesc(file_cluster_v1_cluster, 19);

/**
 * ReportClusterStatusResponse acknowledges a telemetry push.
 *
 * @generated from message admiral.api.cluster.v1.ReportClusterStatusResponse
 */
export type ReportClusterStatusResponse = Message<"admiral.api.cluster.v1.ReportClusterStatusResponse"> & {
  /**
   * Whether the report was accepted.
   *
   * @generated from field: bool ack = 1;
   */
  ack: boolean;

  /**
   * Server-controlled interval (in seconds) before the agent should send
   * its next status push. Allows the server to adjust push frequency dynamically.
   *
   * @generated from field: int32 next_push_seconds = 2;
   */
  nextPushSeconds: number;
};

/**
 * Describes the message admiral.api.cluster.v1.ReportClusterStatusResponse.
 * Use `create(ReportClusterStatusResponseSchema)` to create a new message.
 */
export const ReportClusterStatusResponseSchema: GenMessage<ReportClusterStatusResponse> = /*@__PURE__*/
  messageDesc(file_cluster_v1_cluster, 20);

/**
 * ListWorkloadsRequest contains pagination and filter parameters for listing
 * workloads in a specific cluster.
 *
 * @generated from message admiral.api.cluster.v1.ListWorkloadsRequest
 */
export type ListWorkloadsRequest = Message<"admiral.api.cluster.v1.ListWorkloadsRequest"> & {
  /**
   * The cluster whose workloads to list (UUID).
   *
   * @generated from field: string cluster_id = 1;
   */
  clusterId: string;

  /**
   * Filter expression using the PEG filter DSL
   *
   * @generated from field: string filter = 2;
   */
  filter: string;

  /**
   * Maximum number of workloads to return per page.
   *
   * @generated from field: int32 page_size = 3;
   */
  pageSize: number;

  /**
   * Opaque pagination token from a previous response.
   *
   * @generated from field: string page_token = 4;
   */
  pageToken: string;
};

/**
 * Describes the message admiral.api.cluster.v1.ListWorkloadsRequest.
 * Use `create(ListWorkloadsRequestSchema)` to create a new message.
 */
export const ListWorkloadsRequestSchema: GenMessage<ListWorkloadsRequest> = /*@__PURE__*/
  messageDesc(file_cluster_v1_cluster, 21);

/**
 * ListWorkloadsResponse contains a page of workloads.
 *
 * @generated from message admiral.api.cluster.v1.ListWorkloadsResponse
 */
export type ListWorkloadsResponse = Message<"admiral.api.cluster.v1.ListWorkloadsResponse"> & {
  /**
   * The list of workloads.
   *
   * @generated from field: repeated admiral.api.cluster.v1.Workload workloads = 1;
   */
  workloads: Workload[];

  /**
   * Pagination token for the next page. Empty when there are no more results.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;
};

/**
 * Describes the message admiral.api.cluster.v1.ListWorkloadsResponse.
 * Use `create(ListWorkloadsResponseSchema)` to create a new message.
 */
export const ListWorkloadsResponseSchema: GenMessage<ListWorkloadsResponse> = /*@__PURE__*/
  messageDesc(file_cluster_v1_cluster, 22);

/**
 * ReportWorkloadStatusRequest contains incremental workload telemetry from a K8s agent.
 *
 * @generated from message admiral.api.cluster.v1.ReportWorkloadStatusRequest
 */
export type ReportWorkloadStatusRequest = Message<"admiral.api.cluster.v1.ReportWorkloadStatusRequest"> & {
  /**
   * The cluster these workloads belong to (UUID).
   *
   * @generated from field: string cluster_id = 1;
   */
  clusterId: string;

  /**
   * Per-workload status snapshots.
   *
   * @generated from field: repeated admiral.api.cluster.v1.WorkloadStatus workloads = 2;
   */
  workloads: WorkloadStatus[];

  /**
   * When the agent generated this report.
   *
   * @generated from field: google.protobuf.Timestamp reported_at = 3;
   */
  reportedAt?: Timestamp;
};

/**
 * Describes the message admiral.api.cluster.v1.ReportWorkloadStatusRequest.
 * Use `create(ReportWorkloadStatusRequestSchema)` to create a new message.
 */
export const ReportWorkloadStatusRequestSchema: GenMessage<ReportWorkloadStatusRequest> = /*@__PURE__*/
  messageDesc(file_cluster_v1_cluster, 23);

/**
 * ReportWorkloadStatusResponse acknowledges a workload telemetry push.
 *
 * @generated from message admiral.api.cluster.v1.ReportWorkloadStatusResponse
 */
export type ReportWorkloadStatusResponse = Message<"admiral.api.cluster.v1.ReportWorkloadStatusResponse"> & {
  /**
   * Whether the report was accepted.
   *
   * @generated from field: bool ack = 1;
   */
  ack: boolean;
};

/**
 * Describes the message admiral.api.cluster.v1.ReportWorkloadStatusResponse.
 * Use `create(ReportWorkloadStatusResponseSchema)` to create a new message.
 */
export const ReportWorkloadStatusResponseSchema: GenMessage<ReportWorkloadStatusResponse> = /*@__PURE__*/
  messageDesc(file_cluster_v1_cluster, 24);

/**
 * CreateClusterTokenRequest contains the parameters for creating a new AGT
 * bound to a cluster.
 *
 * @generated from message admiral.api.cluster.v1.CreateClusterTokenRequest
 */
export type CreateClusterTokenRequest = Message<"admiral.api.cluster.v1.CreateClusterTokenRequest"> & {
  /**
   * The cluster to bind this token to (UUID).
   *
   * @generated from field: string cluster_id = 1;
   */
  clusterId: string;

  /**
   * Human-readable name for the token (e.g., "prod-us-east-1-agent-key").
   *
   * @generated from field: string display_name = 2;
   */
  displayName: string;

  /**
   * Optional expiration time. If unset, the token does not expire.
   *
   * @generated from field: google.protobuf.Timestamp expires_at = 3;
   */
  expiresAt?: Timestamp;
};

/**
 * Describes the message admiral.api.cluster.v1.CreateClusterTokenRequest.
 * Use `create(CreateClusterTokenRequestSchema)` to create a new message.
 */
export const CreateClusterTokenRequestSchema: GenMessage<CreateClusterTokenRequest> = /*@__PURE__*/
  messageDesc(file_cluster_v1_cluster, 25);

/**
 * CreateClusterTokenResponse contains the newly created AGT.
 *
 * @generated from message admiral.api.cluster.v1.CreateClusterTokenResponse
 */
export type CreateClusterTokenResponse = Message<"admiral.api.cluster.v1.CreateClusterTokenResponse"> & {
  /**
   * The created token metadata. Scopes are auto-assigned for cluster AGTs.
   *
   * @generated from field: admiral.common.v1.AccessToken access_token = 1;
   */
  accessToken?: AccessToken;

  /**
   * The raw token secret (e.g., "adm_agt_pL2mN5oQ8rS1..."). This value is
   * shown exactly once and cannot be retrieved again. Store it securely.
   *
   * @generated from field: string plain_text_token = 2;
   */
  plainTextToken: string;
};

/**
 * Describes the message admiral.api.cluster.v1.CreateClusterTokenResponse.
 * Use `create(CreateClusterTokenResponseSchema)` to create a new message.
 */
export const CreateClusterTokenResponseSchema: GenMessage<CreateClusterTokenResponse> = /*@__PURE__*/
  messageDesc(file_cluster_v1_cluster, 26);

/**
 * ListClusterTokensRequest contains pagination and filter parameters.
 *
 * @generated from message admiral.api.cluster.v1.ListClusterTokensRequest
 */
export type ListClusterTokensRequest = Message<"admiral.api.cluster.v1.ListClusterTokensRequest"> & {
  /**
   * The cluster whose tokens to list (UUID).
   *
   * @generated from field: string cluster_id = 1;
   */
  clusterId: string;

  /**
   * Maximum number of tokens to return per page.
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize: number;

  /**
   * Opaque pagination token from a previous response.
   *
   * @generated from field: string page_token = 3;
   */
  pageToken: string;

  /**
   * Filter expression using the PEG filter DSL.
   *
   * @generated from field: string filter = 4;
   */
  filter: string;
};

/**
 * Describes the message admiral.api.cluster.v1.ListClusterTokensRequest.
 * Use `create(ListClusterTokensRequestSchema)` to create a new message.
 */
export const ListClusterTokensRequestSchema: GenMessage<ListClusterTokensRequest> = /*@__PURE__*/
  messageDesc(file_cluster_v1_cluster, 27);

/**
 * ListClusterTokensResponse contains a page of cluster AGT metadata.
 *
 * @generated from message admiral.api.cluster.v1.ListClusterTokensResponse
 */
export type ListClusterTokensResponse = Message<"admiral.api.cluster.v1.ListClusterTokensResponse"> & {
  /**
   * The list of tokens. Token secrets are never included.
   *
   * @generated from field: repeated admiral.common.v1.AccessToken access_tokens = 1;
   */
  accessTokens: AccessToken[];

  /**
   * Pagination token for the next page. Empty when there are no more results.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;
};

/**
 * Describes the message admiral.api.cluster.v1.ListClusterTokensResponse.
 * Use `create(ListClusterTokensResponseSchema)` to create a new message.
 */
export const ListClusterTokensResponseSchema: GenMessage<ListClusterTokensResponse> = /*@__PURE__*/
  messageDesc(file_cluster_v1_cluster, 28);

/**
 * GetClusterTokenRequest identifies a cluster AGT to retrieve.
 *
 * @generated from message admiral.api.cluster.v1.GetClusterTokenRequest
 */
export type GetClusterTokenRequest = Message<"admiral.api.cluster.v1.GetClusterTokenRequest"> & {
  /**
   * The cluster the token belongs to (UUID).
   *
   * @generated from field: string cluster_id = 1;
   */
  clusterId: string;

  /**
   * The unique identifier of the token (UUID).
   *
   * @generated from field: string token_id = 2;
   */
  tokenId: string;
};

/**
 * Describes the message admiral.api.cluster.v1.GetClusterTokenRequest.
 * Use `create(GetClusterTokenRequestSchema)` to create a new message.
 */
export const GetClusterTokenRequestSchema: GenMessage<GetClusterTokenRequest> = /*@__PURE__*/
  messageDesc(file_cluster_v1_cluster, 29);

/**
 * GetClusterTokenResponse contains the requested cluster AGT metadata.
 *
 * @generated from message admiral.api.cluster.v1.GetClusterTokenResponse
 */
export type GetClusterTokenResponse = Message<"admiral.api.cluster.v1.GetClusterTokenResponse"> & {
  /**
   * The token metadata. The token secret is never included.
   *
   * @generated from field: admiral.common.v1.AccessToken access_token = 1;
   */
  accessToken?: AccessToken;
};

/**
 * Describes the message admiral.api.cluster.v1.GetClusterTokenResponse.
 * Use `create(GetClusterTokenResponseSchema)` to create a new message.
 */
export const GetClusterTokenResponseSchema: GenMessage<GetClusterTokenResponse> = /*@__PURE__*/
  messageDesc(file_cluster_v1_cluster, 30);

/**
 * RevokeClusterTokenRequest identifies a cluster AGT to revoke.
 *
 * @generated from message admiral.api.cluster.v1.RevokeClusterTokenRequest
 */
export type RevokeClusterTokenRequest = Message<"admiral.api.cluster.v1.RevokeClusterTokenRequest"> & {
  /**
   * The cluster the token belongs to (UUID).
   *
   * @generated from field: string cluster_id = 1;
   */
  clusterId: string;

  /**
   * The unique identifier of the token to revoke (UUID).
   *
   * @generated from field: string token_id = 2;
   */
  tokenId: string;
};

/**
 * Describes the message admiral.api.cluster.v1.RevokeClusterTokenRequest.
 * Use `create(RevokeClusterTokenRequestSchema)` to create a new message.
 */
export const RevokeClusterTokenRequestSchema: GenMessage<RevokeClusterTokenRequest> = /*@__PURE__*/
  messageDesc(file_cluster_v1_cluster, 31);

/**
 * RevokeClusterTokenResponse contains the revoked cluster AGT metadata.
 *
 * @generated from message admiral.api.cluster.v1.RevokeClusterTokenResponse
 */
export type RevokeClusterTokenResponse = Message<"admiral.api.cluster.v1.RevokeClusterTokenResponse"> & {
  /**
   * The token metadata with updated status.
   *
   * @generated from field: admiral.common.v1.AccessToken access_token = 1;
   */
  accessToken?: AccessToken;
};

/**
 * Describes the message admiral.api.cluster.v1.RevokeClusterTokenResponse.
 * Use `create(RevokeClusterTokenResponseSchema)` to create a new message.
 */
export const RevokeClusterTokenResponseSchema: GenMessage<RevokeClusterTokenResponse> = /*@__PURE__*/
  messageDesc(file_cluster_v1_cluster, 32);

/**
 * ClusterHealthStatus represents the derived health state of a cluster.
 * The status is computed from agent connectivity, node readiness, and workload health.
 *
 * @generated from enum admiral.api.cluster.v1.ClusterHealthStatus
 */
export enum ClusterHealthStatus {
  /**
   * Default value. Must not be used.
   *
   * @generated from enum value: CLUSTER_HEALTH_STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Cluster record exists but no agent has registered yet.
   *
   * @generated from enum value: CLUSTER_HEALTH_STATUS_PENDING = 1;
   */
  PENDING = 1,

  /**
   * Agent connected, all nodes ready, less than 10% workloads degraded.
   *
   * @generated from enum value: CLUSTER_HEALTH_STATUS_HEALTHY = 2;
   */
  HEALTHY = 2,

  /**
   * Agent connected, some nodes not ready or workloads in error/degraded state.
   *
   * @generated from enum value: CLUSTER_HEALTH_STATUS_DEGRADED = 3;
   */
  DEGRADED = 3,

  /**
   * Agent connected, more than 25% nodes not ready or workloads in error state.
   *
   * @generated from enum value: CLUSTER_HEALTH_STATUS_ERROR = 4;
   */
  ERROR = 4,

  /**
   * No heartbeat received within 3x the heartbeat interval.
   *
   * @generated from enum value: CLUSTER_HEALTH_STATUS_UNREACHABLE = 5;
   */
  UNREACHABLE = 5,
}

/**
 * Describes the enum admiral.api.cluster.v1.ClusterHealthStatus.
 */
export const ClusterHealthStatusSchema: GenEnum<ClusterHealthStatus> = /*@__PURE__*/
  enumDesc(file_cluster_v1_cluster, 0);

/**
 * WorkloadHealthStatus represents the derived health state of a single workload.
 *
 * @generated from enum admiral.api.cluster.v1.WorkloadHealthStatus
 */
export enum WorkloadHealthStatus {
  /**
   * Default value. Must not be used.
   *
   * @generated from enum value: WORKLOAD_HEALTH_STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * All desired replicas ready, no CrashLoopBackOff, restarts stable.
   *
   * @generated from enum value: WORKLOAD_HEALTH_STATUS_HEALTHY = 1;
   */
  HEALTHY = 1,

  /**
   * Some replicas not ready, restarts increasing, or pods pending over 5 minutes.
   *
   * @generated from enum value: WORKLOAD_HEALTH_STATUS_DEGRADED = 2;
   */
  DEGRADED = 2,

  /**
   * Zero ready replicas, all containers CrashLoopBackOff, or deployment stuck.
   *
   * @generated from enum value: WORKLOAD_HEALTH_STATUS_ERROR = 3;
   */
  ERROR = 3,
}

/**
 * Describes the enum admiral.api.cluster.v1.WorkloadHealthStatus.
 */
export const WorkloadHealthStatusSchema: GenEnum<WorkloadHealthStatus> = /*@__PURE__*/
  enumDesc(file_cluster_v1_cluster, 1);

/**
 * ClusterAPI manages Kubernetes clusters and their workload telemetry.
 *
 * Administrators create clusters via CreateCluster, which returns an Agent
 * Token (AGT) for deploying the K8s agent. Once the agent boots and calls
 * AgentAPI.RegisterAgent, the cluster transitions from PENDING to HEALTHY
 * and begins receiving telemetry.
 *
 * The telemetry model has three tiers: current snapshot (upserted per push),
 * time-series metrics (rolling 48-hour window), and events (rolling 7-day window).
 *
 * @generated from service admiral.api.cluster.v1.ClusterAPI
 */
export const ClusterAPI: GenService<{
  /**
   * CreateCluster creates a new cluster record within the caller's tenant and
   * generates an initial Agent Token (AGT) for the K8s agent. The cluster
   * starts in PENDING status until an agent registers against it.
   *
   * The response includes a `plain_text_token` â€” the raw AGT secret shown
   * exactly once. Deploy this token to the K8s agent (e.g., via Helm values
   * or a Kubernetes Secret). The agent uses it to authenticate with
   * AgentAPI.RegisterAgent on first boot.
   *
   * Scope: `cluster:write`
   *
   * @generated from rpc admiral.api.cluster.v1.ClusterAPI.CreateCluster
   */
  createCluster: {
    methodKind: "unary";
    input: typeof CreateClusterRequestSchema;
    output: typeof CreateClusterResponseSchema;
  },
  /**
   * GetCluster retrieves a cluster by ID.
   *
   * Returns the Cluster record with its server-derived health_status. For
   * detailed telemetry (node counts, resource usage, workload summary), use
   * GetClusterStatus instead.
   *
   * Scope: `cluster:read`
   *
   * @generated from rpc admiral.api.cluster.v1.ClusterAPI.GetCluster
   */
  getCluster: {
    methodKind: "unary";
    input: typeof GetClusterRequestSchema;
    output: typeof GetClusterResponseSchema;
  },
  /**
   * GetClusterStatus retrieves the current telemetry snapshot for a cluster.
   * Returns the latest metrics pushed by the agent, along with server-derived
   * health status and workload summary counts.
   *
   * Returns NOT_FOUND if the cluster does not exist. If the cluster exists but
   * no agent has reported telemetry yet, the response will have health_status
   * PENDING and no status message.
   *
   * Scope: `cluster:read`
   *
   * @generated from rpc admiral.api.cluster.v1.ClusterAPI.GetClusterStatus
   */
  getClusterStatus: {
    methodKind: "unary";
    input: typeof GetClusterStatusRequestSchema;
    output: typeof GetClusterStatusResponseSchema;
  },
  /**
   * ListClusters returns a paginated list of clusters within the caller's tenant.
   *
   * Scope: `cluster:read`
   *
   * @generated from rpc admiral.api.cluster.v1.ClusterAPI.ListClusters
   */
  listClusters: {
    methodKind: "unary";
    input: typeof ListClustersRequestSchema;
    output: typeof ListClustersResponseSchema;
  },
  /**
   * UpdateCluster updates a cluster's mutable fields.
   * Use the `update_mask` to specify which fields to update.
   *
   * Scope: `cluster:write`
   *
   * @generated from rpc admiral.api.cluster.v1.ClusterAPI.UpdateCluster
   */
  updateCluster: {
    methodKind: "unary";
    input: typeof UpdateClusterRequestSchema;
    output: typeof UpdateClusterResponseSchema;
  },
  /**
   * DeleteCluster permanently deletes a cluster record and revokes all
   * associated agent tokens. This action cannot be undone.
   *
   * Scope: `cluster:write`
   *
   * @generated from rpc admiral.api.cluster.v1.ClusterAPI.DeleteCluster
   */
  deleteCluster: {
    methodKind: "unary";
    input: typeof DeleteClusterRequestSchema;
    output: typeof DeleteClusterResponseSchema;
  },
  /**
   * CreateClusterToken creates a new Agent Token (AGT) bound to the specified
   * cluster. Scopes are auto-assigned and cannot be overridden. The response
   * includes the raw token secret, which is shown exactly once.
   *
   * Use this to create additional AGTs for an existing cluster (e.g., for
   * zero-downtime token rotation). The initial AGT is created automatically
   * by CreateCluster.
   *
   * Scope: `cluster:write`
   *
   * @generated from rpc admiral.api.cluster.v1.ClusterAPI.CreateClusterToken
   */
  createClusterToken: {
    methodKind: "unary";
    input: typeof CreateClusterTokenRequestSchema;
    output: typeof CreateClusterTokenResponseSchema;
  },
  /**
   * ListClusterTokens returns a paginated list of AGTs bound to the specified
   * cluster. Token secrets are never included.
   *
   * Scope: `cluster:read`
   *
   * @generated from rpc admiral.api.cluster.v1.ClusterAPI.ListClusterTokens
   */
  listClusterTokens: {
    methodKind: "unary";
    input: typeof ListClusterTokensRequestSchema;
    output: typeof ListClusterTokensResponseSchema;
  },
  /**
   * GetClusterToken retrieves a single AGT by ID.
   * Returns metadata only â€” the token secret is never included.
   *
   * Scope: `cluster:read`
   *
   * @generated from rpc admiral.api.cluster.v1.ClusterAPI.GetClusterToken
   */
  getClusterToken: {
    methodKind: "unary";
    input: typeof GetClusterTokenRequestSchema;
    output: typeof GetClusterTokenResponseSchema;
  },
  /**
   * RevokeClusterToken permanently revokes an AGT bound to this cluster.
   * The agent will receive a 401 on its next request. If this is the only
   * active AGT for the cluster, the agent will become disconnected.
   *
   * Scope: `cluster:write`
   *
   * @generated from rpc admiral.api.cluster.v1.ClusterAPI.RevokeClusterToken
   */
  revokeClusterToken: {
    methodKind: "unary";
    input: typeof RevokeClusterTokenRequestSchema;
    output: typeof RevokeClusterTokenResponseSchema;
  },
  /**
   * ReportClusterStatus receives a combined telemetry snapshot from a K8s agent.
   * The payload includes cluster-level metrics, per-workload status, and
   * Kubernetes events. Admiral splits this into three storage tiers on receipt.
   *
   * This endpoint is agent-facing and restricted to agent tokens.
   *
   * Scope: `cluster:status` | Token types: `agt`
   *
   * @generated from rpc admiral.api.cluster.v1.ClusterAPI.ReportClusterStatus
   */
  reportClusterStatus: {
    methodKind: "unary";
    input: typeof ReportClusterStatusRequestSchema;
    output: typeof ReportClusterStatusResponseSchema;
  },
  /**
   * ListWorkloads returns a paginated list of workloads running in a specific cluster.
   *
   * Scope: `cluster:read`
   *
   * @generated from rpc admiral.api.cluster.v1.ClusterAPI.ListWorkloads
   */
  listWorkloads: {
    methodKind: "unary";
    input: typeof ListWorkloadsRequestSchema;
    output: typeof ListWorkloadsResponseSchema;
  },
  /**
   * ReportWorkloadStatus receives workload-only telemetry from a K8s agent.
   * Used for incremental workload updates between full cluster status pushes.
   *
   * This endpoint is agent-facing and restricted to agent tokens.
   *
   * Scope: `cluster:status` | Token types: `agt`
   *
   * @generated from rpc admiral.api.cluster.v1.ClusterAPI.ReportWorkloadStatus
   */
  reportWorkloadStatus: {
    methodKind: "unary";
    input: typeof ReportWorkloadStatusRequestSchema;
    output: typeof ReportWorkloadStatusResponseSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_cluster_v1_cluster, 0);

