// @generated by protoc-gen-es v2.11.0 with parameter "target=ts"
// @generated from file cluster/v1/cluster.proto (package admiral.api.cluster.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv2";
import { enumDesc, fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv2";
import type { AccessToken } from "../../accesstoken/v1/accesstoken_pb";
import { file_accesstoken_v1_accesstoken } from "../../accesstoken/v1/accesstoken_pb";
import { file_authz_v1_annotations } from "../../authz/v1/annotations_pb";
import { file_buf_validate_validate } from "../../buf/validate/validate_pb";
import { file_google_api_annotations } from "../../google/api/annotations_pb";
import type { FieldMask, Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_field_mask, file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file cluster/v1/cluster.proto.
 */
export const file_cluster_v1_cluster: GenFile = /*@__PURE__*/
  fileDesc("ChhjbHVzdGVyL3YxL2NsdXN0ZXIucHJvdG8SFmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEigwMKB0NsdXN0ZXISFAoCaWQYASABKAlCCLpIBXIDsAEBEhsKCXRlbmFudF9pZBgCIAEoCUIIukgFcgOwAQESIAoMZGlzcGxheV9uYW1lGAMgASgJQgq6SAdyBRABGP8BEjsKBmxhYmVscxgEIAMoCzIrLmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEuQ2x1c3Rlci5MYWJlbHNFbnRyeRITCgtjbHVzdGVyX3VpZBgFIAEoCRJCCg1oZWFsdGhfc3RhdHVzGAYgASgOMisuYWRtaXJhbC5hcGkuY2x1c3Rlci52MS5DbHVzdGVySGVhbHRoU3RhdHVzEi4KCmNyZWF0ZWRfYXQYByABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEi4KCnVwZGF0ZWRfYXQYCCABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wGi0KC0xhYmVsc0VudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCToCOAEimAMKDUNsdXN0ZXJTdGF0dXMSEwoLazhzX3ZlcnNpb24YASABKAkSEgoKbm9kZV9jb3VudBgCIAEoBRITCgtub2Rlc19yZWFkeRgDIAEoBRIUCgxwb2RfY2FwYWNpdHkYBCABKAUSEQoJcG9kX2NvdW50GAUgASgFEhQKDHBvZHNfcnVubmluZxgGIAEoBRIUCgxwb2RzX3BlbmRpbmcYByABKAUSEwoLcG9kc19mYWlsZWQYCCABKAUSHwoXY3B1X2NhcGFjaXR5X21pbGxpY29yZXMYCSABKAMSGwoTY3B1X3VzZWRfbWlsbGljb3JlcxgKIAEoAxIdChVtZW1vcnlfY2FwYWNpdHlfYnl0ZXMYCyABKAMSGQoRbWVtb3J5X3VzZWRfYnl0ZXMYDCABKAMSFwoPd29ya2xvYWRzX3RvdGFsGA0gASgFEhkKEXdvcmtsb2Fkc19oZWFsdGh5GA4gASgFEhoKEndvcmtsb2Fkc19kZWdyYWRlZBgPIAEoBRIXCg93b3JrbG9hZHNfZXJyb3IYECABKAUilgUKCFdvcmtsb2FkEgoKAmlkGAEgASgJEhIKCmNsdXN0ZXJfaWQYAiABKAkSEQoJbmFtZXNwYWNlGAMgASgJEgwKBG5hbWUYBCABKAkSDAoEa2luZBgFIAEoCRI8CgZsYWJlbHMYBiADKAsyLC5hZG1pcmFsLmFwaS5jbHVzdGVyLnYxLldvcmtsb2FkLkxhYmVsc0VudHJ5EkMKDWhlYWx0aF9zdGF0dXMYByABKA4yLC5hZG1pcmFsLmFwaS5jbHVzdGVyLnYxLldvcmtsb2FkSGVhbHRoU3RhdHVzEhUKDXN0YXR1c19yZWFzb24YCCABKAkSGAoQcmVwbGljYXNfZGVzaXJlZBgJIAEoBRIWCg5yZXBsaWNhc19yZWFkeRgKIAEoBRIaChJyZXBsaWNhc19hdmFpbGFibGUYCyABKAUSHwoXY3B1X3JlcXVlc3RzX21pbGxpY29yZXMYDCABKAMSHQoVY3B1X2xpbWl0c19taWxsaWNvcmVzGA0gASgDEhsKE2NwdV91c2VkX21pbGxpY29yZXMYDiABKAMSHQoVbWVtb3J5X3JlcXVlc3RzX2J5dGVzGA8gASgDEhsKE21lbW9yeV9saW1pdHNfYnl0ZXMYECABKAMSGQoRbWVtb3J5X3VzZWRfYnl0ZXMYESABKAMSOwoKY29udGFpbmVycxgSIAMoCzInLmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEuQ29udGFpbmVyU3RhdHVzEjMKD2xhc3RfdXBkYXRlZF9hdBgTIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAaLQoLTGFiZWxzRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgJOgI4ASJjCg9Db250YWluZXJTdGF0dXMSDAoEbmFtZRgBIAEoCRINCgVpbWFnZRgCIAEoCRIVCg1yZXN0YXJ0X2NvdW50GAMgASgFEg0KBXN0YXRlGAQgASgJEg0KBXJlYWR5GAUgASgIIkAKD09iamVjdFJlZmVyZW5jZRIMCgRraW5kGAEgASgJEhEKCW5hbWVzcGFjZRgCIAEoCRIMCgRuYW1lGAMgASgJIvUBCg1Xb3JrbG9hZEV2ZW50EgsKA3VpZBgBIAEoCRIMCgR0eXBlGAIgASgJEg4KBnJlYXNvbhgDIAEoCRI6CglyZWdhcmRpbmcYBCABKAsyJy5hZG1pcmFsLmFwaS5jbHVzdGVyLnYxLk9iamVjdFJlZmVyZW5jZRIPCgdtZXNzYWdlGAUgASgJEi4KCmZpcnN0X3NlZW4YBiABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEi0KCWxhc3Rfc2VlbhgHIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASDQoFY291bnQYCCABKAUisQEKFENyZWF0ZUNsdXN0ZXJSZXF1ZXN0EiAKDGRpc3BsYXlfbmFtZRgBIAEoCUIKukgHcgUQARj/ARJICgZsYWJlbHMYAiADKAsyOC5hZG1pcmFsLmFwaS5jbHVzdGVyLnYxLkNyZWF0ZUNsdXN0ZXJSZXF1ZXN0LkxhYmVsc0VudHJ5Gi0KC0xhYmVsc0VudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCToCOAEiYwoVQ3JlYXRlQ2x1c3RlclJlc3BvbnNlEjAKB2NsdXN0ZXIYASABKAsyHy5hZG1pcmFsLmFwaS5jbHVzdGVyLnYxLkNsdXN0ZXISGAoQcGxhaW5fdGV4dF90b2tlbhgCIAEoCSIxChFHZXRDbHVzdGVyUmVxdWVzdBIcCgpjbHVzdGVyX2lkGAEgASgJQgi6SAVyA7ABASJGChJHZXRDbHVzdGVyUmVzcG9uc2USMAoHY2x1c3RlchgBIAEoCzIfLmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEuQ2x1c3RlciJMChNMaXN0Q2x1c3RlcnNSZXF1ZXN0EhEKCXBhZ2Vfc2l6ZRgBIAEoBRISCgpwYWdlX3Rva2VuGAIgASgJEg4KBmZpbHRlchgDIAEoCSJiChRMaXN0Q2x1c3RlcnNSZXNwb25zZRIxCghjbHVzdGVycxgBIAMoCzIfLmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEuQ2x1c3RlchIXCg9uZXh0X3BhZ2VfdG9rZW4YAiABKAkigQEKFFVwZGF0ZUNsdXN0ZXJSZXF1ZXN0EjgKB2NsdXN0ZXIYASABKAsyHy5hZG1pcmFsLmFwaS5jbHVzdGVyLnYxLkNsdXN0ZXJCBrpIA8gBARIvCgt1cGRhdGVfbWFzaxgCIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5GaWVsZE1hc2siSQoVVXBkYXRlQ2x1c3RlclJlc3BvbnNlEjAKB2NsdXN0ZXIYASABKAsyHy5hZG1pcmFsLmFwaS5jbHVzdGVyLnYxLkNsdXN0ZXIiNAoURGVsZXRlQ2x1c3RlclJlcXVlc3QSHAoKY2x1c3Rlcl9pZBgBIAEoCUIIukgFcgOwAQEiFwoVRGVsZXRlQ2x1c3RlclJlc3BvbnNlIjcKF0dldENsdXN0ZXJTdGF0dXNSZXF1ZXN0EhwKCmNsdXN0ZXJfaWQYASABKAlCCLpIBXIDsAEBIsYBChhHZXRDbHVzdGVyU3RhdHVzUmVzcG9uc2USQgoNaGVhbHRoX3N0YXR1cxgBIAEoDjIrLmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEuQ2x1c3RlckhlYWx0aFN0YXR1cxI1CgZzdGF0dXMYAiABKAsyJS5hZG1pcmFsLmFwaS5jbHVzdGVyLnYxLkNsdXN0ZXJTdGF0dXMSLwoLcmVwb3J0ZWRfYXQYAyABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wIpwCChpSZXBvcnRDbHVzdGVyU3RhdHVzUmVxdWVzdBIcCgpjbHVzdGVyX2lkGAEgASgJQgi6SAVyA7ABARI9CgZzdGF0dXMYAiABKAsyJS5hZG1pcmFsLmFwaS5jbHVzdGVyLnYxLkNsdXN0ZXJTdGF0dXNCBrpIA8gBARI5Cgl3b3JrbG9hZHMYAyADKAsyJi5hZG1pcmFsLmFwaS5jbHVzdGVyLnYxLldvcmtsb2FkU3RhdHVzEjUKBmV2ZW50cxgEIAMoCzIlLmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEuV29ya2xvYWRFdmVudBIvCgtyZXBvcnRlZF9hdBgFIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAitgQKDldvcmtsb2FkU3RhdHVzEhEKCW5hbWVzcGFjZRgBIAEoCRIMCgRuYW1lGAIgASgJEgwKBGtpbmQYAyABKAkSQgoGbGFiZWxzGAQgAygLMjIuYWRtaXJhbC5hcGkuY2x1c3Rlci52MS5Xb3JrbG9hZFN0YXR1cy5MYWJlbHNFbnRyeRIYChByZXBsaWNhc19kZXNpcmVkGAUgASgFEhYKDnJlcGxpY2FzX3JlYWR5GAYgASgFEhoKEnJlcGxpY2FzX2F2YWlsYWJsZRgHIAEoBRIfChdjcHVfcmVxdWVzdHNfbWlsbGljb3JlcxgIIAEoAxIdChVjcHVfbGltaXRzX21pbGxpY29yZXMYCSABKAMSGwoTY3B1X3VzZWRfbWlsbGljb3JlcxgKIAEoAxIdChVtZW1vcnlfcmVxdWVzdHNfYnl0ZXMYCyABKAMSGwoTbWVtb3J5X2xpbWl0c19ieXRlcxgMIAEoAxIZChFtZW1vcnlfdXNlZF9ieXRlcxgNIAEoAxJDCg1oZWFsdGhfc3RhdHVzGA4gASgOMiwuYWRtaXJhbC5hcGkuY2x1c3Rlci52MS5Xb3JrbG9hZEhlYWx0aFN0YXR1cxI7Cgpjb250YWluZXJzGA8gAygLMicuYWRtaXJhbC5hcGkuY2x1c3Rlci52MS5Db250YWluZXJTdGF0dXMaLQoLTGFiZWxzRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgJOgI4ASJFChtSZXBvcnRDbHVzdGVyU3RhdHVzUmVzcG9uc2USCwoDYWNrGAEgASgIEhkKEW5leHRfcHVzaF9zZWNvbmRzGAIgASgFImsKFExpc3RXb3JrbG9hZHNSZXF1ZXN0EhwKCmNsdXN0ZXJfaWQYASABKAlCCLpIBXIDsAEBEhEKCXBhZ2Vfc2l6ZRgCIAEoBRISCgpwYWdlX3Rva2VuGAMgASgJEg4KBmZpbHRlchgEIAEoCSJlChVMaXN0V29ya2xvYWRzUmVzcG9uc2USMwoJd29ya2xvYWRzGAEgAygLMiAuYWRtaXJhbC5hcGkuY2x1c3Rlci52MS5Xb3JrbG9hZBIXCg9uZXh0X3BhZ2VfdG9rZW4YAiABKAkipwEKG1JlcG9ydFdvcmtsb2FkU3RhdHVzUmVxdWVzdBIcCgpjbHVzdGVyX2lkGAEgASgJQgi6SAVyA7ABARI5Cgl3b3JrbG9hZHMYAiADKAsyJi5hZG1pcmFsLmFwaS5jbHVzdGVyLnYxLldvcmtsb2FkU3RhdHVzEi8KC3JlcG9ydGVkX2F0GAMgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCIrChxSZXBvcnRXb3JrbG9hZFN0YXR1c1Jlc3BvbnNlEgsKA2FjaxgBIAEoCCKLAQoZQ3JlYXRlQ2x1c3RlclRva2VuUmVxdWVzdBIcCgpjbHVzdGVyX2lkGAEgASgJQgi6SAVyA7ABARIgCgxkaXNwbGF5X25hbWUYAiABKAlCCrpIB3IFEAEY/wESLgoKZXhwaXJlc19hdBgDIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAidQoaQ3JlYXRlQ2x1c3RlclRva2VuUmVzcG9uc2USPQoMYWNjZXNzX3Rva2VuGAEgASgLMicuYWRtaXJhbC5hcGkuYWNjZXNzdG9rZW4udjEuQWNjZXNzVG9rZW4SGAoQcGxhaW5fdGV4dF90b2tlbhgCIAEoCSJvChhMaXN0Q2x1c3RlclRva2Vuc1JlcXVlc3QSHAoKY2x1c3Rlcl9pZBgBIAEoCUIIukgFcgOwAQESEQoJcGFnZV9zaXplGAIgASgFEhIKCnBhZ2VfdG9rZW4YAyABKAkSDgoGZmlsdGVyGAQgASgJInQKGUxpc3RDbHVzdGVyVG9rZW5zUmVzcG9uc2USPgoNYWNjZXNzX3Rva2VucxgBIAMoCzInLmFkbWlyYWwuYXBpLmFjY2Vzc3Rva2VuLnYxLkFjY2Vzc1Rva2VuEhcKD25leHRfcGFnZV90b2tlbhgCIAEoCSJSChZHZXRDbHVzdGVyVG9rZW5SZXF1ZXN0EhwKCmNsdXN0ZXJfaWQYASABKAlCCLpIBXIDsAEBEhoKCHRva2VuX2lkGAIgASgJQgi6SAVyA7ABASJYChdHZXRDbHVzdGVyVG9rZW5SZXNwb25zZRI9CgxhY2Nlc3NfdG9rZW4YASABKAsyJy5hZG1pcmFsLmFwaS5hY2Nlc3N0b2tlbi52MS5BY2Nlc3NUb2tlbiJVChlSZXZva2VDbHVzdGVyVG9rZW5SZXF1ZXN0EhwKCmNsdXN0ZXJfaWQYASABKAlCCLpIBXIDsAEBEhoKCHRva2VuX2lkGAIgASgJQgi6SAVyA7ABASJbChpSZXZva2VDbHVzdGVyVG9rZW5SZXNwb25zZRI9CgxhY2Nlc3NfdG9rZW4YASABKAsyJy5hZG1pcmFsLmFwaS5hY2Nlc3N0b2tlbi52MS5BY2Nlc3NUb2tlbiruAQoTQ2x1c3RlckhlYWx0aFN0YXR1cxIlCiFDTFVTVEVSX0hFQUxUSF9TVEFUVVNfVU5TUEVDSUZJRUQQABIhCh1DTFVTVEVSX0hFQUxUSF9TVEFUVVNfUEVORElORxABEiEKHUNMVVNURVJfSEVBTFRIX1NUQVRVU19IRUFMVEhZEAISIgoeQ0xVU1RFUl9IRUFMVEhfU1RBVFVTX0RFR1JBREVEEAMSHwobQ0xVU1RFUl9IRUFMVEhfU1RBVFVTX0VSUk9SEAQSJQohQ0xVU1RFUl9IRUFMVEhfU1RBVFVTX1VOUkVBQ0hBQkxFEAUqqQEKFFdvcmtsb2FkSGVhbHRoU3RhdHVzEiYKIldPUktMT0FEX0hFQUxUSF9TVEFUVVNfVU5TUEVDSUZJRUQQABIiCh5XT1JLTE9BRF9IRUFMVEhfU1RBVFVTX0hFQUxUSFkQARIjCh9XT1JLTE9BRF9IRUFMVEhfU1RBVFVTX0RFR1JBREVEEAISIAocV09SS0xPQURfSEVBTFRIX1NUQVRVU19FUlJPUhADMq4SCgpDbHVzdGVyQVBJEpkBCg1DcmVhdGVDbHVzdGVyEiwuYWRtaXJhbC5hcGkuY2x1c3Rlci52MS5DcmVhdGVDbHVzdGVyUmVxdWVzdBotLmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEuQ3JlYXRlQ2x1c3RlclJlc3BvbnNlIiuCtRgQCg5jbHVzdGVyczp3cml0ZYLT5JMCEToBKiIML3YxL2NsdXN0ZXJzEpkBCgpHZXRDbHVzdGVyEikuYWRtaXJhbC5hcGkuY2x1c3Rlci52MS5HZXRDbHVzdGVyUmVxdWVzdBoqLmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEuR2V0Q2x1c3RlclJlc3BvbnNlIjSCtRgPCg1jbHVzdGVyczpyZWFkgtPkkwIbEhkvdjEvY2x1c3RlcnMve2NsdXN0ZXJfaWR9ErIBChBHZXRDbHVzdGVyU3RhdHVzEi8uYWRtaXJhbC5hcGkuY2x1c3Rlci52MS5HZXRDbHVzdGVyU3RhdHVzUmVxdWVzdBowLmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEuR2V0Q2x1c3RlclN0YXR1c1Jlc3BvbnNlIjuCtRgPCg1jbHVzdGVyczpyZWFkgtPkkwIiEiAvdjEvY2x1c3RlcnMve2NsdXN0ZXJfaWR9L3N0YXR1cxKSAQoMTGlzdENsdXN0ZXJzEisuYWRtaXJhbC5hcGkuY2x1c3Rlci52MS5MaXN0Q2x1c3RlcnNSZXF1ZXN0GiwuYWRtaXJhbC5hcGkuY2x1c3Rlci52MS5MaXN0Q2x1c3RlcnNSZXNwb25zZSIngrUYDwoNY2x1c3RlcnM6cmVhZILT5JMCDhIML3YxL2NsdXN0ZXJzEqYBCg1VcGRhdGVDbHVzdGVyEiwuYWRtaXJhbC5hcGkuY2x1c3Rlci52MS5VcGRhdGVDbHVzdGVyUmVxdWVzdBotLmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEuVXBkYXRlQ2x1c3RlclJlc3BvbnNlIjiCtRgQCg5jbHVzdGVyczp3cml0ZYLT5JMCHjoBKjIZL3YxL2NsdXN0ZXJzL3tjbHVzdGVyLmlkfRKjAQoNRGVsZXRlQ2x1c3RlchIsLmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEuRGVsZXRlQ2x1c3RlclJlcXVlc3QaLS5hZG1pcmFsLmFwaS5jbHVzdGVyLnYxLkRlbGV0ZUNsdXN0ZXJSZXNwb25zZSI1grUYEAoOY2x1c3RlcnM6d3JpdGWC0+STAhsqGS92MS9jbHVzdGVycy97Y2x1c3Rlcl9pZH0SvAEKEkNyZWF0ZUNsdXN0ZXJUb2tlbhIxLmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEuQ3JlYXRlQ2x1c3RlclRva2VuUmVxdWVzdBoyLmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEuQ3JlYXRlQ2x1c3RlclRva2VuUmVzcG9uc2UiP4K1GBAKDmNsdXN0ZXJzOndyaXRlgtPkkwIlOgEqIiAvdjEvY2x1c3RlcnMve2NsdXN0ZXJfaWR9L3Rva2VucxK1AQoRTGlzdENsdXN0ZXJUb2tlbnMSMC5hZG1pcmFsLmFwaS5jbHVzdGVyLnYxLkxpc3RDbHVzdGVyVG9rZW5zUmVxdWVzdBoxLmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEuTGlzdENsdXN0ZXJUb2tlbnNSZXNwb25zZSI7grUYDwoNY2x1c3RlcnM6cmVhZILT5JMCIhIgL3YxL2NsdXN0ZXJzL3tjbHVzdGVyX2lkfS90b2tlbnMSugEKD0dldENsdXN0ZXJUb2tlbhIuLmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEuR2V0Q2x1c3RlclRva2VuUmVxdWVzdBovLmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEuR2V0Q2x1c3RlclRva2VuUmVzcG9uc2UiRoK1GA8KDWNsdXN0ZXJzOnJlYWSC0+STAi0SKy92MS9jbHVzdGVycy97Y2x1c3Rlcl9pZH0vdG9rZW5zL3t0b2tlbl9pZH0SzgEKElJldm9rZUNsdXN0ZXJUb2tlbhIxLmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEuUmV2b2tlQ2x1c3RlclRva2VuUmVxdWVzdBoyLmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEuUmV2b2tlQ2x1c3RlclRva2VuUmVzcG9uc2UiUYK1GBAKDmNsdXN0ZXJzOndyaXRlgtPkkwI3OgEqIjIvdjEvY2x1c3RlcnMve2NsdXN0ZXJfaWR9L3Rva2Vucy97dG9rZW5faWR9L3Jldm9rZRLFAQoTUmVwb3J0Q2x1c3RlclN0YXR1cxIyLmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEuUmVwb3J0Q2x1c3RlclN0YXR1c1JlcXVlc3QaMy5hZG1pcmFsLmFwaS5jbHVzdGVyLnYxLlJlcG9ydENsdXN0ZXJTdGF0dXNSZXNwb25zZSJFgrUYFgoPY2x1c3RlcnM6c3RhdHVzEgNhZ3SC0+STAiU6ASoiIC92MS9jbHVzdGVycy97Y2x1c3Rlcl9pZH0vc3RhdHVzEqwBCg1MaXN0V29ya2xvYWRzEiwuYWRtaXJhbC5hcGkuY2x1c3Rlci52MS5MaXN0V29ya2xvYWRzUmVxdWVzdBotLmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEuTGlzdFdvcmtsb2Fkc1Jlc3BvbnNlIj6CtRgPCg1jbHVzdGVyczpyZWFkgtPkkwIlEiMvdjEvY2x1c3RlcnMve2NsdXN0ZXJfaWR9L3dvcmtsb2FkcxLSAQoUUmVwb3J0V29ya2xvYWRTdGF0dXMSMy5hZG1pcmFsLmFwaS5jbHVzdGVyLnYxLlJlcG9ydFdvcmtsb2FkU3RhdHVzUmVxdWVzdBo0LmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEuUmVwb3J0V29ya2xvYWRTdGF0dXNSZXNwb25zZSJPgrUYFgoPY2x1c3RlcnM6c3RhdHVzEgNhZ3SC0+STAi86ASoiKi92MS9jbHVzdGVycy97Y2x1c3Rlcl9pZH0vd29ya2xvYWRzL3N0YXR1c0LTAQoaY29tLmFkbWlyYWwuYXBpLmNsdXN0ZXIudjFCDENsdXN0ZXJQcm90b1ABWixnby5hZG1pcmFsLmlvL3Nkay9wcm90by9jbHVzdGVyL3YxO2NsdXN0ZXJ2MaICA0FBQ6oCFkFkbWlyYWwuQXBpLkNsdXN0ZXIuVjHKAhZBZG1pcmFsXEFwaVxDbHVzdGVyXFYx4gIiQWRtaXJhbFxBcGlcQ2x1c3RlclxWMVxHUEJNZXRhZGF0YeoCGUFkbWlyYWw6OkFwaTo6Q2x1c3Rlcjo6VjFiBnByb3RvMw", [file_accesstoken_v1_accesstoken, file_authz_v1_annotations, file_buf_validate_validate, file_google_api_annotations, file_google_protobuf_field_mask, file_google_protobuf_timestamp]);

/**
 * Cluster represents a registered Kubernetes cluster within a tenant.
 *
 * @generated from message admiral.api.cluster.v1.Cluster
 */
export type Cluster = Message<"admiral.api.cluster.v1.Cluster"> & {
  /**
   * Unique identifier for the cluster (UUID).
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * Tenant this cluster belongs to (UUID).
   *
   * @generated from field: string tenant_id = 2;
   */
  tenantId: string;

  /**
   * Human-readable name (e.g., "prod-us-east-1"). Unique within the tenant.
   *
   * @generated from field: string display_name = 3;
   */
  displayName: string;

  /**
   * Arbitrary key-value labels for organizing and filtering clusters
   * (e.g., `{"region": "us-east-1", "cloud": "aws"}`).
   *
   * @generated from field: map<string, string> labels = 4;
   */
  labels: { [key: string]: string };

  /**
   * The Kubernetes kube-system namespace UID, bound at agent registration
   * using a first-write-wins strategy. Used to detect when a token is
   * accidentally deployed to a different physical cluster.
   *
   * @generated from field: string cluster_uid = 5;
   */
  clusterUid: string;

  /**
   * Derived health status based on agent connectivity and workload state.
   *
   * @generated from field: admiral.api.cluster.v1.ClusterHealthStatus health_status = 6;
   */
  healthStatus: ClusterHealthStatus;

  /**
   * When the cluster record was created.
   *
   * @generated from field: google.protobuf.Timestamp created_at = 7;
   */
  createdAt?: Timestamp;

  /**
   * When the cluster record was last updated.
   *
   * @generated from field: google.protobuf.Timestamp updated_at = 8;
   */
  updatedAt?: Timestamp;
};

/**
 * Describes the message admiral.api.cluster.v1.Cluster.
 * Use `create(ClusterSchema)` to create a new message.
 */
export const ClusterSchema: GenMessage<Cluster> = /*@__PURE__*/
  messageDesc(file_cluster_v1_cluster, 0);

/**
 * ClusterStatus contains the raw telemetry metrics for a cluster, as reported
 * by the K8s agent. This message is used in both the push payload
 * (ReportClusterStatusRequest) and the read response (GetClusterStatusResponse).
 *
 * Server-derived fields (health_status, agent connectivity) are NOT included
 * here â€” they live on the Cluster and Agent records respectively, and are
 * returned alongside this message in GetClusterStatusResponse.
 *
 * @generated from message admiral.api.cluster.v1.ClusterStatus
 */
export type ClusterStatus = Message<"admiral.api.cluster.v1.ClusterStatus"> & {
  /**
   * Kubernetes version reported by the agent (e.g., "1.29.2").
   *
   * @generated from field: string k8s_version = 1;
   */
  k8sVersion: string;

  /**
   * Total number of nodes in the cluster.
   *
   * @generated from field: int32 node_count = 2;
   */
  nodeCount: number;

  /**
   * Number of nodes in Ready condition.
   *
   * @generated from field: int32 nodes_ready = 3;
   */
  nodesReady: number;

  /**
   * Maximum number of pods the cluster can schedule.
   *
   * @generated from field: int32 pod_capacity = 4;
   */
  podCapacity: number;

  /**
   * Total number of pods across all namespaces.
   *
   * @generated from field: int32 pod_count = 5;
   */
  podCount: number;

  /**
   * Number of pods in Running phase.
   *
   * @generated from field: int32 pods_running = 6;
   */
  podsRunning: number;

  /**
   * Number of pods in Pending phase.
   *
   * @generated from field: int32 pods_pending = 7;
   */
  podsPending: number;

  /**
   * Number of pods in Failed phase.
   *
   * @generated from field: int32 pods_failed = 8;
   */
  podsFailed: number;

  /**
   * Total CPU capacity across all nodes, in millicores.
   *
   * @generated from field: int64 cpu_capacity_millicores = 9;
   */
  cpuCapacityMillicores: bigint;

  /**
   * Current CPU usage across all nodes, in millicores.
   *
   * @generated from field: int64 cpu_used_millicores = 10;
   */
  cpuUsedMillicores: bigint;

  /**
   * Total memory capacity across all nodes, in bytes.
   *
   * @generated from field: int64 memory_capacity_bytes = 11;
   */
  memoryCapacityBytes: bigint;

  /**
   * Current memory usage across all nodes, in bytes.
   *
   * @generated from field: int64 memory_used_bytes = 12;
   */
  memoryUsedBytes: bigint;

  /**
   * Total number of tracked workloads.
   *
   * @generated from field: int32 workloads_total = 13;
   */
  workloadsTotal: number;

  /**
   * Number of workloads in healthy state.
   *
   * @generated from field: int32 workloads_healthy = 14;
   */
  workloadsHealthy: number;

  /**
   * Number of workloads in degraded state.
   *
   * @generated from field: int32 workloads_degraded = 15;
   */
  workloadsDegraded: number;

  /**
   * Number of workloads in error state.
   *
   * @generated from field: int32 workloads_error = 16;
   */
  workloadsError: number;
};

/**
 * Describes the message admiral.api.cluster.v1.ClusterStatus.
 * Use `create(ClusterStatusSchema)` to create a new message.
 */
export const ClusterStatusSchema: GenMessage<ClusterStatus> = /*@__PURE__*/
  messageDesc(file_cluster_v1_cluster, 1);

/**
 * Workload represents a Kubernetes workload (Deployment, StatefulSet,
 * DaemonSet, etc.) as observed by the agent.
 *
 * @generated from message admiral.api.cluster.v1.Workload
 */
export type Workload = Message<"admiral.api.cluster.v1.Workload"> & {
  /**
   * Unique identifier for the workload within Admiral (UUID).
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * The cluster this workload belongs to (UUID).
   *
   * @generated from field: string cluster_id = 2;
   */
  clusterId: string;

  /**
   * Kubernetes namespace.
   *
   * @generated from field: string namespace = 3;
   */
  namespace: string;

  /**
   * Workload name.
   *
   * @generated from field: string name = 4;
   */
  name: string;

  /**
   * Kubernetes resource kind (e.g., "Deployment", "StatefulSet", "DaemonSet").
   *
   * @generated from field: string kind = 5;
   */
  kind: string;

  /**
   * Kubernetes labels on the workload.
   *
   * @generated from field: map<string, string> labels = 6;
   */
  labels: { [key: string]: string };

  /**
   * Derived health status.
   *
   * @generated from field: admiral.api.cluster.v1.WorkloadHealthStatus health_status = 7;
   */
  healthStatus: WorkloadHealthStatus;

  /**
   * Human-readable reason for the current status (e.g., "MinimumReplicasUnavailable").
   *
   * @generated from field: string status_reason = 8;
   */
  statusReason: string;

  /**
   * Number of desired replicas.
   *
   * @generated from field: int32 replicas_desired = 9;
   */
  replicasDesired: number;

  /**
   * Number of ready replicas.
   *
   * @generated from field: int32 replicas_ready = 10;
   */
  replicasReady: number;

  /**
   * Number of available replicas.
   *
   * @generated from field: int32 replicas_available = 11;
   */
  replicasAvailable: number;

  /**
   * CPU requests across all containers, in millicores.
   *
   * @generated from field: int64 cpu_requests_millicores = 12;
   */
  cpuRequestsMillicores: bigint;

  /**
   * CPU limits across all containers, in millicores.
   *
   * @generated from field: int64 cpu_limits_millicores = 13;
   */
  cpuLimitsMillicores: bigint;

  /**
   * Current CPU usage across all containers, in millicores.
   *
   * @generated from field: int64 cpu_used_millicores = 14;
   */
  cpuUsedMillicores: bigint;

  /**
   * Memory requests across all containers, in bytes.
   *
   * @generated from field: int64 memory_requests_bytes = 15;
   */
  memoryRequestsBytes: bigint;

  /**
   * Memory limits across all containers, in bytes.
   *
   * @generated from field: int64 memory_limits_bytes = 16;
   */
  memoryLimitsBytes: bigint;

  /**
   * Current memory usage across all containers, in bytes.
   *
   * @generated from field: int64 memory_used_bytes = 17;
   */
  memoryUsedBytes: bigint;

  /**
   * Status of individual containers in this workload.
   *
   * @generated from field: repeated admiral.api.cluster.v1.ContainerStatus containers = 18;
   */
  containers: ContainerStatus[];

  /**
   * When this workload's status was last updated.
   *
   * @generated from field: google.protobuf.Timestamp last_updated_at = 19;
   */
  lastUpdatedAt?: Timestamp;
};

/**
 * Describes the message admiral.api.cluster.v1.Workload.
 * Use `create(WorkloadSchema)` to create a new message.
 */
export const WorkloadSchema: GenMessage<Workload> = /*@__PURE__*/
  messageDesc(file_cluster_v1_cluster, 2);

/**
 * ContainerStatus describes the current state of a single container.
 *
 * @generated from message admiral.api.cluster.v1.ContainerStatus
 */
export type ContainerStatus = Message<"admiral.api.cluster.v1.ContainerStatus"> & {
  /**
   * Container name within the pod spec.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Container image reference (e.g., "registry.example.com/api:v2.1.4").
   *
   * @generated from field: string image = 2;
   */
  image: string;

  /**
   * Cumulative number of container restarts.
   *
   * @generated from field: int32 restart_count = 3;
   */
  restartCount: number;

  /**
   * Current container state (e.g., "running", "waiting", "terminated").
   *
   * @generated from field: string state = 4;
   */
  state: string;

  /**
   * Whether the container's readiness probe is passing.
   *
   * @generated from field: bool ready = 5;
   */
  ready: boolean;
};

/**
 * Describes the message admiral.api.cluster.v1.ContainerStatus.
 * Use `create(ContainerStatusSchema)` to create a new message.
 */
export const ContainerStatusSchema: GenMessage<ContainerStatus> = /*@__PURE__*/
  messageDesc(file_cluster_v1_cluster, 3);

/**
 * ObjectReference is a lightweight reference to a Kubernetes object.
 *
 * @generated from message admiral.api.cluster.v1.ObjectReference
 */
export type ObjectReference = Message<"admiral.api.cluster.v1.ObjectReference"> & {
  /**
   * Kubernetes resource kind (e.g., "Pod", "ReplicaSet").
   *
   * @generated from field: string kind = 1;
   */
  kind: string;

  /**
   * Kubernetes namespace.
   *
   * @generated from field: string namespace = 2;
   */
  namespace: string;

  /**
   * Object name.
   *
   * @generated from field: string name = 3;
   */
  name: string;
};

/**
 * Describes the message admiral.api.cluster.v1.ObjectReference.
 * Use `create(ObjectReferenceSchema)` to create a new message.
 */
export const ObjectReferenceSchema: GenMessage<ObjectReference> = /*@__PURE__*/
  messageDesc(file_cluster_v1_cluster, 4);

/**
 * WorkloadEvent represents a Kubernetes event related to a workload or its
 * child objects (pods, replicasets). Events are deduplicated by their K8s UID.
 *
 * @generated from message admiral.api.cluster.v1.WorkloadEvent
 */
export type WorkloadEvent = Message<"admiral.api.cluster.v1.WorkloadEvent"> & {
  /**
   * Kubernetes event UID, used for deduplication.
   *
   * @generated from field: string uid = 1;
   */
  uid: string;

  /**
   * Event type: "Normal" or "Warning".
   *
   * @generated from field: string type = 2;
   */
  type: string;

  /**
   * Short machine-readable reason (e.g., "BackOff", "FailedScheduling").
   *
   * @generated from field: string reason = 3;
   */
  reason: string;

  /**
   * The Kubernetes object this event is about.
   *
   * @generated from field: admiral.api.cluster.v1.ObjectReference regarding = 4;
   */
  regarding?: ObjectReference;

  /**
   * Human-readable event message.
   *
   * @generated from field: string message = 5;
   */
  message: string;

  /**
   * When this event was first observed.
   *
   * @generated from field: google.protobuf.Timestamp first_seen = 6;
   */
  firstSeen?: Timestamp;

  /**
   * When this event was most recently observed.
   *
   * @generated from field: google.protobuf.Timestamp last_seen = 7;
   */
  lastSeen?: Timestamp;

  /**
   * Number of times this event has occurred.
   *
   * @generated from field: int32 count = 8;
   */
  count: number;
};

/**
 * Describes the message admiral.api.cluster.v1.WorkloadEvent.
 * Use `create(WorkloadEventSchema)` to create a new message.
 */
export const WorkloadEventSchema: GenMessage<WorkloadEvent> = /*@__PURE__*/
  messageDesc(file_cluster_v1_cluster, 5);

/**
 * CreateClusterRequest contains the parameters for creating a new cluster.
 *
 * @generated from message admiral.api.cluster.v1.CreateClusterRequest
 */
export type CreateClusterRequest = Message<"admiral.api.cluster.v1.CreateClusterRequest"> & {
  /**
   * Human-readable name for the cluster (e.g., "prod-us-east-1").
   * Must be unique within the tenant.
   *
   * @generated from field: string display_name = 1;
   */
  displayName: string;

  /**
   * Arbitrary key-value labels for organizing and filtering clusters
   * (e.g., `{"region": "us-east-1", "cloud": "aws"}`).
   *
   * @generated from field: map<string, string> labels = 2;
   */
  labels: { [key: string]: string };
};

/**
 * Describes the message admiral.api.cluster.v1.CreateClusterRequest.
 * Use `create(CreateClusterRequestSchema)` to create a new message.
 */
export const CreateClusterRequestSchema: GenMessage<CreateClusterRequest> = /*@__PURE__*/
  messageDesc(file_cluster_v1_cluster, 6);

/**
 * CreateClusterResponse contains the newly created cluster and its initial
 * Agent Token (AGT).
 *
 * @generated from message admiral.api.cluster.v1.CreateClusterResponse
 */
export type CreateClusterResponse = Message<"admiral.api.cluster.v1.CreateClusterResponse"> & {
  /**
   * The created cluster. Health status will be PENDING until an agent connects
   * and calls AgentAPI.RegisterAgent.
   *
   * @generated from field: admiral.api.cluster.v1.Cluster cluster = 1;
   */
  cluster?: Cluster;

  /**
   * The raw Agent Token secret (e.g., "adm_agt_pL2mN5oQ8rS1..."). This value
   * is shown exactly once and cannot be retrieved again. Deploy this token to
   * the K8s agent for authentication.
   *
   * To create additional tokens (e.g., for rotation), use
   * AccessTokenAPI.CreateAgentToken.
   *
   * @generated from field: string plain_text_token = 2;
   */
  plainTextToken: string;
};

/**
 * Describes the message admiral.api.cluster.v1.CreateClusterResponse.
 * Use `create(CreateClusterResponseSchema)` to create a new message.
 */
export const CreateClusterResponseSchema: GenMessage<CreateClusterResponse> = /*@__PURE__*/
  messageDesc(file_cluster_v1_cluster, 7);

/**
 * GetClusterRequest identifies a cluster to retrieve.
 *
 * @generated from message admiral.api.cluster.v1.GetClusterRequest
 */
export type GetClusterRequest = Message<"admiral.api.cluster.v1.GetClusterRequest"> & {
  /**
   * The unique identifier of the cluster (UUID).
   *
   * @generated from field: string cluster_id = 1;
   */
  clusterId: string;
};

/**
 * Describes the message admiral.api.cluster.v1.GetClusterRequest.
 * Use `create(GetClusterRequestSchema)` to create a new message.
 */
export const GetClusterRequestSchema: GenMessage<GetClusterRequest> = /*@__PURE__*/
  messageDesc(file_cluster_v1_cluster, 8);

/**
 * GetClusterResponse contains the cluster record.
 *
 * @generated from message admiral.api.cluster.v1.GetClusterResponse
 */
export type GetClusterResponse = Message<"admiral.api.cluster.v1.GetClusterResponse"> & {
  /**
   * The cluster record, including server-derived health_status.
   *
   * @generated from field: admiral.api.cluster.v1.Cluster cluster = 1;
   */
  cluster?: Cluster;
};

/**
 * Describes the message admiral.api.cluster.v1.GetClusterResponse.
 * Use `create(GetClusterResponseSchema)` to create a new message.
 */
export const GetClusterResponseSchema: GenMessage<GetClusterResponse> = /*@__PURE__*/
  messageDesc(file_cluster_v1_cluster, 9);

/**
 * ListClustersRequest contains pagination and filter parameters.
 *
 * @generated from message admiral.api.cluster.v1.ListClustersRequest
 */
export type ListClustersRequest = Message<"admiral.api.cluster.v1.ListClustersRequest"> & {
  /**
   * Maximum number of clusters to return per page.
   *
   * @generated from field: int32 page_size = 1;
   */
  pageSize: number;

  /**
   * Opaque pagination token from a previous response.
   *
   * @generated from field: string page_token = 2;
   */
  pageToken: string;

  /**
   * Filter expression using the PEG filter DSL
   * (e.g., `health_status = "healthy"` or `labels.region = "us-east-1"`).
   *
   * @generated from field: string filter = 3;
   */
  filter: string;
};

/**
 * Describes the message admiral.api.cluster.v1.ListClustersRequest.
 * Use `create(ListClustersRequestSchema)` to create a new message.
 */
export const ListClustersRequestSchema: GenMessage<ListClustersRequest> = /*@__PURE__*/
  messageDesc(file_cluster_v1_cluster, 10);

/**
 * ListClustersResponse contains a page of clusters.
 *
 * @generated from message admiral.api.cluster.v1.ListClustersResponse
 */
export type ListClustersResponse = Message<"admiral.api.cluster.v1.ListClustersResponse"> & {
  /**
   * The list of clusters.
   *
   * @generated from field: repeated admiral.api.cluster.v1.Cluster clusters = 1;
   */
  clusters: Cluster[];

  /**
   * Pagination token for the next page. Empty when there are no more results.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;
};

/**
 * Describes the message admiral.api.cluster.v1.ListClustersResponse.
 * Use `create(ListClustersResponseSchema)` to create a new message.
 */
export const ListClustersResponseSchema: GenMessage<ListClustersResponse> = /*@__PURE__*/
  messageDesc(file_cluster_v1_cluster, 11);

/**
 * UpdateClusterRequest contains the cluster fields to update.
 *
 * @generated from message admiral.api.cluster.v1.UpdateClusterRequest
 */
export type UpdateClusterRequest = Message<"admiral.api.cluster.v1.UpdateClusterRequest"> & {
  /**
   * The cluster with updated fields. The `id` field is required.
   * Only fields specified in `update_mask` are updated.
   *
   * @generated from field: admiral.api.cluster.v1.Cluster cluster = 1;
   */
  cluster?: Cluster;

  /**
   * The set of fields to update. If unset, all mutable fields are updated.
   * Supported fields: `display_name`, `labels`.
   *
   * @generated from field: google.protobuf.FieldMask update_mask = 2;
   */
  updateMask?: FieldMask;
};

/**
 * Describes the message admiral.api.cluster.v1.UpdateClusterRequest.
 * Use `create(UpdateClusterRequestSchema)` to create a new message.
 */
export const UpdateClusterRequestSchema: GenMessage<UpdateClusterRequest> = /*@__PURE__*/
  messageDesc(file_cluster_v1_cluster, 12);

/**
 * UpdateClusterResponse contains the updated cluster.
 *
 * @generated from message admiral.api.cluster.v1.UpdateClusterResponse
 */
export type UpdateClusterResponse = Message<"admiral.api.cluster.v1.UpdateClusterResponse"> & {
  /**
   * The updated cluster.
   *
   * @generated from field: admiral.api.cluster.v1.Cluster cluster = 1;
   */
  cluster?: Cluster;
};

/**
 * Describes the message admiral.api.cluster.v1.UpdateClusterResponse.
 * Use `create(UpdateClusterResponseSchema)` to create a new message.
 */
export const UpdateClusterResponseSchema: GenMessage<UpdateClusterResponse> = /*@__PURE__*/
  messageDesc(file_cluster_v1_cluster, 13);

/**
 * DeleteClusterRequest identifies a cluster to delete.
 *
 * @generated from message admiral.api.cluster.v1.DeleteClusterRequest
 */
export type DeleteClusterRequest = Message<"admiral.api.cluster.v1.DeleteClusterRequest"> & {
  /**
   * The unique identifier of the cluster to delete (UUID).
   * All associated agent tokens will be revoked.
   *
   * @generated from field: string cluster_id = 1;
   */
  clusterId: string;
};

/**
 * Describes the message admiral.api.cluster.v1.DeleteClusterRequest.
 * Use `create(DeleteClusterRequestSchema)` to create a new message.
 */
export const DeleteClusterRequestSchema: GenMessage<DeleteClusterRequest> = /*@__PURE__*/
  messageDesc(file_cluster_v1_cluster, 14);

/**
 * DeleteClusterResponse is empty on success.
 *
 * @generated from message admiral.api.cluster.v1.DeleteClusterResponse
 */
export type DeleteClusterResponse = Message<"admiral.api.cluster.v1.DeleteClusterResponse"> & {
};

/**
 * Describes the message admiral.api.cluster.v1.DeleteClusterResponse.
 * Use `create(DeleteClusterResponseSchema)` to create a new message.
 */
export const DeleteClusterResponseSchema: GenMessage<DeleteClusterResponse> = /*@__PURE__*/
  messageDesc(file_cluster_v1_cluster, 15);

/**
 * GetClusterStatusRequest identifies a cluster whose telemetry status to retrieve.
 *
 * @generated from message admiral.api.cluster.v1.GetClusterStatusRequest
 */
export type GetClusterStatusRequest = Message<"admiral.api.cluster.v1.GetClusterStatusRequest"> & {
  /**
   * The unique identifier of the cluster (UUID).
   *
   * @generated from field: string cluster_id = 1;
   */
  clusterId: string;
};

/**
 * Describes the message admiral.api.cluster.v1.GetClusterStatusRequest.
 * Use `create(GetClusterStatusRequestSchema)` to create a new message.
 */
export const GetClusterStatusRequestSchema: GenMessage<GetClusterStatusRequest> = /*@__PURE__*/
  messageDesc(file_cluster_v1_cluster, 16);

/**
 * GetClusterStatusResponse contains the server-derived health status and the
 * latest telemetry snapshot. If no agent has reported telemetry yet, the
 * health_status will be PENDING and status will be absent.
 *
 * @generated from message admiral.api.cluster.v1.GetClusterStatusResponse
 */
export type GetClusterStatusResponse = Message<"admiral.api.cluster.v1.GetClusterStatusResponse"> & {
  /**
   * Server-derived health status based on agent connectivity, node readiness,
   * and workload health.
   *
   * @generated from field: admiral.api.cluster.v1.ClusterHealthStatus health_status = 1;
   */
  healthStatus: ClusterHealthStatus;

  /**
   * Latest telemetry snapshot from the agent. Absent if no telemetry has
   * been reported yet.
   *
   * @generated from field: admiral.api.cluster.v1.ClusterStatus status = 2;
   */
  status?: ClusterStatus;

  /**
   * When the latest telemetry was reported by the agent.
   *
   * @generated from field: google.protobuf.Timestamp reported_at = 3;
   */
  reportedAt?: Timestamp;
};

/**
 * Describes the message admiral.api.cluster.v1.GetClusterStatusResponse.
 * Use `create(GetClusterStatusResponseSchema)` to create a new message.
 */
export const GetClusterStatusResponseSchema: GenMessage<GetClusterStatusResponse> = /*@__PURE__*/
  messageDesc(file_cluster_v1_cluster, 17);

/**
 * ReportClusterStatusRequest contains a combined telemetry payload from a K8s agent.
 * Admiral splits this into three storage tiers: current snapshot, time-series
 * metrics, and events.
 *
 * @generated from message admiral.api.cluster.v1.ReportClusterStatusRequest
 */
export type ReportClusterStatusRequest = Message<"admiral.api.cluster.v1.ReportClusterStatusRequest"> & {
  /**
   * The cluster this status report is for (UUID).
   *
   * @generated from field: string cluster_id = 1;
   */
  clusterId: string;

  /**
   * Cluster-level telemetry snapshot.
   *
   * @generated from field: admiral.api.cluster.v1.ClusterStatus status = 2;
   */
  status?: ClusterStatus;

  /**
   * Per-workload status snapshots.
   *
   * @generated from field: repeated admiral.api.cluster.v1.WorkloadStatus workloads = 3;
   */
  workloads: WorkloadStatus[];

  /**
   * Kubernetes events observed since the last push.
   *
   * @generated from field: repeated admiral.api.cluster.v1.WorkloadEvent events = 4;
   */
  events: WorkloadEvent[];

  /**
   * When the agent generated this report.
   *
   * @generated from field: google.protobuf.Timestamp reported_at = 5;
   */
  reportedAt?: Timestamp;
};

/**
 * Describes the message admiral.api.cluster.v1.ReportClusterStatusRequest.
 * Use `create(ReportClusterStatusRequestSchema)` to create a new message.
 */
export const ReportClusterStatusRequestSchema: GenMessage<ReportClusterStatusRequest> = /*@__PURE__*/
  messageDesc(file_cluster_v1_cluster, 18);

/**
 * WorkloadStatus is the agent-reported status for a single workload within
 * a telemetry push payload.
 *
 * @generated from message admiral.api.cluster.v1.WorkloadStatus
 */
export type WorkloadStatus = Message<"admiral.api.cluster.v1.WorkloadStatus"> & {
  /**
   * Kubernetes namespace.
   *
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * Workload name.
   *
   * @generated from field: string name = 2;
   */
  name: string;

  /**
   * Kubernetes resource kind (e.g., "Deployment", "StatefulSet").
   *
   * @generated from field: string kind = 3;
   */
  kind: string;

  /**
   * Kubernetes labels on the workload.
   *
   * @generated from field: map<string, string> labels = 4;
   */
  labels: { [key: string]: string };

  /**
   * Number of desired replicas.
   *
   * @generated from field: int32 replicas_desired = 5;
   */
  replicasDesired: number;

  /**
   * Number of ready replicas.
   *
   * @generated from field: int32 replicas_ready = 6;
   */
  replicasReady: number;

  /**
   * Number of available replicas.
   *
   * @generated from field: int32 replicas_available = 7;
   */
  replicasAvailable: number;

  /**
   * CPU requests across all containers, in millicores.
   *
   * @generated from field: int64 cpu_requests_millicores = 8;
   */
  cpuRequestsMillicores: bigint;

  /**
   * CPU limits across all containers, in millicores.
   *
   * @generated from field: int64 cpu_limits_millicores = 9;
   */
  cpuLimitsMillicores: bigint;

  /**
   * Current CPU usage across all containers, in millicores.
   *
   * @generated from field: int64 cpu_used_millicores = 10;
   */
  cpuUsedMillicores: bigint;

  /**
   * Memory requests across all containers, in bytes.
   *
   * @generated from field: int64 memory_requests_bytes = 11;
   */
  memoryRequestsBytes: bigint;

  /**
   * Memory limits across all containers, in bytes.
   *
   * @generated from field: int64 memory_limits_bytes = 12;
   */
  memoryLimitsBytes: bigint;

  /**
   * Current memory usage across all containers, in bytes.
   *
   * @generated from field: int64 memory_used_bytes = 13;
   */
  memoryUsedBytes: bigint;

  /**
   * Derived health status.
   *
   * @generated from field: admiral.api.cluster.v1.WorkloadHealthStatus health_status = 14;
   */
  healthStatus: WorkloadHealthStatus;

  /**
   * Status of individual containers.
   *
   * @generated from field: repeated admiral.api.cluster.v1.ContainerStatus containers = 15;
   */
  containers: ContainerStatus[];
};

/**
 * Describes the message admiral.api.cluster.v1.WorkloadStatus.
 * Use `create(WorkloadStatusSchema)` to create a new message.
 */
export const WorkloadStatusSchema: GenMessage<WorkloadStatus> = /*@__PURE__*/
  messageDesc(file_cluster_v1_cluster, 19);

/**
 * ReportClusterStatusResponse acknowledges a telemetry push.
 *
 * @generated from message admiral.api.cluster.v1.ReportClusterStatusResponse
 */
export type ReportClusterStatusResponse = Message<"admiral.api.cluster.v1.ReportClusterStatusResponse"> & {
  /**
   * Whether the report was accepted.
   *
   * @generated from field: bool ack = 1;
   */
  ack: boolean;

  /**
   * Server-controlled interval (in seconds) before the agent should send
   * its next status push. Allows the server to adjust push frequency dynamically.
   *
   * @generated from field: int32 next_push_seconds = 2;
   */
  nextPushSeconds: number;
};

/**
 * Describes the message admiral.api.cluster.v1.ReportClusterStatusResponse.
 * Use `create(ReportClusterStatusResponseSchema)` to create a new message.
 */
export const ReportClusterStatusResponseSchema: GenMessage<ReportClusterStatusResponse> = /*@__PURE__*/
  messageDesc(file_cluster_v1_cluster, 20);

/**
 * ListWorkloadsRequest contains pagination and filter parameters for listing
 * workloads in a specific cluster.
 *
 * @generated from message admiral.api.cluster.v1.ListWorkloadsRequest
 */
export type ListWorkloadsRequest = Message<"admiral.api.cluster.v1.ListWorkloadsRequest"> & {
  /**
   * The cluster whose workloads to list (UUID).
   *
   * @generated from field: string cluster_id = 1;
   */
  clusterId: string;

  /**
   * Maximum number of workloads to return per page.
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize: number;

  /**
   * Opaque pagination token from a previous response.
   *
   * @generated from field: string page_token = 3;
   */
  pageToken: string;

  /**
   * Filter expression using the PEG filter DSL
   * (e.g., `namespace = "production"` or `health_status = "degraded"`).
   *
   * @generated from field: string filter = 4;
   */
  filter: string;
};

/**
 * Describes the message admiral.api.cluster.v1.ListWorkloadsRequest.
 * Use `create(ListWorkloadsRequestSchema)` to create a new message.
 */
export const ListWorkloadsRequestSchema: GenMessage<ListWorkloadsRequest> = /*@__PURE__*/
  messageDesc(file_cluster_v1_cluster, 21);

/**
 * ListWorkloadsResponse contains a page of workloads.
 *
 * @generated from message admiral.api.cluster.v1.ListWorkloadsResponse
 */
export type ListWorkloadsResponse = Message<"admiral.api.cluster.v1.ListWorkloadsResponse"> & {
  /**
   * The list of workloads.
   *
   * @generated from field: repeated admiral.api.cluster.v1.Workload workloads = 1;
   */
  workloads: Workload[];

  /**
   * Pagination token for the next page. Empty when there are no more results.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;
};

/**
 * Describes the message admiral.api.cluster.v1.ListWorkloadsResponse.
 * Use `create(ListWorkloadsResponseSchema)` to create a new message.
 */
export const ListWorkloadsResponseSchema: GenMessage<ListWorkloadsResponse> = /*@__PURE__*/
  messageDesc(file_cluster_v1_cluster, 22);

/**
 * ReportWorkloadStatusRequest contains incremental workload telemetry from a K8s agent.
 *
 * @generated from message admiral.api.cluster.v1.ReportWorkloadStatusRequest
 */
export type ReportWorkloadStatusRequest = Message<"admiral.api.cluster.v1.ReportWorkloadStatusRequest"> & {
  /**
   * The cluster these workloads belong to (UUID).
   *
   * @generated from field: string cluster_id = 1;
   */
  clusterId: string;

  /**
   * Per-workload status snapshots.
   *
   * @generated from field: repeated admiral.api.cluster.v1.WorkloadStatus workloads = 2;
   */
  workloads: WorkloadStatus[];

  /**
   * When the agent generated this report.
   *
   * @generated from field: google.protobuf.Timestamp reported_at = 3;
   */
  reportedAt?: Timestamp;
};

/**
 * Describes the message admiral.api.cluster.v1.ReportWorkloadStatusRequest.
 * Use `create(ReportWorkloadStatusRequestSchema)` to create a new message.
 */
export const ReportWorkloadStatusRequestSchema: GenMessage<ReportWorkloadStatusRequest> = /*@__PURE__*/
  messageDesc(file_cluster_v1_cluster, 23);

/**
 * ReportWorkloadStatusResponse acknowledges a workload telemetry push.
 *
 * @generated from message admiral.api.cluster.v1.ReportWorkloadStatusResponse
 */
export type ReportWorkloadStatusResponse = Message<"admiral.api.cluster.v1.ReportWorkloadStatusResponse"> & {
  /**
   * Whether the report was accepted.
   *
   * @generated from field: bool ack = 1;
   */
  ack: boolean;
};

/**
 * Describes the message admiral.api.cluster.v1.ReportWorkloadStatusResponse.
 * Use `create(ReportWorkloadStatusResponseSchema)` to create a new message.
 */
export const ReportWorkloadStatusResponseSchema: GenMessage<ReportWorkloadStatusResponse> = /*@__PURE__*/
  messageDesc(file_cluster_v1_cluster, 24);

/**
 * CreateClusterTokenRequest contains the parameters for creating a new AGT
 * bound to a cluster.
 *
 * @generated from message admiral.api.cluster.v1.CreateClusterTokenRequest
 */
export type CreateClusterTokenRequest = Message<"admiral.api.cluster.v1.CreateClusterTokenRequest"> & {
  /**
   * The cluster to bind this token to (UUID).
   *
   * @generated from field: string cluster_id = 1;
   */
  clusterId: string;

  /**
   * Human-readable name for the token (e.g., "prod-us-east-1-agent-key").
   *
   * @generated from field: string display_name = 2;
   */
  displayName: string;

  /**
   * Optional expiration time. If unset, the token does not expire.
   *
   * @generated from field: google.protobuf.Timestamp expires_at = 3;
   */
  expiresAt?: Timestamp;
};

/**
 * Describes the message admiral.api.cluster.v1.CreateClusterTokenRequest.
 * Use `create(CreateClusterTokenRequestSchema)` to create a new message.
 */
export const CreateClusterTokenRequestSchema: GenMessage<CreateClusterTokenRequest> = /*@__PURE__*/
  messageDesc(file_cluster_v1_cluster, 25);

/**
 * CreateClusterTokenResponse contains the newly created AGT.
 *
 * @generated from message admiral.api.cluster.v1.CreateClusterTokenResponse
 */
export type CreateClusterTokenResponse = Message<"admiral.api.cluster.v1.CreateClusterTokenResponse"> & {
  /**
   * The created token metadata. Scopes are auto-assigned for cluster AGTs.
   *
   * @generated from field: admiral.api.accesstoken.v1.AccessToken access_token = 1;
   */
  accessToken?: AccessToken;

  /**
   * The raw token secret (e.g., "adm_agt_pL2mN5oQ8rS1..."). This value is
   * shown exactly once and cannot be retrieved again. Store it securely.
   *
   * @generated from field: string plain_text_token = 2;
   */
  plainTextToken: string;
};

/**
 * Describes the message admiral.api.cluster.v1.CreateClusterTokenResponse.
 * Use `create(CreateClusterTokenResponseSchema)` to create a new message.
 */
export const CreateClusterTokenResponseSchema: GenMessage<CreateClusterTokenResponse> = /*@__PURE__*/
  messageDesc(file_cluster_v1_cluster, 26);

/**
 * ListClusterTokensRequest contains pagination and filter parameters.
 *
 * @generated from message admiral.api.cluster.v1.ListClusterTokensRequest
 */
export type ListClusterTokensRequest = Message<"admiral.api.cluster.v1.ListClusterTokensRequest"> & {
  /**
   * The cluster whose tokens to list (UUID).
   *
   * @generated from field: string cluster_id = 1;
   */
  clusterId: string;

  /**
   * Maximum number of tokens to return per page.
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize: number;

  /**
   * Opaque pagination token from a previous response.
   *
   * @generated from field: string page_token = 3;
   */
  pageToken: string;

  /**
   * Filter expression using the PEG filter DSL.
   *
   * @generated from field: string filter = 4;
   */
  filter: string;
};

/**
 * Describes the message admiral.api.cluster.v1.ListClusterTokensRequest.
 * Use `create(ListClusterTokensRequestSchema)` to create a new message.
 */
export const ListClusterTokensRequestSchema: GenMessage<ListClusterTokensRequest> = /*@__PURE__*/
  messageDesc(file_cluster_v1_cluster, 27);

/**
 * ListClusterTokensResponse contains a page of cluster AGT metadata.
 *
 * @generated from message admiral.api.cluster.v1.ListClusterTokensResponse
 */
export type ListClusterTokensResponse = Message<"admiral.api.cluster.v1.ListClusterTokensResponse"> & {
  /**
   * The list of tokens. Token secrets are never included.
   *
   * @generated from field: repeated admiral.api.accesstoken.v1.AccessToken access_tokens = 1;
   */
  accessTokens: AccessToken[];

  /**
   * Pagination token for the next page. Empty when there are no more results.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;
};

/**
 * Describes the message admiral.api.cluster.v1.ListClusterTokensResponse.
 * Use `create(ListClusterTokensResponseSchema)` to create a new message.
 */
export const ListClusterTokensResponseSchema: GenMessage<ListClusterTokensResponse> = /*@__PURE__*/
  messageDesc(file_cluster_v1_cluster, 28);

/**
 * GetClusterTokenRequest identifies a cluster AGT to retrieve.
 *
 * @generated from message admiral.api.cluster.v1.GetClusterTokenRequest
 */
export type GetClusterTokenRequest = Message<"admiral.api.cluster.v1.GetClusterTokenRequest"> & {
  /**
   * The cluster the token belongs to (UUID).
   *
   * @generated from field: string cluster_id = 1;
   */
  clusterId: string;

  /**
   * The unique identifier of the token (UUID).
   *
   * @generated from field: string token_id = 2;
   */
  tokenId: string;
};

/**
 * Describes the message admiral.api.cluster.v1.GetClusterTokenRequest.
 * Use `create(GetClusterTokenRequestSchema)` to create a new message.
 */
export const GetClusterTokenRequestSchema: GenMessage<GetClusterTokenRequest> = /*@__PURE__*/
  messageDesc(file_cluster_v1_cluster, 29);

/**
 * GetClusterTokenResponse contains the requested cluster AGT metadata.
 *
 * @generated from message admiral.api.cluster.v1.GetClusterTokenResponse
 */
export type GetClusterTokenResponse = Message<"admiral.api.cluster.v1.GetClusterTokenResponse"> & {
  /**
   * The token metadata. The token secret is never included.
   *
   * @generated from field: admiral.api.accesstoken.v1.AccessToken access_token = 1;
   */
  accessToken?: AccessToken;
};

/**
 * Describes the message admiral.api.cluster.v1.GetClusterTokenResponse.
 * Use `create(GetClusterTokenResponseSchema)` to create a new message.
 */
export const GetClusterTokenResponseSchema: GenMessage<GetClusterTokenResponse> = /*@__PURE__*/
  messageDesc(file_cluster_v1_cluster, 30);

/**
 * RevokeClusterTokenRequest identifies a cluster AGT to revoke.
 *
 * @generated from message admiral.api.cluster.v1.RevokeClusterTokenRequest
 */
export type RevokeClusterTokenRequest = Message<"admiral.api.cluster.v1.RevokeClusterTokenRequest"> & {
  /**
   * The cluster the token belongs to (UUID).
   *
   * @generated from field: string cluster_id = 1;
   */
  clusterId: string;

  /**
   * The unique identifier of the token to revoke (UUID).
   *
   * @generated from field: string token_id = 2;
   */
  tokenId: string;
};

/**
 * Describes the message admiral.api.cluster.v1.RevokeClusterTokenRequest.
 * Use `create(RevokeClusterTokenRequestSchema)` to create a new message.
 */
export const RevokeClusterTokenRequestSchema: GenMessage<RevokeClusterTokenRequest> = /*@__PURE__*/
  messageDesc(file_cluster_v1_cluster, 31);

/**
 * RevokeClusterTokenResponse contains the revoked cluster AGT metadata.
 *
 * @generated from message admiral.api.cluster.v1.RevokeClusterTokenResponse
 */
export type RevokeClusterTokenResponse = Message<"admiral.api.cluster.v1.RevokeClusterTokenResponse"> & {
  /**
   * The token metadata with updated status.
   *
   * @generated from field: admiral.api.accesstoken.v1.AccessToken access_token = 1;
   */
  accessToken?: AccessToken;
};

/**
 * Describes the message admiral.api.cluster.v1.RevokeClusterTokenResponse.
 * Use `create(RevokeClusterTokenResponseSchema)` to create a new message.
 */
export const RevokeClusterTokenResponseSchema: GenMessage<RevokeClusterTokenResponse> = /*@__PURE__*/
  messageDesc(file_cluster_v1_cluster, 32);

/**
 * ClusterHealthStatus represents the derived health state of a cluster.
 * The status is computed from agent connectivity, node readiness, and workload health.
 *
 * @generated from enum admiral.api.cluster.v1.ClusterHealthStatus
 */
export enum ClusterHealthStatus {
  /**
   * Default value. Must not be used.
   *
   * @generated from enum value: CLUSTER_HEALTH_STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Cluster record exists but no agent has registered yet.
   *
   * @generated from enum value: CLUSTER_HEALTH_STATUS_PENDING = 1;
   */
  PENDING = 1,

  /**
   * Agent connected, all nodes ready, less than 10% workloads degraded.
   *
   * @generated from enum value: CLUSTER_HEALTH_STATUS_HEALTHY = 2;
   */
  HEALTHY = 2,

  /**
   * Agent connected, some nodes not ready or workloads in error/degraded state.
   *
   * @generated from enum value: CLUSTER_HEALTH_STATUS_DEGRADED = 3;
   */
  DEGRADED = 3,

  /**
   * Agent connected, more than 25% nodes not ready or workloads in error state.
   *
   * @generated from enum value: CLUSTER_HEALTH_STATUS_ERROR = 4;
   */
  ERROR = 4,

  /**
   * No heartbeat received within 3x the heartbeat interval.
   *
   * @generated from enum value: CLUSTER_HEALTH_STATUS_UNREACHABLE = 5;
   */
  UNREACHABLE = 5,
}

/**
 * Describes the enum admiral.api.cluster.v1.ClusterHealthStatus.
 */
export const ClusterHealthStatusSchema: GenEnum<ClusterHealthStatus> = /*@__PURE__*/
  enumDesc(file_cluster_v1_cluster, 0);

/**
 * WorkloadHealthStatus represents the derived health state of a single workload.
 *
 * @generated from enum admiral.api.cluster.v1.WorkloadHealthStatus
 */
export enum WorkloadHealthStatus {
  /**
   * Default value. Must not be used.
   *
   * @generated from enum value: WORKLOAD_HEALTH_STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * All desired replicas ready, no CrashLoopBackOff, restarts stable.
   *
   * @generated from enum value: WORKLOAD_HEALTH_STATUS_HEALTHY = 1;
   */
  HEALTHY = 1,

  /**
   * Some replicas not ready, restarts increasing, or pods pending over 5 minutes.
   *
   * @generated from enum value: WORKLOAD_HEALTH_STATUS_DEGRADED = 2;
   */
  DEGRADED = 2,

  /**
   * Zero ready replicas, all containers CrashLoopBackOff, or deployment stuck.
   *
   * @generated from enum value: WORKLOAD_HEALTH_STATUS_ERROR = 3;
   */
  ERROR = 3,
}

/**
 * Describes the enum admiral.api.cluster.v1.WorkloadHealthStatus.
 */
export const WorkloadHealthStatusSchema: GenEnum<WorkloadHealthStatus> = /*@__PURE__*/
  enumDesc(file_cluster_v1_cluster, 1);

/**
 * ClusterAPI manages Kubernetes clusters and their workload telemetry.
 *
 * Administrators create clusters via CreateCluster, which returns an Agent
 * Token (AGT) for deploying the K8s agent. Once the agent boots and calls
 * AgentAPI.RegisterAgent, the cluster transitions from PENDING to HEALTHY
 * and begins receiving telemetry.
 *
 * The telemetry model has three tiers: current snapshot (upserted per push),
 * time-series metrics (rolling 48-hour window), and events (rolling 7-day window).
 *
 * @generated from service admiral.api.cluster.v1.ClusterAPI
 */
export const ClusterAPI: GenService<{
  /**
   * CreateCluster creates a new cluster record within the caller's tenant and
   * generates an initial Agent Token (AGT) for the K8s agent. The cluster
   * starts in PENDING status until an agent registers against it.
   *
   * The response includes a `plain_text_token` â€” the raw AGT secret shown
   * exactly once. Deploy this token to the K8s agent (e.g., via Helm values
   * or a Kubernetes Secret). The agent uses it to authenticate with
   * AgentAPI.RegisterAgent on first boot.
   *
   * Scope: `clusters:write`
   *
   * @generated from rpc admiral.api.cluster.v1.ClusterAPI.CreateCluster
   */
  createCluster: {
    methodKind: "unary";
    input: typeof CreateClusterRequestSchema;
    output: typeof CreateClusterResponseSchema;
  },
  /**
   * GetCluster retrieves a cluster by ID.
   *
   * Returns the Cluster record with its server-derived health_status. For
   * detailed telemetry (node counts, resource usage, workload summary), use
   * GetClusterStatus instead.
   *
   * Scope: `clusters:read`
   *
   * @generated from rpc admiral.api.cluster.v1.ClusterAPI.GetCluster
   */
  getCluster: {
    methodKind: "unary";
    input: typeof GetClusterRequestSchema;
    output: typeof GetClusterResponseSchema;
  },
  /**
   * GetClusterStatus retrieves the current telemetry snapshot for a cluster.
   * Returns the latest metrics pushed by the agent, along with server-derived
   * health status and workload summary counts.
   *
   * Returns NOT_FOUND if the cluster does not exist. If the cluster exists but
   * no agent has reported telemetry yet, the response will have health_status
   * PENDING and no status message.
   *
   * Scope: `clusters:read`
   *
   * @generated from rpc admiral.api.cluster.v1.ClusterAPI.GetClusterStatus
   */
  getClusterStatus: {
    methodKind: "unary";
    input: typeof GetClusterStatusRequestSchema;
    output: typeof GetClusterStatusResponseSchema;
  },
  /**
   * ListClusters returns a paginated list of clusters within the caller's tenant.
   *
   * Scope: `clusters:read`
   *
   * @generated from rpc admiral.api.cluster.v1.ClusterAPI.ListClusters
   */
  listClusters: {
    methodKind: "unary";
    input: typeof ListClustersRequestSchema;
    output: typeof ListClustersResponseSchema;
  },
  /**
   * UpdateCluster updates a cluster's mutable fields (display name, labels).
   * Use the `update_mask` to specify which fields to update.
   *
   * Scope: `clusters:write`
   *
   * @generated from rpc admiral.api.cluster.v1.ClusterAPI.UpdateCluster
   */
  updateCluster: {
    methodKind: "unary";
    input: typeof UpdateClusterRequestSchema;
    output: typeof UpdateClusterResponseSchema;
  },
  /**
   * DeleteCluster permanently deletes a cluster record and revokes all
   * associated agent tokens. This action cannot be undone.
   *
   * Scope: `clusters:write`
   *
   * @generated from rpc admiral.api.cluster.v1.ClusterAPI.DeleteCluster
   */
  deleteCluster: {
    methodKind: "unary";
    input: typeof DeleteClusterRequestSchema;
    output: typeof DeleteClusterResponseSchema;
  },
  /**
   * CreateClusterToken creates a new Agent Token (AGT) bound to the specified
   * cluster. Scopes are auto-assigned and cannot be overridden. The response
   * includes the raw token secret, which is shown exactly once.
   *
   * Use this to create additional AGTs for an existing cluster (e.g., for
   * zero-downtime token rotation). The initial AGT is created automatically
   * by CreateCluster.
   *
   * Scope: `clusters:write`
   *
   * @generated from rpc admiral.api.cluster.v1.ClusterAPI.CreateClusterToken
   */
  createClusterToken: {
    methodKind: "unary";
    input: typeof CreateClusterTokenRequestSchema;
    output: typeof CreateClusterTokenResponseSchema;
  },
  /**
   * ListClusterTokens returns a paginated list of AGTs bound to the specified
   * cluster. Token secrets are never included.
   *
   * Scope: `clusters:read`
   *
   * @generated from rpc admiral.api.cluster.v1.ClusterAPI.ListClusterTokens
   */
  listClusterTokens: {
    methodKind: "unary";
    input: typeof ListClusterTokensRequestSchema;
    output: typeof ListClusterTokensResponseSchema;
  },
  /**
   * GetClusterToken retrieves a single AGT by ID.
   * Returns metadata only â€” the token secret is never included.
   *
   * Scope: `clusters:read`
   *
   * @generated from rpc admiral.api.cluster.v1.ClusterAPI.GetClusterToken
   */
  getClusterToken: {
    methodKind: "unary";
    input: typeof GetClusterTokenRequestSchema;
    output: typeof GetClusterTokenResponseSchema;
  },
  /**
   * RevokeClusterToken permanently revokes an AGT bound to this cluster.
   * The agent will receive a 401 on its next request. If this is the only
   * active AGT for the cluster, the agent will become disconnected.
   *
   * Scope: `clusters:write`
   *
   * @generated from rpc admiral.api.cluster.v1.ClusterAPI.RevokeClusterToken
   */
  revokeClusterToken: {
    methodKind: "unary";
    input: typeof RevokeClusterTokenRequestSchema;
    output: typeof RevokeClusterTokenResponseSchema;
  },
  /**
   * ReportClusterStatus receives a combined telemetry snapshot from a K8s agent.
   * The payload includes cluster-level metrics, per-workload status, and
   * Kubernetes events. Admiral splits this into three storage tiers on receipt.
   *
   * This endpoint is agent-facing and restricted to agent tokens.
   *
   * Scope: `clusters:status` | Token types: `agt`
   *
   * @generated from rpc admiral.api.cluster.v1.ClusterAPI.ReportClusterStatus
   */
  reportClusterStatus: {
    methodKind: "unary";
    input: typeof ReportClusterStatusRequestSchema;
    output: typeof ReportClusterStatusResponseSchema;
  },
  /**
   * ListWorkloads returns a paginated list of workloads running in a specific cluster.
   *
   * Scope: `clusters:read`
   *
   * @generated from rpc admiral.api.cluster.v1.ClusterAPI.ListWorkloads
   */
  listWorkloads: {
    methodKind: "unary";
    input: typeof ListWorkloadsRequestSchema;
    output: typeof ListWorkloadsResponseSchema;
  },
  /**
   * ReportWorkloadStatus receives workload-only telemetry from a K8s agent.
   * Used for incremental workload updates between full cluster status pushes.
   *
   * This endpoint is agent-facing and restricted to agent tokens.
   *
   * Scope: `clusters:status` | Token types: `agt`
   *
   * @generated from rpc admiral.api.cluster.v1.ClusterAPI.ReportWorkloadStatus
   */
  reportWorkloadStatus: {
    methodKind: "unary";
    input: typeof ReportWorkloadStatusRequestSchema;
    output: typeof ReportWorkloadStatusResponseSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_cluster_v1_cluster, 0);

