// @generated by protoc-gen-es v2.11.0 with parameter "target=ts"
// @generated from file admiral/source/v1/source.proto (package admiral.source.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv2";
import { enumDesc, fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv2";
import { file_admiral_common_v1_annotations } from "../../common/v1/annotations_pb";
import { file_buf_validate_validate } from "../../../buf/validate/validate_pb";
import { file_google_api_annotations } from "../../../google/api/annotations_pb";
import type { FieldMask, Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_field_mask, file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file admiral/source/v1/source.proto.
 */
export const file_admiral_source_v1_source: GenFile = /*@__PURE__*/
  fileDesc("Ch5hZG1pcmFsL3NvdXJjZS92MS9zb3VyY2UucHJvdG8SEWFkbWlyYWwuc291cmNlLnYxIlEKF1RlcnJhZm9ybVJlZ2lzdHJ5Q29uZmlnEhEKCW5hbWVzcGFjZRgBIAEoCRITCgttb2R1bGVfbmFtZRgCIAEoCRIOCgZzeXN0ZW0YAyABKAkiQQoSVGVycmFmb3JtR2l0Q29uZmlnEhAKCHJlcG9fdXJsGAEgASgJEgwKBHBhdGgYAiABKAkSCwoDcmVmGAMgASgJIjwKFEhlbG1SZXBvc2l0b3J5Q29uZmlnEhAKCHJlcG9fdXJsGAEgASgJEhIKCmNoYXJ0X25hbWUYAiABKAkiOQoNSGVsbU9DSUNvbmZpZxIUCgxyZWdpc3RyeV91cmwYASABKAkSEgoKY2hhcnRfbmFtZRgCIAEoCSI8Cg1IZWxtR2l0Q29uZmlnEhAKCHJlcG9fdXJsGAEgASgJEgwKBHBhdGgYAiABKAkSCwoDcmVmGAMgASgJIkEKEkt1c3RvbWl6ZUdpdENvbmZpZxIQCghyZXBvX3VybBgBIAEoCRIMCgRwYXRoGAIgASgJEgsKA3JlZhgDIAEoCSJAChFNYW5pZmVzdEdpdENvbmZpZxIQCghyZXBvX3VybBgBIAEoCRIMCgRwYXRoGAIgASgJEgsKA3JlZhgDIAEoCSIcCg1BcmNoaXZlQ29uZmlnEgsKA3VybBgBIAEoCSJ6CgtTb3VyY2VJbnB1dBIMCgRuYW1lGAEgASgJEgwKBHR5cGUYAiABKAkSEwoLZGVzY3JpcHRpb24YAyABKAkSFQoNZGVmYXVsdF92YWx1ZRgEIAEoCRIQCghyZXF1aXJlZBgFIAEoCBIRCglzZW5zaXRpdmUYBiABKAgiUgoMU291cmNlT3V0cHV0EgwKBG5hbWUYASABKAkSDAoEdHlwZRgCIAEoCRITCgtkZXNjcmlwdGlvbhgDIAEoCRIRCglzZW5zaXRpdmUYBCABKAgi7gcKBlNvdXJjZRIUCgJpZBgBIAEoCUIIukgFcgOwAQESOgoEbmFtZRgDIAEoCUIsukgpcicQARg/MiFeW2Etel0oW2EtejAtOS1dezAsNjF9W2EtejAtOV0pPyQSHQoLZGVzY3JpcHRpb24YBCABKAlCCLpIBXIDGIAIEjIKC3NvdXJjZV90eXBlGAUgASgOMh0uYWRtaXJhbC5zb3VyY2UudjEuU291cmNlVHlwZRJIChJ0ZXJyYWZvcm1fcmVnaXN0cnkYBiABKAsyKi5hZG1pcmFsLnNvdXJjZS52MS5UZXJyYWZvcm1SZWdpc3RyeUNvbmZpZ0gAEj4KDXRlcnJhZm9ybV9naXQYByABKAsyJS5hZG1pcmFsLnNvdXJjZS52MS5UZXJyYWZvcm1HaXRDb25maWdIABJCCg9oZWxtX3JlcG9zaXRvcnkYCCABKAsyJy5hZG1pcmFsLnNvdXJjZS52MS5IZWxtUmVwb3NpdG9yeUNvbmZpZ0gAEjQKCGhlbG1fb2NpGAkgASgLMiAuYWRtaXJhbC5zb3VyY2UudjEuSGVsbU9DSUNvbmZpZ0gAEjQKCGhlbG1fZ2l0GAogASgLMiAuYWRtaXJhbC5zb3VyY2UudjEuSGVsbUdpdENvbmZpZ0gAEj4KDWt1c3RvbWl6ZV9naXQYCyABKAsyJS5hZG1pcmFsLnNvdXJjZS52MS5LdXN0b21pemVHaXRDb25maWdIABI8CgxtYW5pZmVzdF9naXQYDCABKAsyJC5hZG1pcmFsLnNvdXJjZS52MS5NYW5pZmVzdEdpdENvbmZpZ0gAEjMKB2FyY2hpdmUYDSABKAsyIC5hZG1pcmFsLnNvdXJjZS52MS5BcmNoaXZlQ29uZmlnSAASJAoNY29ubmVjdGlvbl9pZBgOIAEoCUIIukgFcgOwAQFIAYgBARIPCgdjYXRhbG9nGA8gASgIEjUKBmxhYmVscxgQIAMoCzIlLmFkbWlyYWwuc291cmNlLnYxLlNvdXJjZS5MYWJlbHNFbnRyeRIYCgpjcmVhdGVkX2J5GBEgASgJQgTAnSQBEhgKCnVwZGF0ZWRfYnkYEiABKAlCBMCdJAESLgoKY3JlYXRlZF9hdBgTIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASLgoKdXBkYXRlZF9hdBgUIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAaLQoLTGFiZWxzRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgJOgI4AUIPCg1zb3VyY2VfY29uZmlnQhAKDl9jb25uZWN0aW9uX2lkIpcHChNDcmVhdGVTb3VyY2VSZXF1ZXN0EjoKBG5hbWUYAiABKAlCLLpIKXInEAEYPzIhXlthLXpdKFthLXowLTktXXswLDYxfVthLXowLTldKT8kEiIKC2Rlc2NyaXB0aW9uGAMgASgJQgi6SAVyAxiACEgBiAEBEjwKC3NvdXJjZV90eXBlGAQgASgOMh0uYWRtaXJhbC5zb3VyY2UudjEuU291cmNlVHlwZUIIukgFggECEAESSAoSdGVycmFmb3JtX3JlZ2lzdHJ5GAUgASgLMiouYWRtaXJhbC5zb3VyY2UudjEuVGVycmFmb3JtUmVnaXN0cnlDb25maWdIABI+Cg10ZXJyYWZvcm1fZ2l0GAYgASgLMiUuYWRtaXJhbC5zb3VyY2UudjEuVGVycmFmb3JtR2l0Q29uZmlnSAASQgoPaGVsbV9yZXBvc2l0b3J5GAcgASgLMicuYWRtaXJhbC5zb3VyY2UudjEuSGVsbVJlcG9zaXRvcnlDb25maWdIABI0CghoZWxtX29jaRgIIAEoCzIgLmFkbWlyYWwuc291cmNlLnYxLkhlbG1PQ0lDb25maWdIABI0CghoZWxtX2dpdBgJIAEoCzIgLmFkbWlyYWwuc291cmNlLnYxLkhlbG1HaXRDb25maWdIABI+Cg1rdXN0b21pemVfZ2l0GAogASgLMiUuYWRtaXJhbC5zb3VyY2UudjEuS3VzdG9taXplR2l0Q29uZmlnSAASPAoMbWFuaWZlc3RfZ2l0GAsgASgLMiQuYWRtaXJhbC5zb3VyY2UudjEuTWFuaWZlc3RHaXRDb25maWdIABIzCgdhcmNoaXZlGAwgASgLMiAuYWRtaXJhbC5zb3VyY2UudjEuQXJjaGl2ZUNvbmZpZ0gAEiQKDWNvbm5lY3Rpb25faWQYDSABKAlCCLpIBXIDsAEBSAKIAQESDwoHY2F0YWxvZxgOIAEoCBJCCgZsYWJlbHMYDyADKAsyMi5hZG1pcmFsLnNvdXJjZS52MS5DcmVhdGVTb3VyY2VSZXF1ZXN0LkxhYmVsc0VudHJ5EhgKCmNyZWF0ZWRfYnkYECABKAlCBMCdJAEaLQoLTGFiZWxzRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgJOgI4AUIPCg1zb3VyY2VfY29uZmlnQg4KDF9kZXNjcmlwdGlvbkIQCg5fY29ubmVjdGlvbl9pZCJBChRDcmVhdGVTb3VyY2VSZXNwb25zZRIpCgZzb3VyY2UYASABKAsyGS5hZG1pcmFsLnNvdXJjZS52MS5Tb3VyY2UiLwoQR2V0U291cmNlUmVxdWVzdBIbCglzb3VyY2VfaWQYASABKAlCCLpIBXIDsAEBIj4KEUdldFNvdXJjZVJlc3BvbnNlEikKBnNvdXJjZRgBIAEoCzIZLmFkbWlyYWwuc291cmNlLnYxLlNvdXJjZSJfChJMaXN0U291cmNlc1JlcXVlc3QSDgoGZmlsdGVyGAEgASgJEhEKCXBhZ2Vfc2l6ZRgCIAEoBRIXCgpwYWdlX3Rva2VuGAMgASgJSACIAQFCDQoLX3BhZ2VfdG9rZW4iWgoTTGlzdFNvdXJjZXNSZXNwb25zZRIqCgdzb3VyY2VzGAEgAygLMhkuYWRtaXJhbC5zb3VyY2UudjEuU291cmNlEhcKD25leHRfcGFnZV90b2tlbhgCIAEoCSJ5ChNVcGRhdGVTb3VyY2VSZXF1ZXN0EjEKBnNvdXJjZRgBIAEoCzIZLmFkbWlyYWwuc291cmNlLnYxLlNvdXJjZUIGukgDyAEBEi8KC3VwZGF0ZV9tYXNrGAIgASgLMhouZ29vZ2xlLnByb3RvYnVmLkZpZWxkTWFzayJBChRVcGRhdGVTb3VyY2VSZXNwb25zZRIpCgZzb3VyY2UYASABKAsyGS5hZG1pcmFsLnNvdXJjZS52MS5Tb3VyY2UiMgoTRGVsZXRlU291cmNlUmVxdWVzdBIbCglzb3VyY2VfaWQYASABKAlCCLpIBXIDsAEBIhYKFERlbGV0ZVNvdXJjZVJlc3BvbnNlIjgKGUxpc3RTb3VyY2VWZXJzaW9uc1JlcXVlc3QSGwoJc291cmNlX2lkGAEgASgJQgi6SAVyA7ABASIuChpMaXN0U291cmNlVmVyc2lvbnNSZXNwb25zZRIQCgh2ZXJzaW9ucxgBIAMoCSJPChZHZXRTb3VyY2VJbnB1dHNSZXF1ZXN0EhsKCXNvdXJjZV9pZBgBIAEoCUIIukgFcgOwAQESGAoHdmVyc2lvbhgCIAEoCUIHukgEcgIQASJJChdHZXRTb3VyY2VJbnB1dHNSZXNwb25zZRIuCgZpbnB1dHMYASADKAsyHi5hZG1pcmFsLnNvdXJjZS52MS5Tb3VyY2VJbnB1dCJQChdHZXRTb3VyY2VPdXRwdXRzUmVxdWVzdBIbCglzb3VyY2VfaWQYASABKAlCCLpIBXIDsAEBEhgKB3ZlcnNpb24YAiABKAlCB7pIBHICEAEiTAoYR2V0U291cmNlT3V0cHV0c1Jlc3BvbnNlEjAKB291dHB1dHMYASADKAsyHy5hZG1pcmFsLnNvdXJjZS52MS5Tb3VyY2VPdXRwdXQiMAoRU3luY1NvdXJjZVJlcXVlc3QSGwoJc291cmNlX2lkGAEgASgJQgi6SAVyA7ABASIUChJTeW5jU291cmNlUmVzcG9uc2UqlwIKClNvdXJjZVR5cGUSGwoXU09VUkNFX1RZUEVfVU5TUEVDSUZJRUQQABIiCh5TT1VSQ0VfVFlQRV9URVJSQUZPUk1fUkVHSVNUUlkQARIdChlTT1VSQ0VfVFlQRV9URVJSQUZPUk1fR0lUEAISHwobU09VUkNFX1RZUEVfSEVMTV9SRVBPU0lUT1JZEAMSGAoUU09VUkNFX1RZUEVfSEVMTV9PQ0kQBBIYChRTT1VSQ0VfVFlQRV9IRUxNX0dJVBAFEh0KGVNPVVJDRV9UWVBFX0tVU1RPTUlaRV9HSVQQBhIcChhTT1VSQ0VfVFlQRV9NQU5JRkVTVF9HSVQQBxIXChNTT1VSQ0VfVFlQRV9BUkNISVZFEAgysAsKCVNvdXJjZUFQSRKNAQoMQ3JlYXRlU291cmNlEiYuYWRtaXJhbC5zb3VyY2UudjEuQ3JlYXRlU291cmNlUmVxdWVzdBonLmFkbWlyYWwuc291cmNlLnYxLkNyZWF0ZVNvdXJjZVJlc3BvbnNlIiyilyQOCgxzb3VyY2U6d3JpdGWolyQBgtPkkwIQOgEqIgsvdjEvc291cmNlcxKMAQoJR2V0U291cmNlEiMuYWRtaXJhbC5zb3VyY2UudjEuR2V0U291cmNlUmVxdWVzdBokLmFkbWlyYWwuc291cmNlLnYxLkdldFNvdXJjZVJlc3BvbnNlIjSilyQNCgtzb3VyY2U6cmVhZKiXJAGC0+STAhkSFy92MS9zb3VyY2VzL3tzb3VyY2VfaWR9EoYBCgtMaXN0U291cmNlcxIlLmFkbWlyYWwuc291cmNlLnYxLkxpc3RTb3VyY2VzUmVxdWVzdBomLmFkbWlyYWwuc291cmNlLnYxLkxpc3RTb3VyY2VzUmVzcG9uc2UiKKKXJA0KC3NvdXJjZTpyZWFkqJckAYLT5JMCDRILL3YxL3NvdXJjZXMSmQEKDFVwZGF0ZVNvdXJjZRImLmFkbWlyYWwuc291cmNlLnYxLlVwZGF0ZVNvdXJjZVJlcXVlc3QaJy5hZG1pcmFsLnNvdXJjZS52MS5VcGRhdGVTb3VyY2VSZXNwb25zZSI4opckDgoMc291cmNlOndyaXRlqJckAYLT5JMCHDoBKjIXL3YxL3NvdXJjZXMve3NvdXJjZS5pZH0SlgEKDERlbGV0ZVNvdXJjZRImLmFkbWlyYWwuc291cmNlLnYxLkRlbGV0ZVNvdXJjZVJlcXVlc3QaJy5hZG1pcmFsLnNvdXJjZS52MS5EZWxldGVTb3VyY2VSZXNwb25zZSI1opckDgoMc291cmNlOndyaXRlqJckAYLT5JMCGSoXL3YxL3NvdXJjZXMve3NvdXJjZV9pZH0SsAEKEkxpc3RTb3VyY2VWZXJzaW9ucxIsLmFkbWlyYWwuc291cmNlLnYxLkxpc3RTb3VyY2VWZXJzaW9uc1JlcXVlc3QaLS5hZG1pcmFsLnNvdXJjZS52MS5MaXN0U291cmNlVmVyc2lvbnNSZXNwb25zZSI9opckDQoLc291cmNlOnJlYWSolyQBgtPkkwIiEiAvdjEvc291cmNlcy97c291cmNlX2lkfS92ZXJzaW9ucxK4AQoPR2V0U291cmNlSW5wdXRzEikuYWRtaXJhbC5zb3VyY2UudjEuR2V0U291cmNlSW5wdXRzUmVxdWVzdBoqLmFkbWlyYWwuc291cmNlLnYxLkdldFNvdXJjZUlucHV0c1Jlc3BvbnNlIk6ilyQNCgtzb3VyY2U6cmVhZKiXJAGC0+STAjMSMS92MS9zb3VyY2VzL3tzb3VyY2VfaWR9L3ZlcnNpb25zL3t2ZXJzaW9ufS9pbnB1dHMSvAEKEEdldFNvdXJjZU91dHB1dHMSKi5hZG1pcmFsLnNvdXJjZS52MS5HZXRTb3VyY2VPdXRwdXRzUmVxdWVzdBorLmFkbWlyYWwuc291cmNlLnYxLkdldFNvdXJjZU91dHB1dHNSZXNwb25zZSJPopckDQoLc291cmNlOnJlYWSolyQBgtPkkwI0EjIvdjEvc291cmNlcy97c291cmNlX2lkfS92ZXJzaW9ucy97dmVyc2lvbn0vb3V0cHV0cxKYAQoKU3luY1NvdXJjZRIkLmFkbWlyYWwuc291cmNlLnYxLlN5bmNTb3VyY2VSZXF1ZXN0GiUuYWRtaXJhbC5zb3VyY2UudjEuU3luY1NvdXJjZVJlc3BvbnNlIj2ilyQOCgxzb3VyY2U6d3JpdGWolyQBgtPkkwIhOgEqIhwvdjEvc291cmNlcy97c291cmNlX2lkfS9zeW5jQr4BChVjb20uYWRtaXJhbC5zb3VyY2UudjFCC1NvdXJjZVByb3RvUAFaMmdvLmFkbWlyYWwuaW8vc2RrL3Byb3RvL2FkbWlyYWwvc291cmNlL3YxO3NvdXJjZXYxogIDQVNYqgIRQWRtaXJhbC5Tb3VyY2UuVjHKAhFBZG1pcmFsXFNvdXJjZVxWMeICHUFkbWlyYWxcU291cmNlXFYxXEdQQk1ldGFkYXRh6gITQWRtaXJhbDo6U291cmNlOjpWMWIGcHJvdG8z", [file_admiral_common_v1_annotations, file_buf_validate_validate, file_google_api_annotations, file_google_protobuf_field_mask, file_google_protobuf_timestamp]);

/**
 * TerraformRegistryConfig contains settings for a Terraform registry source.
 *
 * @generated from message admiral.source.v1.TerraformRegistryConfig
 */
export type TerraformRegistryConfig = Message<"admiral.source.v1.TerraformRegistryConfig"> & {
  /**
   * Registry namespace (e.g., "hashicorp").
   *
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * Module name (e.g., "consul").
   *
   * @generated from field: string module_name = 2;
   */
  moduleName: string;

  /**
   * Target system (e.g., "aws", "azurerm", "google").
   *
   * @generated from field: string system = 3;
   */
  system: string;
};

/**
 * Describes the message admiral.source.v1.TerraformRegistryConfig.
 * Use `create(TerraformRegistryConfigSchema)` to create a new message.
 */
export const TerraformRegistryConfigSchema: GenMessage<TerraformRegistryConfig> = /*@__PURE__*/
  messageDesc(file_admiral_source_v1_source, 0);

/**
 * TerraformGitConfig contains settings for a Terraform module in a Git repository.
 *
 * @generated from message admiral.source.v1.TerraformGitConfig
 */
export type TerraformGitConfig = Message<"admiral.source.v1.TerraformGitConfig"> & {
  /**
   * Git repository URL.
   *
   * @generated from field: string repo_url = 1;
   */
  repoUrl: string;

  /**
   * Path to the module within the repository.
   *
   * @generated from field: string path = 2;
   */
  path: string;

  /**
   * Git ref (branch, tag, or commit SHA). Defaults to the repository's default branch.
   *
   * @generated from field: string ref = 3;
   */
  ref: string;
};

/**
 * Describes the message admiral.source.v1.TerraformGitConfig.
 * Use `create(TerraformGitConfigSchema)` to create a new message.
 */
export const TerraformGitConfigSchema: GenMessage<TerraformGitConfig> = /*@__PURE__*/
  messageDesc(file_admiral_source_v1_source, 1);

/**
 * HelmRepositoryConfig contains settings for a Helm chart in an HTTP(S) repository.
 *
 * @generated from message admiral.source.v1.HelmRepositoryConfig
 */
export type HelmRepositoryConfig = Message<"admiral.source.v1.HelmRepositoryConfig"> & {
  /**
   * Helm chart repository URL.
   *
   * @generated from field: string repo_url = 1;
   */
  repoUrl: string;

  /**
   * Chart name within the repository.
   *
   * @generated from field: string chart_name = 2;
   */
  chartName: string;
};

/**
 * Describes the message admiral.source.v1.HelmRepositoryConfig.
 * Use `create(HelmRepositoryConfigSchema)` to create a new message.
 */
export const HelmRepositoryConfigSchema: GenMessage<HelmRepositoryConfig> = /*@__PURE__*/
  messageDesc(file_admiral_source_v1_source, 2);

/**
 * HelmOCIConfig contains settings for a Helm chart in an OCI registry.
 *
 * @generated from message admiral.source.v1.HelmOCIConfig
 */
export type HelmOCIConfig = Message<"admiral.source.v1.HelmOCIConfig"> & {
  /**
   * OCI registry URL (e.g., "oci://ghcr.io/org").
   *
   * @generated from field: string registry_url = 1;
   */
  registryUrl: string;

  /**
   * Chart name within the registry.
   *
   * @generated from field: string chart_name = 2;
   */
  chartName: string;
};

/**
 * Describes the message admiral.source.v1.HelmOCIConfig.
 * Use `create(HelmOCIConfigSchema)` to create a new message.
 */
export const HelmOCIConfigSchema: GenMessage<HelmOCIConfig> = /*@__PURE__*/
  messageDesc(file_admiral_source_v1_source, 3);

/**
 * HelmGitConfig contains settings for a Helm chart in a Git repository.
 *
 * @generated from message admiral.source.v1.HelmGitConfig
 */
export type HelmGitConfig = Message<"admiral.source.v1.HelmGitConfig"> & {
  /**
   * Git repository URL.
   *
   * @generated from field: string repo_url = 1;
   */
  repoUrl: string;

  /**
   * Path to the chart within the repository.
   *
   * @generated from field: string path = 2;
   */
  path: string;

  /**
   * Git ref (branch, tag, or commit SHA). Defaults to the repository's default branch.
   *
   * @generated from field: string ref = 3;
   */
  ref: string;
};

/**
 * Describes the message admiral.source.v1.HelmGitConfig.
 * Use `create(HelmGitConfigSchema)` to create a new message.
 */
export const HelmGitConfigSchema: GenMessage<HelmGitConfig> = /*@__PURE__*/
  messageDesc(file_admiral_source_v1_source, 4);

/**
 * KustomizeGitConfig contains settings for a Kustomize overlay in a Git repository.
 *
 * @generated from message admiral.source.v1.KustomizeGitConfig
 */
export type KustomizeGitConfig = Message<"admiral.source.v1.KustomizeGitConfig"> & {
  /**
   * Git repository URL.
   *
   * @generated from field: string repo_url = 1;
   */
  repoUrl: string;

  /**
   * Path to the kustomization directory within the repository.
   *
   * @generated from field: string path = 2;
   */
  path: string;

  /**
   * Git ref (branch, tag, or commit SHA). Defaults to the repository's default branch.
   *
   * @generated from field: string ref = 3;
   */
  ref: string;
};

/**
 * Describes the message admiral.source.v1.KustomizeGitConfig.
 * Use `create(KustomizeGitConfigSchema)` to create a new message.
 */
export const KustomizeGitConfigSchema: GenMessage<KustomizeGitConfig> = /*@__PURE__*/
  messageDesc(file_admiral_source_v1_source, 5);

/**
 * ManifestGitConfig contains settings for raw Kubernetes manifests in a Git repository.
 *
 * @generated from message admiral.source.v1.ManifestGitConfig
 */
export type ManifestGitConfig = Message<"admiral.source.v1.ManifestGitConfig"> & {
  /**
   * Git repository URL.
   *
   * @generated from field: string repo_url = 1;
   */
  repoUrl: string;

  /**
   * Path to the manifests directory within the repository.
   *
   * @generated from field: string path = 2;
   */
  path: string;

  /**
   * Git ref (branch, tag, or commit SHA). Defaults to the repository's default branch.
   *
   * @generated from field: string ref = 3;
   */
  ref: string;
};

/**
 * Describes the message admiral.source.v1.ManifestGitConfig.
 * Use `create(ManifestGitConfigSchema)` to create a new message.
 */
export const ManifestGitConfigSchema: GenMessage<ManifestGitConfig> = /*@__PURE__*/
  messageDesc(file_admiral_source_v1_source, 6);

/**
 * ArchiveConfig contains settings for a downloadable archive source.
 *
 * @generated from message admiral.source.v1.ArchiveConfig
 */
export type ArchiveConfig = Message<"admiral.source.v1.ArchiveConfig"> & {
  /**
   * URL to the archive (tar.gz, zip).
   *
   * @generated from field: string url = 1;
   */
  url: string;
};

/**
 * Describes the message admiral.source.v1.ArchiveConfig.
 * Use `create(ArchiveConfigSchema)` to create a new message.
 */
export const ArchiveConfigSchema: GenMessage<ArchiveConfig> = /*@__PURE__*/
  messageDesc(file_admiral_source_v1_source, 7);

/**
 * SourceInput describes a single input parameter for a source artifact.
 * For Terraform: parsed from variable blocks via terraform-config-inspect.
 * For Helm: parsed from values.yaml and values.schema.json.
 *
 * @generated from message admiral.source.v1.SourceInput
 */
export type SourceInput = Message<"admiral.source.v1.SourceInput"> & {
  /**
   * Input parameter name (e.g., "instance_type", "replicaCount").
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Input type (e.g., "string", "number", "bool", "list", "map").
   *
   * @generated from field: string type = 2;
   */
  type: string;

  /**
   * Human-readable description of the input.
   *
   * @generated from field: string description = 3;
   */
  description: string;

  /**
   * Default value as a JSON-encoded string. Empty if no default is defined.
   *
   * @generated from field: string default_value = 4;
   */
  defaultValue: string;

  /**
   * Whether this input is required (no default value).
   *
   * @generated from field: bool required = 5;
   */
  required: boolean;

  /**
   * Whether this input contains sensitive data.
   *
   * @generated from field: bool sensitive = 6;
   */
  sensitive: boolean;
};

/**
 * Describes the message admiral.source.v1.SourceInput.
 * Use `create(SourceInputSchema)` to create a new message.
 */
export const SourceInputSchema: GenMessage<SourceInput> = /*@__PURE__*/
  messageDesc(file_admiral_source_v1_source, 8);

/**
 * SourceOutput describes a single output from a source artifact.
 * Only applicable to Terraform sources — Helm/Kustomize have no formal outputs.
 *
 * @generated from message admiral.source.v1.SourceOutput
 */
export type SourceOutput = Message<"admiral.source.v1.SourceOutput"> & {
  /**
   * Output name (e.g., "cluster_endpoint", "database_url").
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Output type (e.g., "string", "list", "map").
   *
   * @generated from field: string type = 2;
   */
  type: string;

  /**
   * Human-readable description of the output.
   *
   * @generated from field: string description = 3;
   */
  description: string;

  /**
   * Whether this output contains sensitive data.
   *
   * @generated from field: bool sensitive = 4;
   */
  sensitive: boolean;
};

/**
 * Describes the message admiral.source.v1.SourceOutput.
 * Use `create(SourceOutputSchema)` to create a new message.
 */
export const SourceOutputSchema: GenMessage<SourceOutput> = /*@__PURE__*/
  messageDesc(file_admiral_source_v1_source, 9);

/**
 * Source represents a tenant-scoped artifact definition pointing to an external
 * module, chart, manifest set, or archive. Sources are referenced by components
 * to define what gets deployed.
 *
 * @generated from message admiral.source.v1.Source
 */
export type Source = Message<"admiral.source.v1.Source"> & {
  /**
   * Unique identifier for the source (UUID).
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * URL-safe, human-readable identifier (e.g., "vpc-module", "nginx-chart").
   * Unique within the tenant. Lowercase alphanumeric and hyphens only, must
   * start with a letter and end with an alphanumeric character (1-63 chars).
   *
   * @generated from field: string name = 3;
   */
  name: string;

  /**
   * Optional longer-form description of the source's purpose.
   *
   * @generated from field: string description = 4;
   */
  description: string;

  /**
   * The type of artifact this source points to.
   *
   * @generated from field: admiral.source.v1.SourceType source_type = 5;
   */
  sourceType: SourceType;

  /**
   * Type-specific source configuration. The active field must match source_type.
   *
   * @generated from oneof admiral.source.v1.Source.source_config
   */
  sourceConfig: {
    /**
     * Terraform registry module.
     *
     * @generated from field: admiral.source.v1.TerraformRegistryConfig terraform_registry = 6;
     */
    value: TerraformRegistryConfig;
    case: "terraformRegistry";
  } | {
    /**
     * Terraform module in a Git repository.
     *
     * @generated from field: admiral.source.v1.TerraformGitConfig terraform_git = 7;
     */
    value: TerraformGitConfig;
    case: "terraformGit";
  } | {
    /**
     * Helm chart from an HTTP(S) repository.
     *
     * @generated from field: admiral.source.v1.HelmRepositoryConfig helm_repository = 8;
     */
    value: HelmRepositoryConfig;
    case: "helmRepository";
  } | {
    /**
     * Helm chart from an OCI registry.
     *
     * @generated from field: admiral.source.v1.HelmOCIConfig helm_oci = 9;
     */
    value: HelmOCIConfig;
    case: "helmOci";
  } | {
    /**
     * Helm chart from a Git repository.
     *
     * @generated from field: admiral.source.v1.HelmGitConfig helm_git = 10;
     */
    value: HelmGitConfig;
    case: "helmGit";
  } | {
    /**
     * Kustomize overlay from a Git repository.
     *
     * @generated from field: admiral.source.v1.KustomizeGitConfig kustomize_git = 11;
     */
    value: KustomizeGitConfig;
    case: "kustomizeGit";
  } | {
    /**
     * Raw Kubernetes manifests from a Git repository.
     *
     * @generated from field: admiral.source.v1.ManifestGitConfig manifest_git = 12;
     */
    value: ManifestGitConfig;
    case: "manifestGit";
  } | {
    /**
     * Downloadable archive.
     *
     * @generated from field: admiral.source.v1.ArchiveConfig archive = 13;
     */
    value: ArchiveConfig;
    case: "archive";
  } | { case: undefined; value?: undefined };

  /**
   * The connection providing credentials for this source (UUID). Null for
   * public sources that require no authentication.
   *
   * @generated from field: optional string connection_id = 14;
   */
  connectionId?: string;

  /**
   * Whether this source is a curated catalog entry. Platform engineers mark
   * sources as catalog entries for developer self-service consumption.
   *
   * @generated from field: bool catalog = 15;
   */
  catalog: boolean;

  /**
   * Arbitrary key-value labels for organizing and filtering sources.
   *
   * @generated from field: map<string, string> labels = 16;
   */
  labels: { [key: string]: string };

  /**
   * User ID who created the source.
   *
   * @generated from field: string created_by = 17;
   */
  createdBy: string;

  /**
   * User ID who last updated the source.
   *
   * @generated from field: string updated_by = 18;
   */
  updatedBy: string;

  /**
   * When the source was created.
   *
   * @generated from field: google.protobuf.Timestamp created_at = 19;
   */
  createdAt?: Timestamp;

  /**
   * When the source was last updated.
   *
   * @generated from field: google.protobuf.Timestamp updated_at = 20;
   */
  updatedAt?: Timestamp;
};

/**
 * Describes the message admiral.source.v1.Source.
 * Use `create(SourceSchema)` to create a new message.
 */
export const SourceSchema: GenMessage<Source> = /*@__PURE__*/
  messageDesc(file_admiral_source_v1_source, 10);

/**
 * CreateSourceRequest contains the parameters for creating a new source.
 *
 * @generated from message admiral.source.v1.CreateSourceRequest
 */
export type CreateSourceRequest = Message<"admiral.source.v1.CreateSourceRequest"> & {
  /**
   * URL-safe, human-readable identifier (e.g., "vpc-module"). Must be unique
   * within the tenant. Lowercase alphanumeric and hyphens only.
   *
   * @generated from field: string name = 2;
   */
  name: string;

  /**
   * Optional longer-form description of the source's purpose.
   *
   * @generated from field: optional string description = 3;
   */
  description?: string;

  /**
   * The type of artifact this source points to.
   *
   * @generated from field: admiral.source.v1.SourceType source_type = 4;
   */
  sourceType: SourceType;

  /**
   * Type-specific source configuration. Must match source_type.
   *
   * @generated from oneof admiral.source.v1.CreateSourceRequest.source_config
   */
  sourceConfig: {
    /**
     * Terraform registry module.
     *
     * @generated from field: admiral.source.v1.TerraformRegistryConfig terraform_registry = 5;
     */
    value: TerraformRegistryConfig;
    case: "terraformRegistry";
  } | {
    /**
     * Terraform module in a Git repository.
     *
     * @generated from field: admiral.source.v1.TerraformGitConfig terraform_git = 6;
     */
    value: TerraformGitConfig;
    case: "terraformGit";
  } | {
    /**
     * Helm chart from an HTTP(S) repository.
     *
     * @generated from field: admiral.source.v1.HelmRepositoryConfig helm_repository = 7;
     */
    value: HelmRepositoryConfig;
    case: "helmRepository";
  } | {
    /**
     * Helm chart from an OCI registry.
     *
     * @generated from field: admiral.source.v1.HelmOCIConfig helm_oci = 8;
     */
    value: HelmOCIConfig;
    case: "helmOci";
  } | {
    /**
     * Helm chart from a Git repository.
     *
     * @generated from field: admiral.source.v1.HelmGitConfig helm_git = 9;
     */
    value: HelmGitConfig;
    case: "helmGit";
  } | {
    /**
     * Kustomize overlay from a Git repository.
     *
     * @generated from field: admiral.source.v1.KustomizeGitConfig kustomize_git = 10;
     */
    value: KustomizeGitConfig;
    case: "kustomizeGit";
  } | {
    /**
     * Raw Kubernetes manifests from a Git repository.
     *
     * @generated from field: admiral.source.v1.ManifestGitConfig manifest_git = 11;
     */
    value: ManifestGitConfig;
    case: "manifestGit";
  } | {
    /**
     * Downloadable archive.
     *
     * @generated from field: admiral.source.v1.ArchiveConfig archive = 12;
     */
    value: ArchiveConfig;
    case: "archive";
  } | { case: undefined; value?: undefined };

  /**
   * The connection providing credentials for this source (UUID). Omit for
   * public sources that require no authentication.
   *
   * @generated from field: optional string connection_id = 13;
   */
  connectionId?: string;

  /**
   * Whether this source is a curated catalog entry.
   *
   * @generated from field: bool catalog = 14;
   */
  catalog: boolean;

  /**
   * Arbitrary key-value labels for organizing and filtering sources.
   *
   * @generated from field: map<string, string> labels = 15;
   */
  labels: { [key: string]: string };

  /**
   * User ID who is creating the source.
   *
   * @generated from field: string created_by = 16;
   */
  createdBy: string;
};

/**
 * Describes the message admiral.source.v1.CreateSourceRequest.
 * Use `create(CreateSourceRequestSchema)` to create a new message.
 */
export const CreateSourceRequestSchema: GenMessage<CreateSourceRequest> = /*@__PURE__*/
  messageDesc(file_admiral_source_v1_source, 11);

/**
 * CreateSourceResponse contains the newly created source.
 *
 * @generated from message admiral.source.v1.CreateSourceResponse
 */
export type CreateSourceResponse = Message<"admiral.source.v1.CreateSourceResponse"> & {
  /**
   * The created source.
   *
   * @generated from field: admiral.source.v1.Source source = 1;
   */
  source?: Source;
};

/**
 * Describes the message admiral.source.v1.CreateSourceResponse.
 * Use `create(CreateSourceResponseSchema)` to create a new message.
 */
export const CreateSourceResponseSchema: GenMessage<CreateSourceResponse> = /*@__PURE__*/
  messageDesc(file_admiral_source_v1_source, 12);

/**
 * GetSourceRequest identifies a source to retrieve.
 *
 * @generated from message admiral.source.v1.GetSourceRequest
 */
export type GetSourceRequest = Message<"admiral.source.v1.GetSourceRequest"> & {
  /**
   * The unique identifier of the source (UUID).
   *
   * @generated from field: string source_id = 1;
   */
  sourceId: string;
};

/**
 * Describes the message admiral.source.v1.GetSourceRequest.
 * Use `create(GetSourceRequestSchema)` to create a new message.
 */
export const GetSourceRequestSchema: GenMessage<GetSourceRequest> = /*@__PURE__*/
  messageDesc(file_admiral_source_v1_source, 13);

/**
 * GetSourceResponse contains the requested source.
 *
 * @generated from message admiral.source.v1.GetSourceResponse
 */
export type GetSourceResponse = Message<"admiral.source.v1.GetSourceResponse"> & {
  /**
   * The source record.
   *
   * @generated from field: admiral.source.v1.Source source = 1;
   */
  source?: Source;
};

/**
 * Describes the message admiral.source.v1.GetSourceResponse.
 * Use `create(GetSourceResponseSchema)` to create a new message.
 */
export const GetSourceResponseSchema: GenMessage<GetSourceResponse> = /*@__PURE__*/
  messageDesc(file_admiral_source_v1_source, 14);

/**
 * ListSourcesRequest contains pagination and filter parameters.
 *
 * @generated from message admiral.source.v1.ListSourcesRequest
 */
export type ListSourcesRequest = Message<"admiral.source.v1.ListSourcesRequest"> & {
  /**
   * Filter expression using the PEG filter DSL. Supported fields include
   * `tenant_id`, `source_type`, `catalog`, `name`, and label selectors.
   *
   * @generated from field: string filter = 1;
   */
  filter: string;

  /**
   * Maximum number of sources to return per page.
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize: number;

  /**
   * Opaque pagination token from a previous response.
   *
   * @generated from field: optional string page_token = 3;
   */
  pageToken?: string;
};

/**
 * Describes the message admiral.source.v1.ListSourcesRequest.
 * Use `create(ListSourcesRequestSchema)` to create a new message.
 */
export const ListSourcesRequestSchema: GenMessage<ListSourcesRequest> = /*@__PURE__*/
  messageDesc(file_admiral_source_v1_source, 15);

/**
 * ListSourcesResponse contains a page of sources.
 *
 * @generated from message admiral.source.v1.ListSourcesResponse
 */
export type ListSourcesResponse = Message<"admiral.source.v1.ListSourcesResponse"> & {
  /**
   * The list of sources matching the filter.
   *
   * @generated from field: repeated admiral.source.v1.Source sources = 1;
   */
  sources: Source[];

  /**
   * Token to retrieve the next page. Empty when there are no more results.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;
};

/**
 * Describes the message admiral.source.v1.ListSourcesResponse.
 * Use `create(ListSourcesResponseSchema)` to create a new message.
 */
export const ListSourcesResponseSchema: GenMessage<ListSourcesResponse> = /*@__PURE__*/
  messageDesc(file_admiral_source_v1_source, 16);

/**
 * UpdateSourceRequest contains the source with updated fields.
 *
 * @generated from message admiral.source.v1.UpdateSourceRequest
 */
export type UpdateSourceRequest = Message<"admiral.source.v1.UpdateSourceRequest"> & {
  /**
   * The source with updated fields. The source's id field is required to
   * identify which source to update.
   *
   * @generated from field: admiral.source.v1.Source source = 1;
   */
  source?: Source;

  /**
   * The set of fields to update. If unset, all mutable fields are updated.
   * Supported fields: `name`, `description`, `source_type`, `source_config`,
   * `connection_id`, `catalog`, `labels`.
   *
   * @generated from field: google.protobuf.FieldMask update_mask = 2;
   */
  updateMask?: FieldMask;
};

/**
 * Describes the message admiral.source.v1.UpdateSourceRequest.
 * Use `create(UpdateSourceRequestSchema)` to create a new message.
 */
export const UpdateSourceRequestSchema: GenMessage<UpdateSourceRequest> = /*@__PURE__*/
  messageDesc(file_admiral_source_v1_source, 17);

/**
 * UpdateSourceResponse contains the updated source.
 *
 * @generated from message admiral.source.v1.UpdateSourceResponse
 */
export type UpdateSourceResponse = Message<"admiral.source.v1.UpdateSourceResponse"> & {
  /**
   * The updated source with all fields reflecting the current state.
   *
   * @generated from field: admiral.source.v1.Source source = 1;
   */
  source?: Source;
};

/**
 * Describes the message admiral.source.v1.UpdateSourceResponse.
 * Use `create(UpdateSourceResponseSchema)` to create a new message.
 */
export const UpdateSourceResponseSchema: GenMessage<UpdateSourceResponse> = /*@__PURE__*/
  messageDesc(file_admiral_source_v1_source, 18);

/**
 * DeleteSourceRequest identifies a source to delete.
 * Deletion fails if any application components still reference this source.
 *
 * @generated from message admiral.source.v1.DeleteSourceRequest
 */
export type DeleteSourceRequest = Message<"admiral.source.v1.DeleteSourceRequest"> & {
  /**
   * The unique identifier of the source to delete (UUID).
   *
   * @generated from field: string source_id = 1;
   */
  sourceId: string;
};

/**
 * Describes the message admiral.source.v1.DeleteSourceRequest.
 * Use `create(DeleteSourceRequestSchema)` to create a new message.
 */
export const DeleteSourceRequestSchema: GenMessage<DeleteSourceRequest> = /*@__PURE__*/
  messageDesc(file_admiral_source_v1_source, 19);

/**
 * DeleteSourceResponse is returned when the source has been successfully deleted.
 *
 * @generated from message admiral.source.v1.DeleteSourceResponse
 */
export type DeleteSourceResponse = Message<"admiral.source.v1.DeleteSourceResponse"> & {
};

/**
 * Describes the message admiral.source.v1.DeleteSourceResponse.
 * Use `create(DeleteSourceResponseSchema)` to create a new message.
 */
export const DeleteSourceResponseSchema: GenMessage<DeleteSourceResponse> = /*@__PURE__*/
  messageDesc(file_admiral_source_v1_source, 20);

/**
 * ListSourceVersionsRequest identifies a source whose available versions to list.
 *
 * @generated from message admiral.source.v1.ListSourceVersionsRequest
 */
export type ListSourceVersionsRequest = Message<"admiral.source.v1.ListSourceVersionsRequest"> & {
  /**
   * The unique identifier of the source (UUID).
   *
   * @generated from field: string source_id = 1;
   */
  sourceId: string;
};

/**
 * Describes the message admiral.source.v1.ListSourceVersionsRequest.
 * Use `create(ListSourceVersionsRequestSchema)` to create a new message.
 */
export const ListSourceVersionsRequestSchema: GenMessage<ListSourceVersionsRequest> = /*@__PURE__*/
  messageDesc(file_admiral_source_v1_source, 21);

/**
 * ListSourceVersionsResponse contains the available versions for a source.
 *
 * @generated from message admiral.source.v1.ListSourceVersionsResponse
 */
export type ListSourceVersionsResponse = Message<"admiral.source.v1.ListSourceVersionsResponse"> & {
  /**
   * Available versions from the external system (e.g., semver tags, commit SHAs).
   *
   * @generated from field: repeated string versions = 1;
   */
  versions: string[];
};

/**
 * Describes the message admiral.source.v1.ListSourceVersionsResponse.
 * Use `create(ListSourceVersionsResponseSchema)` to create a new message.
 */
export const ListSourceVersionsResponseSchema: GenMessage<ListSourceVersionsResponse> = /*@__PURE__*/
  messageDesc(file_admiral_source_v1_source, 22);

/**
 * GetSourceInputsRequest identifies a source and version to parse inputs from.
 *
 * @generated from message admiral.source.v1.GetSourceInputsRequest
 */
export type GetSourceInputsRequest = Message<"admiral.source.v1.GetSourceInputsRequest"> & {
  /**
   * The unique identifier of the source (UUID).
   *
   * @generated from field: string source_id = 1;
   */
  sourceId: string;

  /**
   * The version to fetch and parse (e.g., "1.2.3", "v2.0.0", commit SHA).
   *
   * @generated from field: string version = 2;
   */
  version: string;
};

/**
 * Describes the message admiral.source.v1.GetSourceInputsRequest.
 * Use `create(GetSourceInputsRequestSchema)` to create a new message.
 */
export const GetSourceInputsRequestSchema: GenMessage<GetSourceInputsRequest> = /*@__PURE__*/
  messageDesc(file_admiral_source_v1_source, 23);

/**
 * GetSourceInputsResponse contains the parsed inputs for a source version.
 *
 * @generated from message admiral.source.v1.GetSourceInputsResponse
 */
export type GetSourceInputsResponse = Message<"admiral.source.v1.GetSourceInputsResponse"> & {
  /**
   * The parsed input parameters.
   *
   * @generated from field: repeated admiral.source.v1.SourceInput inputs = 1;
   */
  inputs: SourceInput[];
};

/**
 * Describes the message admiral.source.v1.GetSourceInputsResponse.
 * Use `create(GetSourceInputsResponseSchema)` to create a new message.
 */
export const GetSourceInputsResponseSchema: GenMessage<GetSourceInputsResponse> = /*@__PURE__*/
  messageDesc(file_admiral_source_v1_source, 24);

/**
 * GetSourceOutputsRequest identifies a source and version to parse outputs from.
 *
 * @generated from message admiral.source.v1.GetSourceOutputsRequest
 */
export type GetSourceOutputsRequest = Message<"admiral.source.v1.GetSourceOutputsRequest"> & {
  /**
   * The unique identifier of the source (UUID).
   *
   * @generated from field: string source_id = 1;
   */
  sourceId: string;

  /**
   * The version to fetch and parse (e.g., "1.2.3", "v2.0.0", commit SHA).
   *
   * @generated from field: string version = 2;
   */
  version: string;
};

/**
 * Describes the message admiral.source.v1.GetSourceOutputsRequest.
 * Use `create(GetSourceOutputsRequestSchema)` to create a new message.
 */
export const GetSourceOutputsRequestSchema: GenMessage<GetSourceOutputsRequest> = /*@__PURE__*/
  messageDesc(file_admiral_source_v1_source, 25);

/**
 * GetSourceOutputsResponse contains the parsed outputs for a source version.
 * Only populated for Terraform sources — workload sources have no formal outputs.
 *
 * @generated from message admiral.source.v1.GetSourceOutputsResponse
 */
export type GetSourceOutputsResponse = Message<"admiral.source.v1.GetSourceOutputsResponse"> & {
  /**
   * The parsed output definitions.
   *
   * @generated from field: repeated admiral.source.v1.SourceOutput outputs = 1;
   */
  outputs: SourceOutput[];
};

/**
 * Describes the message admiral.source.v1.GetSourceOutputsResponse.
 * Use `create(GetSourceOutputsResponseSchema)` to create a new message.
 */
export const GetSourceOutputsResponseSchema: GenMessage<GetSourceOutputsResponse> = /*@__PURE__*/
  messageDesc(file_admiral_source_v1_source, 26);

/**
 * SyncSourceRequest triggers a metadata refresh for a source.
 *
 * @generated from message admiral.source.v1.SyncSourceRequest
 */
export type SyncSourceRequest = Message<"admiral.source.v1.SyncSourceRequest"> & {
  /**
   * The unique identifier of the source to sync (UUID).
   *
   * @generated from field: string source_id = 1;
   */
  sourceId: string;
};

/**
 * Describes the message admiral.source.v1.SyncSourceRequest.
 * Use `create(SyncSourceRequestSchema)` to create a new message.
 */
export const SyncSourceRequestSchema: GenMessage<SyncSourceRequest> = /*@__PURE__*/
  messageDesc(file_admiral_source_v1_source, 27);

/**
 * SyncSourceResponse acknowledges the sync request.
 *
 * @generated from message admiral.source.v1.SyncSourceResponse
 */
export type SyncSourceResponse = Message<"admiral.source.v1.SyncSourceResponse"> & {
};

/**
 * Describes the message admiral.source.v1.SyncSourceResponse.
 * Use `create(SyncSourceResponseSchema)` to create a new message.
 */
export const SyncSourceResponseSchema: GenMessage<SyncSourceResponse> = /*@__PURE__*/
  messageDesc(file_admiral_source_v1_source, 28);

/**
 * SourceType identifies the kind of artifact a source points to.
 *
 * @generated from enum admiral.source.v1.SourceType
 */
export enum SourceType {
  /**
   * Default value. Must not be used.
   *
   * @generated from enum value: SOURCE_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Terraform module from a registry (public or private).
   *
   * @generated from enum value: SOURCE_TYPE_TERRAFORM_REGISTRY = 1;
   */
  TERRAFORM_REGISTRY = 1,

  /**
   * Terraform module from a Git repository.
   *
   * @generated from enum value: SOURCE_TYPE_TERRAFORM_GIT = 2;
   */
  TERRAFORM_GIT = 2,

  /**
   * Helm chart from an HTTP(S) chart repository.
   *
   * @generated from enum value: SOURCE_TYPE_HELM_REPOSITORY = 3;
   */
  HELM_REPOSITORY = 3,

  /**
   * Helm chart from an OCI-compliant registry.
   *
   * @generated from enum value: SOURCE_TYPE_HELM_OCI = 4;
   */
  HELM_OCI = 4,

  /**
   * Helm chart from a Git repository.
   *
   * @generated from enum value: SOURCE_TYPE_HELM_GIT = 5;
   */
  HELM_GIT = 5,

  /**
   * Kustomize overlay from a Git repository.
   *
   * @generated from enum value: SOURCE_TYPE_KUSTOMIZE_GIT = 6;
   */
  KUSTOMIZE_GIT = 6,

  /**
   * Raw Kubernetes manifests from a Git repository.
   *
   * @generated from enum value: SOURCE_TYPE_MANIFEST_GIT = 7;
   */
  MANIFEST_GIT = 7,

  /**
   * Downloadable archive (tar.gz, zip).
   *
   * @generated from enum value: SOURCE_TYPE_ARCHIVE = 8;
   */
  ARCHIVE = 8,
}

/**
 * Describes the enum admiral.source.v1.SourceType.
 */
export const SourceTypeSchema: GenEnum<SourceType> = /*@__PURE__*/
  enumDesc(file_admiral_source_v1_source, 0);

/**
 * SourceAPI manages the lifecycle of sources within a tenant.
 *
 * Sources are tenant-scoped artifact definitions — pointers to external modules,
 * charts, manifests, or archives. They reference a connection for credentials
 * (optional for public sources) and can be marked as catalog entries for
 * curated self-service consumption.
 *
 * Discovery RPCs (ListSourceVersions, GetSourceInputs, GetSourceOutputs) query
 * the external system to help users explore available versions and parameters.
 *
 * @generated from service admiral.source.v1.SourceAPI
 */
export const SourceAPI: GenService<{
  /**
   * CreateSource creates a new source within the caller's tenant.
   *
   * Scope: `source:write`
   *
   * @generated from rpc admiral.source.v1.SourceAPI.CreateSource
   */
  createSource: {
    methodKind: "unary";
    input: typeof CreateSourceRequestSchema;
    output: typeof CreateSourceResponseSchema;
  },
  /**
   * GetSource retrieves a source by ID.
   *
   * Scope: `source:read`
   *
   * @generated from rpc admiral.source.v1.SourceAPI.GetSource
   */
  getSource: {
    methodKind: "unary";
    input: typeof GetSourceRequestSchema;
    output: typeof GetSourceResponseSchema;
  },
  /**
   * ListSources returns a paginated list of sources within the caller's tenant.
   *
   * Scope: `source:read`
   *
   * @generated from rpc admiral.source.v1.SourceAPI.ListSources
   */
  listSources: {
    methodKind: "unary";
    input: typeof ListSourcesRequestSchema;
    output: typeof ListSourcesResponseSchema;
  },
  /**
   * UpdateSource updates a source's mutable fields.
   *
   * Scope: `source:write`
   *
   * @generated from rpc admiral.source.v1.SourceAPI.UpdateSource
   */
  updateSource: {
    methodKind: "unary";
    input: typeof UpdateSourceRequestSchema;
    output: typeof UpdateSourceResponseSchema;
  },
  /**
   * DeleteSource permanently deletes a source. Fails if any application
   * components still reference this source. This action cannot be undone.
   *
   * Scope: `source:write`
   *
   * @generated from rpc admiral.source.v1.SourceAPI.DeleteSource
   */
  deleteSource: {
    methodKind: "unary";
    input: typeof DeleteSourceRequestSchema;
    output: typeof DeleteSourceResponseSchema;
  },
  /**
   * ListSourceVersions queries the external system for available versions of a
   * source (registry API, OCI tags, git ls-remote).
   *
   * Scope: `source:read`
   *
   * @generated from rpc admiral.source.v1.SourceAPI.ListSourceVersions
   */
  listSourceVersions: {
    methodKind: "unary";
    input: typeof ListSourceVersionsRequestSchema;
    output: typeof ListSourceVersionsResponseSchema;
  },
  /**
   * GetSourceInputs fetches the source artifact at a specific version and
   * parses its inputs (Terraform variables, Helm values.yaml + values.schema.json).
   *
   * Scope: `source:read`
   *
   * @generated from rpc admiral.source.v1.SourceAPI.GetSourceInputs
   */
  getSourceInputs: {
    methodKind: "unary";
    input: typeof GetSourceInputsRequestSchema;
    output: typeof GetSourceInputsResponseSchema;
  },
  /**
   * GetSourceOutputs parses output definitions from a source at a specific
   * version. Only applicable to Terraform sources — workload sources have no
   * formal outputs (user-declared at the component level).
   *
   * Scope: `source:read`
   *
   * @generated from rpc admiral.source.v1.SourceAPI.GetSourceOutputs
   */
  getSourceOutputs: {
    methodKind: "unary";
    input: typeof GetSourceOutputsRequestSchema;
    output: typeof GetSourceOutputsResponseSchema;
  },
  /**
   * SyncSource triggers a metadata refresh for a source.
   *
   * Scope: `source:write`
   *
   * @generated from rpc admiral.source.v1.SourceAPI.SyncSource
   */
  syncSource: {
    methodKind: "unary";
    input: typeof SyncSourceRequestSchema;
    output: typeof SyncSourceResponseSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_admiral_source_v1_source, 0);

