// @generated by protoc-gen-es v2.11.0 with parameter "target=ts"
// @generated from file admiral/api/state/v1/state.proto (package admiral.api.state.v1, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv2";
import { fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv2";
import { file_admiral_common_v1_annotations } from "../../../common/v1/annotations_pb";
import { file_buf_validate_validate } from "../../../../buf/validate/validate_pb";
import { file_google_api_annotations } from "../../../../google/api/annotations_pb";
import { file_gnostic_openapi_v3_annotations } from "../../../../gnostic/openapi/v3/annotations_pb";
import type { Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file admiral/api/state/v1/state.proto.
 */
export const file_admiral_api_state_v1_state: GenFile = /*@__PURE__*/
  fileDesc("CiBhZG1pcmFsL2FwaS9zdGF0ZS92MS9zdGF0ZS5wcm90bxIUYWRtaXJhbC5hcGkuc3RhdGUudjEiqgIKBVN0YXRlEhQKAmlkGAEgASgJQgi6SAVyA7ABARIeCgxjb21wb25lbnRfaWQYAiABKAlCCLpIBXIDsAEBEiAKDmVudmlyb25tZW50X2lkGAMgASgJQgi6SAVyA7ABARIOCgZzZXJpYWwYBCABKAMSDAoEZGF0YRgFIAEoDBILCgNtZDUYBiABKAkSDwoHbGluZWFnZRgHIAEoCRItCgRsb2NrGAggASgLMh8uYWRtaXJhbC5hcGkuc3RhdGUudjEuU3RhdGVMb2NrEi4KCmNyZWF0ZWRfYXQYCSABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEi4KCnVwZGF0ZWRfYXQYCiABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wIrcCCgxTdGF0ZVN1bW1hcnkSFAoCaWQYASABKAlCCLpIBXIDsAEBEh4KDGNvbXBvbmVudF9pZBgCIAEoCUIIukgFcgOwAQESIAoOZW52aXJvbm1lbnRfaWQYAyABKAlCCLpIBXIDsAEBEg4KBnNlcmlhbBgEIAEoAxILCgNtZDUYBSABKAkSDwoHbGluZWFnZRgGIAEoCRISCgpzaXplX2J5dGVzGAcgASgDEi0KBGxvY2sYCCABKAsyHy5hZG1pcmFsLmFwaS5zdGF0ZS52MS5TdGF0ZUxvY2sSLgoKY3JlYXRlZF9hdBgJIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASLgoKdXBkYXRlZF9hdBgKIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAiiAEKCVN0YXRlTG9jaxIZCgdsb2NrX2lkGAEgASgJQgi6SAVyA7ABARIRCglvcGVyYXRpb24YAiABKAkSCwoDd2hvGAMgASgJEg8KB3ZlcnNpb24YBCABKAkSLwoLYWNxdWlyZWRfYXQYBSABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wIqoBCgxTdGF0ZVZlcnNpb24SDgoGc2VyaWFsGAEgASgDEgsKA21kNRgCIAEoCRIPCgdsaW5lYWdlGAMgASgJEhIKCnNpemVfYnl0ZXMYBCABKAMSHQoGam9iX2lkGAUgASgJQgi6SAVyA7ABAUgAiAEBEi4KCmNyZWF0ZWRfYXQYBiABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wQgkKB19qb2JfaWQiKwoPR2V0U3RhdGVSZXF1ZXN0EhgKBmpvYl9pZBgBIAEoCUIIukgFcgOwAQEiIAoQR2V0U3RhdGVSZXNwb25zZRIMCgRkYXRhGAEgASgMIogBChBQdXNoU3RhdGVSZXF1ZXN0EhgKBmpvYl9pZBgBIAEoCUIIukgFcgOwAQESGgoEZGF0YRgCIAEoDEIMukgJegcQARiAgIAgEhQKA21kNRgDIAEoCUIHukgEcgIQARIOCgZzZXJpYWwYBCABKAMSGAoHbGluZWFnZRgFIAEoCUIHukgEcgIQASITChFQdXNoU3RhdGVSZXNwb25zZSJ4ChBMb2NrU3RhdGVSZXF1ZXN0EhgKBmpvYl9pZBgBIAEoCUIIukgFcgOwAQESGQoHbG9ja19pZBgCIAEoCUIIukgFcgOwAQESEQoJb3BlcmF0aW9uGAMgASgJEgsKA3dobxgEIAEoCRIPCgd2ZXJzaW9uGAUgASgJIhMKEUxvY2tTdGF0ZVJlc3BvbnNlIkkKElVubG9ja1N0YXRlUmVxdWVzdBIYCgZqb2JfaWQYASABKAlCCLpIBXIDsAEBEhkKB2xvY2tfaWQYAiABKAlCCLpIBXIDsAEBIhUKE1VubG9ja1N0YXRlUmVzcG9uc2UiNAoWR2V0Q3VycmVudFN0YXRlUmVxdWVzdBIaCghzdGF0ZV9pZBgBIAEoCUIIukgFcgOwAQEiRQoXR2V0Q3VycmVudFN0YXRlUmVzcG9uc2USKgoFc3RhdGUYASABKAsyGy5hZG1pcmFsLmFwaS5zdGF0ZS52MS5TdGF0ZSJfChFMaXN0U3RhdGVzUmVxdWVzdBIYCgZmaWx0ZXIYASABKAlCCLpIBXIDGIAIEhwKCXBhZ2Vfc2l6ZRgCIAEoBUIJukgGGgQYZCgAEhIKCnBhZ2VfdG9rZW4YAyABKAkiYQoSTGlzdFN0YXRlc1Jlc3BvbnNlEjIKBnN0YXRlcxgBIAMoCzIiLmFkbWlyYWwuYXBpLnN0YXRlLnYxLlN0YXRlU3VtbWFyeRIXCg9uZXh0X3BhZ2VfdG9rZW4YAiABKAkiaAoYTGlzdFN0YXRlVmVyc2lvbnNSZXF1ZXN0EhoKCHN0YXRlX2lkGAEgASgJQgi6SAVyA7ABARIcCglwYWdlX3NpemUYAiABKAVCCbpIBhoEGGQoABISCgpwYWdlX3Rva2VuGAMgASgJImoKGUxpc3RTdGF0ZVZlcnNpb25zUmVzcG9uc2USNAoIdmVyc2lvbnMYASADKAsyIi5hZG1pcmFsLmFwaS5zdGF0ZS52MS5TdGF0ZVZlcnNpb24SFwoPbmV4dF9wYWdlX3Rva2VuGAIgASgJIkQKFkdldFN0YXRlVmVyc2lvblJlcXVlc3QSGgoIc3RhdGVfaWQYASABKAlCCLpIBXIDsAEBEg4KBnNlcmlhbBgCIAEoAyJcChdHZXRTdGF0ZVZlcnNpb25SZXNwb25zZRIzCgd2ZXJzaW9uGAEgASgLMiIuYWRtaXJhbC5hcGkuc3RhdGUudjEuU3RhdGVWZXJzaW9uEgwKBGRhdGEYAiABKAwiTwoXRm9yY2VVbmxvY2tTdGF0ZVJlcXVlc3QSGgoIc3RhdGVfaWQYASABKAlCCLpIBXIDsAEBEhgKBnJlYXNvbhgCIAEoCUIIukgFcgMYgAgiGgoYRm9yY2VVbmxvY2tTdGF0ZVJlc3BvbnNlIjAKEkRlbGV0ZVN0YXRlUmVxdWVzdBIaCghzdGF0ZV9pZBgBIAEoCUIIukgFcgOwAQEiFQoTRGVsZXRlU3RhdGVSZXNwb25zZTKhDwoIU3RhdGVBUEkSugEKCEdldFN0YXRlEiUuYWRtaXJhbC5hcGkuc3RhdGUudjEuR2V0U3RhdGVSZXF1ZXN0GiYuYWRtaXJhbC5hcGkuc3RhdGUudjEuR2V0U3RhdGVSZXNwb25zZSJfukchCgVTdGF0ZRIYUmV0cmlldmUgc3RhdGUgZm9yIGEgam9iopckEQoKc3RhdGU6cmVhZBIDYWd0gtPkkwIgEh4vdjEvcnVubmVyL2pvYnMve2pvYl9pZH0vc3RhdGUSvQEKCVB1c2hTdGF0ZRImLmFkbWlyYWwuYXBpLnN0YXRlLnYxLlB1c2hTdGF0ZVJlcXVlc3QaJy5hZG1pcmFsLmFwaS5zdGF0ZS52MS5QdXNoU3RhdGVSZXNwb25zZSJfukcdCgVTdGF0ZRIUUHVzaCBzdGF0ZSBmb3IgYSBqb2KilyQSCgtzdGF0ZTp3cml0ZRIDYWd0gtPkkwIjOgEqIh4vdjEvcnVubmVyL2pvYnMve2pvYl9pZH0vc3RhdGUSwgEKCUxvY2tTdGF0ZRImLmFkbWlyYWwuYXBpLnN0YXRlLnYxLkxvY2tTdGF0ZVJlcXVlc3QaJy5hZG1pcmFsLmFwaS5zdGF0ZS52MS5Mb2NrU3RhdGVSZXNwb25zZSJkukcdCgVTdGF0ZRIUTG9jayBzdGF0ZSBmb3IgYSBqb2KilyQSCgtzdGF0ZTp3cml0ZRIDYWd0gtPkkwIoOgEqIiMvdjEvcnVubmVyL2pvYnMve2pvYl9pZH0vc3RhdGUvbG9jaxLMAQoLVW5sb2NrU3RhdGUSKC5hZG1pcmFsLmFwaS5zdGF0ZS52MS5VbmxvY2tTdGF0ZVJlcXVlc3QaKS5hZG1pcmFsLmFwaS5zdGF0ZS52MS5VbmxvY2tTdGF0ZVJlc3BvbnNlImi6Rx8KBVN0YXRlEhZVbmxvY2sgc3RhdGUgZm9yIGEgam9iopckEgoLc3RhdGU6d3JpdGUSA2FndILT5JMCKjoBKiIlL3YxL3J1bm5lci9qb2JzL3tqb2JfaWR9L3N0YXRlL3VubG9jaxK/AQoPR2V0Q3VycmVudFN0YXRlEiwuYWRtaXJhbC5hcGkuc3RhdGUudjEuR2V0Q3VycmVudFN0YXRlUmVxdWVzdBotLmFkbWlyYWwuYXBpLnN0YXRlLnYxLkdldEN1cnJlbnRTdGF0ZVJlc3BvbnNlIk+6Rx8KBVN0YXRlEhZSZXRyaWV2ZSBjdXJyZW50IHN0YXRlopckDAoKc3RhdGU6cmVhZILT5JMCFxIVL3YxL3N0YXRlcy97c3RhdGVfaWR9EpoBCgpMaXN0U3RhdGVzEicuYWRtaXJhbC5hcGkuc3RhdGUudjEuTGlzdFN0YXRlc1JlcXVlc3QaKC5hZG1pcmFsLmFwaS5zdGF0ZS52MS5MaXN0U3RhdGVzUmVzcG9uc2UiObpHFAoFU3RhdGUSC0xpc3Qgc3RhdGVzopckDAoKc3RhdGU6cmVhZILT5JMCDBIKL3YxL3N0YXRlcxLLAQoRTGlzdFN0YXRlVmVyc2lvbnMSLi5hZG1pcmFsLmFwaS5zdGF0ZS52MS5MaXN0U3RhdGVWZXJzaW9uc1JlcXVlc3QaLy5hZG1pcmFsLmFwaS5zdGF0ZS52MS5MaXN0U3RhdGVWZXJzaW9uc1Jlc3BvbnNlIlW6RxwKBVN0YXRlEhNMaXN0IHN0YXRlIHZlcnNpb25zopckDAoKc3RhdGU6cmVhZILT5JMCIBIeL3YxL3N0YXRlcy97c3RhdGVfaWR9L3ZlcnNpb25zEtMBCg9HZXRTdGF0ZVZlcnNpb24SLC5hZG1pcmFsLmFwaS5zdGF0ZS52MS5HZXRTdGF0ZVZlcnNpb25SZXF1ZXN0Gi0uYWRtaXJhbC5hcGkuc3RhdGUudjEuR2V0U3RhdGVWZXJzaW9uUmVzcG9uc2UiY7pHIQoFU3RhdGUSGFJldHJpZXZlIGEgc3RhdGUgdmVyc2lvbqKXJAwKCnN0YXRlOnJlYWSC0+STAikSJy92MS9zdGF0ZXMve3N0YXRlX2lkfS92ZXJzaW9ucy97c2VyaWFsfRLRAQoQRm9yY2VVbmxvY2tTdGF0ZRItLmFkbWlyYWwuYXBpLnN0YXRlLnYxLkZvcmNlVW5sb2NrU3RhdGVSZXF1ZXN0Gi4uYWRtaXJhbC5hcGkuc3RhdGUudjEuRm9yY2VVbmxvY2tTdGF0ZVJlc3BvbnNlIl66Rx0KBVN0YXRlEhRGb3JjZSB1bmxvY2sgYSBzdGF0ZaKXJA0KC3N0YXRlOmFkbWlugtPkkwInOgEqIiIvdjEvc3RhdGVzL3tzdGF0ZV9pZH0vZm9yY2UtdW5sb2NrEqwBCgtEZWxldGVTdGF0ZRIoLmFkbWlyYWwuYXBpLnN0YXRlLnYxLkRlbGV0ZVN0YXRlUmVxdWVzdBopLmFkbWlyYWwuYXBpLnN0YXRlLnYxLkRlbGV0ZVN0YXRlUmVzcG9uc2UiSLpHFwoFU3RhdGUSDkRlbGV0ZSBhIHN0YXRlopckDQoLc3RhdGU6YWRtaW6C0+STAhcqFS92MS9zdGF0ZXMve3N0YXRlX2lkfULPAQoYY29tLmFkbWlyYWwuYXBpLnN0YXRlLnYxQgpTdGF0ZVByb3RvUAFaNGdvLmFkbWlyYWwuaW8vc2RrL3Byb3RvL2FkbWlyYWwvYXBpL3N0YXRlL3YxO3N0YXRldjGiAgNBQVOqAhRBZG1pcmFsLkFwaS5TdGF0ZS5WMcoCFEFkbWlyYWxcQXBpXFN0YXRlXFYx4gIgQWRtaXJhbFxBcGlcU3RhdGVcVjFcR1BCTWV0YWRhdGHqAhdBZG1pcmFsOjpBcGk6OlN0YXRlOjpWMWIGcHJvdG8z", [file_admiral_common_v1_annotations, file_buf_validate_validate, file_google_api_annotations, file_gnostic_openapi_v3_annotations, file_google_protobuf_timestamp]);

/**
 * State represents the full Terraform state for an infrastructure component
 * in a specific environment, including the raw state data blob. Each
 * component + environment combination has at most one state record. The
 * server creates the record on first PushState.
 *
 * This message is returned by GetCurrentState. For list operations, see
 * StateSummary which omits the data blob.
 *
 * @generated from message admiral.api.state.v1.State
 */
export type State = Message<"admiral.api.state.v1.State"> & {
  /**
   * Unique identifier for the state record (UUID, server-generated).
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * The infrastructure component this state belongs to (UUID).
   *
   * @generated from field: string component_id = 2;
   */
  componentId: string;

  /**
   * The environment this state is scoped to (UUID).
   *
   * @generated from field: string environment_id = 3;
   */
  environmentId: string;

  /**
   * Terraform state serial number. Monotonically increasing with each
   * successful apply. Used for optimistic concurrency control.
   *
   * @generated from field: int64 serial = 4;
   */
  serial: bigint;

  /**
   * The raw Terraform state data (JSON-encoded). This is the opaque
   * `.tfstate` blob managed by Terraform. Can be several megabytes for
   * large workspaces.
   *
   * @generated from field: bytes data = 5;
   */
  data: Uint8Array;

  /**
   * MD5 hash of the state data. Used by Terraform for integrity checks
   * and conditional updates.
   *
   * @generated from field: string md5 = 6;
   */
  md5: string;

  /**
   * Terraform state lineage -- a UUID generated on first init. All
   * subsequent writes must match this lineage to prevent cross-state
   * contamination.
   *
   * @generated from field: string lineage = 7;
   */
  lineage: string;

  /**
   * Active lock on this state, if any. Absent when the state is unlocked.
   *
   * @generated from field: admiral.api.state.v1.StateLock lock = 8;
   */
  lock?: StateLock;

  /**
   * When the state record was first created.
   *
   * @generated from field: google.protobuf.Timestamp created_at = 9;
   */
  createdAt?: Timestamp;

  /**
   * When the state data was last updated (last successful PushState).
   *
   * @generated from field: google.protobuf.Timestamp updated_at = 10;
   */
  updatedAt?: Timestamp;
};

/**
 * Describes the message admiral.api.state.v1.State.
 * Use `create(StateSchema)` to create a new message.
 */
export const StateSchema: GenMessage<State> = /*@__PURE__*/
  messageDesc(file_admiral_api_state_v1_state, 0);

/**
 * StateSummary contains state metadata without the raw data blob. Used in
 * ListStates to keep list responses lightweight. Use GetCurrentState to
 * fetch the full state data for a specific record.
 *
 * @generated from message admiral.api.state.v1.StateSummary
 */
export type StateSummary = Message<"admiral.api.state.v1.StateSummary"> & {
  /**
   * Unique identifier for the state record (UUID).
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * The infrastructure component this state belongs to (UUID).
   *
   * @generated from field: string component_id = 2;
   */
  componentId: string;

  /**
   * The environment this state is scoped to (UUID).
   *
   * @generated from field: string environment_id = 3;
   */
  environmentId: string;

  /**
   * Terraform state serial number.
   *
   * @generated from field: int64 serial = 4;
   */
  serial: bigint;

  /**
   * MD5 hash of the current state data.
   *
   * @generated from field: string md5 = 5;
   */
  md5: string;

  /**
   * Terraform state lineage.
   *
   * @generated from field: string lineage = 6;
   */
  lineage: string;

  /**
   * Size of the current state data in bytes.
   *
   * @generated from field: int64 size_bytes = 7;
   */
  sizeBytes: bigint;

  /**
   * Active lock on this state, if any. Absent when the state is unlocked.
   *
   * @generated from field: admiral.api.state.v1.StateLock lock = 8;
   */
  lock?: StateLock;

  /**
   * When the state record was first created.
   *
   * @generated from field: google.protobuf.Timestamp created_at = 9;
   */
  createdAt?: Timestamp;

  /**
   * When the state data was last updated (last successful PushState).
   *
   * @generated from field: google.protobuf.Timestamp updated_at = 10;
   */
  updatedAt?: Timestamp;
};

/**
 * Describes the message admiral.api.state.v1.StateSummary.
 * Use `create(StateSummarySchema)` to create a new message.
 */
export const StateSummarySchema: GenMessage<StateSummary> = /*@__PURE__*/
  messageDesc(file_admiral_api_state_v1_state, 1);

/**
 * StateLock represents an exclusive lock on a state record. Terraform acquires
 * locks before plan/apply to prevent concurrent modifications. The lock_id is
 * generated by Terraform (as a UUID) and included in all lock/unlock requests.
 *
 * @generated from message admiral.api.state.v1.StateLock
 */
export type StateLock = Message<"admiral.api.state.v1.StateLock"> & {
  /**
   * Unique identifier for the lock (UUID, generated by Terraform/OpenTofu).
   *
   * @generated from field: string lock_id = 1;
   */
  lockId: string;

  /**
   * The Terraform operation holding the lock. Common values:
   *   - "OperationTypePlan"
   *   - "OperationTypeApply"
   * This value is set by the Terraform client and is informational only.
   *
   * @generated from field: string operation = 2;
   */
  operation: string;

  /**
   * Identifier of who holds the lock. Populated by Terraform -- typically
   * the format "username@hostname" (e.g., "deploy@prod-runner-01").
   * This field is informational only; its format is controlled by Terraform.
   *
   * @generated from field: string who = 3;
   */
  who: string;

  /**
   * Terraform/OpenTofu version string of the client holding the lock
   * (e.g., "1.7.5").
   *
   * @generated from field: string version = 4;
   */
  version: string;

  /**
   * When the lock was acquired.
   *
   * @generated from field: google.protobuf.Timestamp acquired_at = 5;
   */
  acquiredAt?: Timestamp;
};

/**
 * Describes the message admiral.api.state.v1.StateLock.
 * Use `create(StateLockSchema)` to create a new message.
 */
export const StateLockSchema: GenMessage<StateLock> = /*@__PURE__*/
  messageDesc(file_admiral_api_state_v1_state, 2);

/**
 * StateVersion contains metadata about a historical state version. Used in
 * ListStateVersions to provide version history without the full state data
 * blob.
 *
 * @generated from message admiral.api.state.v1.StateVersion
 */
export type StateVersion = Message<"admiral.api.state.v1.StateVersion"> & {
  /**
   * Terraform state serial number for this version.
   *
   * @generated from field: int64 serial = 1;
   */
  serial: bigint;

  /**
   * MD5 hash of the state data at this version.
   *
   * @generated from field: string md5 = 2;
   */
  md5: string;

  /**
   * Terraform state lineage.
   *
   * @generated from field: string lineage = 3;
   */
  lineage: string;

  /**
   * Size of the state data in bytes.
   *
   * @generated from field: int64 size_bytes = 4;
   */
  sizeBytes: bigint;

  /**
   * The job that produced this state version (UUID). Absent for state that
   * was written outside the normal job lifecycle -- for example, state
   * uploaded directly via an admin migration tool, or state that existed
   * before Admiral began managing the component.
   *
   * @generated from field: optional string job_id = 5;
   */
  jobId?: string;

  /**
   * When this state version was created.
   *
   * @generated from field: google.protobuf.Timestamp created_at = 6;
   */
  createdAt?: Timestamp;
};

/**
 * Describes the message admiral.api.state.v1.StateVersion.
 * Use `create(StateVersionSchema)` to create a new message.
 */
export const StateVersionSchema: GenMessage<StateVersion> = /*@__PURE__*/
  messageDesc(file_admiral_api_state_v1_state, 3);

/**
 * GetStateRequest fetches the current state for a job.
 *
 * @generated from message admiral.api.state.v1.GetStateRequest
 */
export type GetStateRequest = Message<"admiral.api.state.v1.GetStateRequest"> & {
  /**
   * The job to fetch state for (UUID). The server resolves the component
   * and environment from the job's binding.
   *
   * @generated from field: string job_id = 1;
   */
  jobId: string;
};

/**
 * Describes the message admiral.api.state.v1.GetStateRequest.
 * Use `create(GetStateRequestSchema)` to create a new message.
 */
export const GetStateRequestSchema: GenMessage<GetStateRequest> = /*@__PURE__*/
  messageDesc(file_admiral_api_state_v1_state, 4);

/**
 * GetStateResponse contains the current state data.
 *
 * @generated from message admiral.api.state.v1.GetStateResponse
 */
export type GetStateResponse = Message<"admiral.api.state.v1.GetStateResponse"> & {
  /**
   * The raw Terraform state data (JSON-encoded). Empty if no state exists
   * yet (fresh init -- Terraform handles this gracefully).
   *
   * @generated from field: bytes data = 1;
   */
  data: Uint8Array;
};

/**
 * Describes the message admiral.api.state.v1.GetStateResponse.
 * Use `create(GetStateResponseSchema)` to create a new message.
 */
export const GetStateResponseSchema: GenMessage<GetStateResponse> = /*@__PURE__*/
  messageDesc(file_admiral_api_state_v1_state, 5);

/**
 * PushStateRequest stores a new state version.
 *
 * @generated from message admiral.api.state.v1.PushStateRequest
 */
export type PushStateRequest = Message<"admiral.api.state.v1.PushStateRequest"> & {
  /**
   * The job pushing state (UUID).
   *
   * @generated from field: string job_id = 1;
   */
  jobId: string;

  /**
   * The raw Terraform state data (JSON-encoded). Maximum 64 MiB.
   *
   * @generated from field: bytes data = 2;
   */
  data: Uint8Array;

  /**
   * MD5 hash of the state data.
   *
   * @generated from field: string md5 = 3;
   */
  md5: string;

  /**
   * Terraform state serial number. Must be greater than the current serial.
   *
   * @generated from field: int64 serial = 4;
   */
  serial: bigint;

  /**
   * Terraform state lineage. Must match the existing lineage if the state
   * record already exists.
   *
   * @generated from field: string lineage = 5;
   */
  lineage: string;
};

/**
 * Describes the message admiral.api.state.v1.PushStateRequest.
 * Use `create(PushStateRequestSchema)` to create a new message.
 */
export const PushStateRequestSchema: GenMessage<PushStateRequest> = /*@__PURE__*/
  messageDesc(file_admiral_api_state_v1_state, 6);

/**
 * PushStateResponse acknowledges the state was stored.
 *
 * @generated from message admiral.api.state.v1.PushStateResponse
 */
export type PushStateResponse = Message<"admiral.api.state.v1.PushStateResponse"> & {
};

/**
 * Describes the message admiral.api.state.v1.PushStateResponse.
 * Use `create(PushStateResponseSchema)` to create a new message.
 */
export const PushStateResponseSchema: GenMessage<PushStateResponse> = /*@__PURE__*/
  messageDesc(file_admiral_api_state_v1_state, 7);

/**
 * LockStateRequest acquires an exclusive lock on the job's state.
 *
 * @generated from message admiral.api.state.v1.LockStateRequest
 */
export type LockStateRequest = Message<"admiral.api.state.v1.LockStateRequest"> & {
  /**
   * The job requesting the lock (UUID).
   *
   * @generated from field: string job_id = 1;
   */
  jobId: string;

  /**
   * Terraform-generated lock ID (UUID).
   *
   * @generated from field: string lock_id = 2;
   */
  lockId: string;

  /**
   * The Terraform operation requesting the lock.
   *
   * @generated from field: string operation = 3;
   */
  operation: string;

  /**
   * Identifier of who is requesting the lock.
   *
   * @generated from field: string who = 4;
   */
  who: string;

  /**
   * Terraform/OpenTofu version of the client requesting the lock.
   *
   * @generated from field: string version = 5;
   */
  version: string;
};

/**
 * Describes the message admiral.api.state.v1.LockStateRequest.
 * Use `create(LockStateRequestSchema)` to create a new message.
 */
export const LockStateRequestSchema: GenMessage<LockStateRequest> = /*@__PURE__*/
  messageDesc(file_admiral_api_state_v1_state, 8);

/**
 * LockStateResponse confirms the lock was acquired.
 *
 * @generated from message admiral.api.state.v1.LockStateResponse
 */
export type LockStateResponse = Message<"admiral.api.state.v1.LockStateResponse"> & {
};

/**
 * Describes the message admiral.api.state.v1.LockStateResponse.
 * Use `create(LockStateResponseSchema)` to create a new message.
 */
export const LockStateResponseSchema: GenMessage<LockStateResponse> = /*@__PURE__*/
  messageDesc(file_admiral_api_state_v1_state, 9);

/**
 * UnlockStateRequest releases the lock on the job's state.
 *
 * @generated from message admiral.api.state.v1.UnlockStateRequest
 */
export type UnlockStateRequest = Message<"admiral.api.state.v1.UnlockStateRequest"> & {
  /**
   * The job releasing the lock (UUID).
   *
   * @generated from field: string job_id = 1;
   */
  jobId: string;

  /**
   * The lock_id to release (UUID). Must match the currently held lock.
   *
   * @generated from field: string lock_id = 2;
   */
  lockId: string;
};

/**
 * Describes the message admiral.api.state.v1.UnlockStateRequest.
 * Use `create(UnlockStateRequestSchema)` to create a new message.
 */
export const UnlockStateRequestSchema: GenMessage<UnlockStateRequest> = /*@__PURE__*/
  messageDesc(file_admiral_api_state_v1_state, 10);

/**
 * UnlockStateResponse confirms the lock was released.
 *
 * @generated from message admiral.api.state.v1.UnlockStateResponse
 */
export type UnlockStateResponse = Message<"admiral.api.state.v1.UnlockStateResponse"> & {
};

/**
 * Describes the message admiral.api.state.v1.UnlockStateResponse.
 * Use `create(UnlockStateResponseSchema)` to create a new message.
 */
export const UnlockStateResponseSchema: GenMessage<UnlockStateResponse> = /*@__PURE__*/
  messageDesc(file_admiral_api_state_v1_state, 11);

/**
 * GetCurrentStateRequest identifies a state record to retrieve.
 *
 * @generated from message admiral.api.state.v1.GetCurrentStateRequest
 */
export type GetCurrentStateRequest = Message<"admiral.api.state.v1.GetCurrentStateRequest"> & {
  /**
   * The unique identifier of the state record (UUID).
   *
   * @generated from field: string state_id = 1;
   */
  stateId: string;
};

/**
 * Describes the message admiral.api.state.v1.GetCurrentStateRequest.
 * Use `create(GetCurrentStateRequestSchema)` to create a new message.
 */
export const GetCurrentStateRequestSchema: GenMessage<GetCurrentStateRequest> = /*@__PURE__*/
  messageDesc(file_admiral_api_state_v1_state, 12);

/**
 * GetCurrentStateResponse contains the state record with current data and
 * lock info.
 *
 * @generated from message admiral.api.state.v1.GetCurrentStateResponse
 */
export type GetCurrentStateResponse = Message<"admiral.api.state.v1.GetCurrentStateResponse"> & {
  /**
   * The state record including current data and any active lock.
   *
   * @generated from field: admiral.api.state.v1.State state = 1;
   */
  state?: State;
};

/**
 * Describes the message admiral.api.state.v1.GetCurrentStateResponse.
 * Use `create(GetCurrentStateResponseSchema)` to create a new message.
 */
export const GetCurrentStateResponseSchema: GenMessage<GetCurrentStateResponse> = /*@__PURE__*/
  messageDesc(file_admiral_api_state_v1_state, 13);

/**
 * ListStatesRequest contains pagination and filter parameters.
 *
 * @generated from message admiral.api.state.v1.ListStatesRequest
 */
export type ListStatesRequest = Message<"admiral.api.state.v1.ListStatesRequest"> & {
  /**
   * Filter expression using the PEG filter DSL.
   *
   * Common filter fields:
   *   - `component_id` -- states for a specific component (UUID).
   *   - `environment_id` -- states for a specific environment (UUID).
   *   - `application_id` -- states for all components belonging to an
   *     application (UUID). The server resolves the application's components
   *     and returns states for all of them. Can be combined with
   *     `environment_id`.
   *
   * @generated from field: string filter = 1;
   */
  filter: string;

  /**
   * Maximum number of states to return per page.
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize: number;

  /**
   * Opaque pagination token from a previous response.
   *
   * @generated from field: string page_token = 3;
   */
  pageToken: string;
};

/**
 * Describes the message admiral.api.state.v1.ListStatesRequest.
 * Use `create(ListStatesRequestSchema)` to create a new message.
 */
export const ListStatesRequestSchema: GenMessage<ListStatesRequest> = /*@__PURE__*/
  messageDesc(file_admiral_api_state_v1_state, 14);

/**
 * ListStatesResponse contains a page of state metadata.
 *
 * @generated from message admiral.api.state.v1.ListStatesResponse
 */
export type ListStatesResponse = Message<"admiral.api.state.v1.ListStatesResponse"> & {
  /**
   * The list of state summaries (metadata only, no state data blob).
   * Use GetCurrentState to fetch full data for a specific record.
   *
   * @generated from field: repeated admiral.api.state.v1.StateSummary states = 1;
   */
  states: StateSummary[];

  /**
   * Pagination token for the next page. Empty when there are no more results.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;
};

/**
 * Describes the message admiral.api.state.v1.ListStatesResponse.
 * Use `create(ListStatesResponseSchema)` to create a new message.
 */
export const ListStatesResponseSchema: GenMessage<ListStatesResponse> = /*@__PURE__*/
  messageDesc(file_admiral_api_state_v1_state, 15);

/**
 * ListStateVersionsRequest contains pagination parameters for version history.
 *
 * @generated from message admiral.api.state.v1.ListStateVersionsRequest
 */
export type ListStateVersionsRequest = Message<"admiral.api.state.v1.ListStateVersionsRequest"> & {
  /**
   * The state record to list versions for (UUID).
   *
   * @generated from field: string state_id = 1;
   */
  stateId: string;

  /**
   * Maximum number of versions to return per page.
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize: number;

  /**
   * Opaque pagination token from a previous response.
   *
   * @generated from field: string page_token = 3;
   */
  pageToken: string;
};

/**
 * Describes the message admiral.api.state.v1.ListStateVersionsRequest.
 * Use `create(ListStateVersionsRequestSchema)` to create a new message.
 */
export const ListStateVersionsRequestSchema: GenMessage<ListStateVersionsRequest> = /*@__PURE__*/
  messageDesc(file_admiral_api_state_v1_state, 16);

/**
 * ListStateVersionsResponse contains a page of state version metadata.
 *
 * @generated from message admiral.api.state.v1.ListStateVersionsResponse
 */
export type ListStateVersionsResponse = Message<"admiral.api.state.v1.ListStateVersionsResponse"> & {
  /**
   * The list of state versions, ordered from newest to oldest.
   *
   * @generated from field: repeated admiral.api.state.v1.StateVersion versions = 1;
   */
  versions: StateVersion[];

  /**
   * Pagination token for the next page. Empty when there are no more results.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;
};

/**
 * Describes the message admiral.api.state.v1.ListStateVersionsResponse.
 * Use `create(ListStateVersionsResponseSchema)` to create a new message.
 */
export const ListStateVersionsResponseSchema: GenMessage<ListStateVersionsResponse> = /*@__PURE__*/
  messageDesc(file_admiral_api_state_v1_state, 17);

/**
 * GetStateVersionRequest identifies a specific historical state version.
 *
 * @generated from message admiral.api.state.v1.GetStateVersionRequest
 */
export type GetStateVersionRequest = Message<"admiral.api.state.v1.GetStateVersionRequest"> & {
  /**
   * The state record (UUID).
   *
   * @generated from field: string state_id = 1;
   */
  stateId: string;

  /**
   * The serial number of the version to retrieve.
   *
   * @generated from field: int64 serial = 2;
   */
  serial: bigint;
};

/**
 * Describes the message admiral.api.state.v1.GetStateVersionRequest.
 * Use `create(GetStateVersionRequestSchema)` to create a new message.
 */
export const GetStateVersionRequestSchema: GenMessage<GetStateVersionRequest> = /*@__PURE__*/
  messageDesc(file_admiral_api_state_v1_state, 18);

/**
 * GetStateVersionResponse contains the full state data at a historical serial.
 * Returns both the version metadata and the raw data separately -- the
 * StateVersion message intentionally omits data to keep ListStateVersions
 * lightweight.
 *
 * @generated from message admiral.api.state.v1.GetStateVersionResponse
 */
export type GetStateVersionResponse = Message<"admiral.api.state.v1.GetStateVersionResponse"> & {
  /**
   * The state version metadata.
   *
   * @generated from field: admiral.api.state.v1.StateVersion version = 1;
   */
  version?: StateVersion;

  /**
   * The raw Terraform state data (JSON-encoded) at this serial.
   *
   * @generated from field: bytes data = 2;
   */
  data: Uint8Array;
};

/**
 * Describes the message admiral.api.state.v1.GetStateVersionResponse.
 * Use `create(GetStateVersionResponseSchema)` to create a new message.
 */
export const GetStateVersionResponseSchema: GenMessage<GetStateVersionResponse> = /*@__PURE__*/
  messageDesc(file_admiral_api_state_v1_state, 19);

/**
 * ForceUnlockStateRequest identifies a state to force-unlock.
 *
 * @generated from message admiral.api.state.v1.ForceUnlockStateRequest
 */
export type ForceUnlockStateRequest = Message<"admiral.api.state.v1.ForceUnlockStateRequest"> & {
  /**
   * The state record to force-unlock (UUID).
   *
   * @generated from field: string state_id = 1;
   */
  stateId: string;

  /**
   * Reason for force-unlocking (audited). Recommended to provide context
   * for why the lock is being broken (e.g., "runner crashed during apply").
   *
   * @generated from field: string reason = 2;
   */
  reason: string;
};

/**
 * Describes the message admiral.api.state.v1.ForceUnlockStateRequest.
 * Use `create(ForceUnlockStateRequestSchema)` to create a new message.
 */
export const ForceUnlockStateRequestSchema: GenMessage<ForceUnlockStateRequest> = /*@__PURE__*/
  messageDesc(file_admiral_api_state_v1_state, 20);

/**
 * ForceUnlockStateResponse confirms the lock was forcefully released.
 *
 * @generated from message admiral.api.state.v1.ForceUnlockStateResponse
 */
export type ForceUnlockStateResponse = Message<"admiral.api.state.v1.ForceUnlockStateResponse"> & {
};

/**
 * Describes the message admiral.api.state.v1.ForceUnlockStateResponse.
 * Use `create(ForceUnlockStateResponseSchema)` to create a new message.
 */
export const ForceUnlockStateResponseSchema: GenMessage<ForceUnlockStateResponse> = /*@__PURE__*/
  messageDesc(file_admiral_api_state_v1_state, 21);

/**
 * DeleteStateRequest identifies a state record to permanently delete.
 *
 * @generated from message admiral.api.state.v1.DeleteStateRequest
 */
export type DeleteStateRequest = Message<"admiral.api.state.v1.DeleteStateRequest"> & {
  /**
   * The unique identifier of the state record to delete (UUID).
   * Fails if the state is currently locked -- force-unlock first.
   *
   * @generated from field: string state_id = 1;
   */
  stateId: string;
};

/**
 * Describes the message admiral.api.state.v1.DeleteStateRequest.
 * Use `create(DeleteStateRequestSchema)` to create a new message.
 */
export const DeleteStateRequestSchema: GenMessage<DeleteStateRequest> = /*@__PURE__*/
  messageDesc(file_admiral_api_state_v1_state, 22);

/**
 * DeleteStateResponse is empty on success.
 *
 * @generated from message admiral.api.state.v1.DeleteStateResponse
 */
export type DeleteStateResponse = Message<"admiral.api.state.v1.DeleteStateResponse"> & {
};

/**
 * Describes the message admiral.api.state.v1.DeleteStateResponse.
 * Use `create(DeleteStateResponseSchema)` to create a new message.
 */
export const DeleteStateResponseSchema: GenMessage<DeleteStateResponse> = /*@__PURE__*/
  messageDesc(file_admiral_api_state_v1_state, 23);

/**
 * StateAPI manages Terraform state for infrastructure components within a
 * tenant.
 *
 * State is scoped to **component + environment** -- each infrastructure
 * component (e.g., "rds", "vpc") has exactly one state record per
 * environment (e.g., dev, staging, prod). This state persists for the
 * entire lifetime of that component in that environment, spanning many
 * deployments and jobs. Locks protect the state record itself, not any
 * individual job -- if a job crashes while holding a lock, the lock remains
 * on the state until released or force-unlocked.
 *
 * Admiral acts as the state backend for all Terraform-backed components.
 * You do not need to configure a separate backend (S3, GCS, etc.) --
 * Admiral stores and versions state automatically.
 *
 * Most callers only need the admin-facing RPCs: GetCurrentState, ListStates,
 * ListStateVersions, GetStateVersion, ForceUnlockState, and DeleteState.
 * These provide full visibility into and control over state without needing
 * to understand the Terraform HTTP backend protocol.
 *
 * Runner-facing RPCs (GetState, PushState, LockState, UnlockState) are
 * called by Admiral's runner binary during job execution. These endpoints
 * use job_id as an access path -- the server resolves the job's component
 * and environment to locate the underlying state record. The runner
 * configures Terraform's HTTP backend with per-job state URLs and injects
 * its AGT as a bearer token. These endpoints are not intended for direct
 * use by external developers.
 *
 * Execution flow:
 *   ClaimJob → GetJobBundle → LockState → GetState → terraform apply →
 *   PushState → UnlockState → ReportJobResult
 *
 * Admin routes use /v1/states/... (plural, with state_id).
 * Runner-facing routes use /v1/runner/jobs/{job_id}/state (job-scoped --
 * the server resolves the component and environment from the job).
 *
 * All operations delegate to the platform StateAPI. The facade resolves the
 * caller's identity and calls ResolveJobState for runner-facing RPCs to map
 * job_id → state_id before forwarding state operations.
 *
 * ---------------------------------------------------------------------------
 * Runner-facing (AGT-only)
 * ---------------------------------------------------------------------------
 *
 * @generated from service admiral.api.state.v1.StateAPI
 */
export const StateAPI: GenService<{
  /**
   * GetState fetches the current state for a job's component + environment.
   * Returns empty data if no state exists yet (fresh init -- Terraform
   * handles this gracefully).
   *
   * The server validates that the AGT's runner binding matches the runner
   * assigned to this job. Returns PERMISSION_DENIED if they do not match.
   * Returns NOT_FOUND if the job does not exist or has been cancelled.
   *
   * Maps to Terraform HTTP backend GET on the state address.
   *
   * Scope: `state:read` | Token types: `agt`
   *
   * @generated from rpc admiral.api.state.v1.StateAPI.GetState
   */
  getState: {
    methodKind: "unary";
    input: typeof GetStateRequestSchema;
    output: typeof GetStateResponseSchema;
  },
  /**
   * PushState stores a new state version after a successful apply. The server
   * validates the serial number (must be greater than current) and lineage
   * (must match if state already exists). Creates the state record on first
   * push.
   *
   * The server validates that the AGT's runner binding matches the runner
   * assigned to this job. Returns PERMISSION_DENIED if they do not match.
   * Returns FAILED_PRECONDITION if the serial is not greater than the current
   * serial. Returns INVALID_ARGUMENT if the lineage does not match the
   * existing state record.
   *
   * Maps to Terraform HTTP backend POST on the state address.
   *
   * Scope: `state:write` | Token types: `agt`
   *
   * @generated from rpc admiral.api.state.v1.StateAPI.PushState
   */
  pushState: {
    methodKind: "unary";
    input: typeof PushStateRequestSchema;
    output: typeof PushStateResponseSchema;
  },
  /**
   * LockState acquires an exclusive lock for the job's state. Terraform calls
   * this before plan/apply to prevent concurrent modifications.
   *
   * The server validates that the AGT's runner binding matches the runner
   * assigned to this job. Returns PERMISSION_DENIED if they do not match.
   * Returns FAILED_PRECONDITION if the state is already locked by a different
   * operation. The lock_id is generated by Terraform and must be passed to
   * UnlockState.
   *
   * Maps to Terraform HTTP backend POST on the lock address.
   *
   * Scope: `state:write` | Token types: `agt`
   *
   * @generated from rpc admiral.api.state.v1.StateAPI.LockState
   */
  lockState: {
    methodKind: "unary";
    input: typeof LockStateRequestSchema;
    output: typeof LockStateResponseSchema;
  },
  /**
   * UnlockState releases the exclusive lock on the job's state. The lock_id
   * must match the one used during LockState.
   *
   * The server validates that the AGT's runner binding matches the runner
   * assigned to this job. Returns PERMISSION_DENIED if they do not match.
   * Returns FAILED_PRECONDITION if the lock_id does not match the currently
   * held lock. Returns NOT_FOUND if no lock is held.
   *
   * Maps to Terraform HTTP backend POST on the unlock address.
   *
   * Scope: `state:write` | Token types: `agt`
   *
   * @generated from rpc admiral.api.state.v1.StateAPI.UnlockState
   */
  unlockState: {
    methodKind: "unary";
    input: typeof UnlockStateRequestSchema;
    output: typeof UnlockStateResponseSchema;
  },
  /**
   * GetCurrentState retrieves the current state and lock info for a state
   * record. Returns the latest state data, serial, lineage, and any active
   * lock.
   *
   * Returns NOT_FOUND if the state record does not exist.
   *
   * Scope: `state:read`
   *
   * @generated from rpc admiral.api.state.v1.StateAPI.GetCurrentState
   */
  getCurrentState: {
    methodKind: "unary";
    input: typeof GetCurrentStateRequestSchema;
    output: typeof GetCurrentStateResponseSchema;
  },
  /**
   * ListStates returns a paginated list of state records within the caller's
   * tenant. Use filters to scope by component, environment, or application.
   * Returns metadata only -- use GetCurrentState to fetch full state data.
   *
   * Scope: `state:read`
   *
   * @generated from rpc admiral.api.state.v1.StateAPI.ListStates
   */
  listStates: {
    methodKind: "unary";
    input: typeof ListStatesRequestSchema;
    output: typeof ListStatesResponseSchema;
  },
  /**
   * ListStateVersions returns a paginated history of state versions for a
   * state record. Returns metadata only (serial, md5, size) -- use
   * GetStateVersion to fetch the full state data at a specific serial.
   *
   * Returns NOT_FOUND if the state record does not exist.
   *
   * Scope: `state:read`
   *
   * @generated from rpc admiral.api.state.v1.StateAPI.ListStateVersions
   */
  listStateVersions: {
    methodKind: "unary";
    input: typeof ListStateVersionsRequestSchema;
    output: typeof ListStateVersionsResponseSchema;
  },
  /**
   * GetStateVersion retrieves the full state data at a historical serial
   * number. Use ListStateVersions to discover available serials.
   *
   * Returns NOT_FOUND if the state record does not exist or if no version
   * with the specified serial exists for that state record.
   *
   * Scope: `state:read`
   *
   * @generated from rpc admiral.api.state.v1.StateAPI.GetStateVersion
   */
  getStateVersion: {
    methodKind: "unary";
    input: typeof GetStateVersionRequestSchema;
    output: typeof GetStateVersionResponseSchema;
  },
  /**
   * ForceUnlockState forcefully releases a stuck lock on a state record.
   * Use this when a runner has crashed or become unreachable while holding
   * a lock, preventing subsequent deployments from proceeding.
   *
   * Returns NOT_FOUND if the state record does not exist.
   * Returns FAILED_PRECONDITION if the state has no active lock.
   * This action is logged in the audit trail.
   *
   * Scope: `state:admin`
   *
   * @generated from rpc admiral.api.state.v1.StateAPI.ForceUnlockState
   */
  forceUnlockState: {
    methodKind: "unary";
    input: typeof ForceUnlockStateRequestSchema;
    output: typeof ForceUnlockStateResponseSchema;
  },
  /**
   * DeleteState permanently deletes a state record and all its version
   * history. Fails if the state is currently locked -- force-unlock first.
   * This action cannot be undone.
   *
   * Returns NOT_FOUND if the state record does not exist.
   * Returns FAILED_PRECONDITION if the state is currently locked.
   *
   * Scope: `state:admin`
   *
   * @generated from rpc admiral.api.state.v1.StateAPI.DeleteState
   */
  deleteState: {
    methodKind: "unary";
    input: typeof DeleteStateRequestSchema;
    output: typeof DeleteStateResponseSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_admiral_api_state_v1_state, 0);

