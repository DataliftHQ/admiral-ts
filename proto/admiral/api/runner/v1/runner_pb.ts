// @generated by protoc-gen-es v2.11.0 with parameter "target=ts"
// @generated from file admiral/api/runner/v1/runner.proto (package admiral.api.runner.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv2";
import { enumDesc, fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv2";
import { file_admiral_common_v1_annotations } from "../../../common/v1/annotations_pb";
import type { AccessToken } from "../../../common/v1/token_pb";
import { file_admiral_common_v1_token } from "../../../common/v1/token_pb";
import type { TerraformPlanSummary } from "../../deployment/v1/deployment_pb";
import { file_admiral_api_deployment_v1_deployment } from "../../deployment/v1/deployment_pb";
import { file_buf_validate_validate } from "../../../../buf/validate/validate_pb";
import { file_gnostic_openapi_v3_annotations } from "../../../../gnostic/openapi/v3/annotations_pb";
import { file_google_api_annotations } from "../../../../google/api/annotations_pb";
import type { Duration, FieldMask, Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_duration, file_google_protobuf_field_mask, file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file admiral/api/runner/v1/runner.proto.
 */
export const file_admiral_api_runner_v1_runner: GenFile = /*@__PURE__*/
  fileDesc("CiJhZG1pcmFsL2FwaS9ydW5uZXIvdjEvcnVubmVyLnByb3RvEhVhZG1pcmFsLmFwaS5ydW5uZXIudjEilAQKBlJ1bm5lchIUCgJpZBgBIAEoCUIIukgFcgOwAQESGwoJdGVuYW50X2lkGAIgASgJQgi6SAVyA7ABARI6CgRuYW1lGAMgASgJQiy6SClyJxABGD8yIV5bYS16XShbYS16MC05LV17MCw2MX1bYS16MC05XSk/JBIdCgtkZXNjcmlwdGlvbhgEIAEoCUIIukgFcgMYgAgSLwoEa2luZBgFIAEoDjIhLmFkbWlyYWwuYXBpLnJ1bm5lci52MS5SdW5uZXJLaW5kElIKBmxhYmVscxgGIAMoCzIpLmFkbWlyYWwuYXBpLnJ1bm5lci52MS5SdW5uZXIuTGFiZWxzRW50cnlCF7pIFJoBERBAIgZyBBABGD8qBXIDGIACEkAKDWhlYWx0aF9zdGF0dXMYByABKA4yKS5hZG1pcmFsLmFwaS5ydW5uZXIudjEuUnVubmVySGVhbHRoU3RhdHVzEhIKCmNyZWF0ZWRfYnkYCiABKAkSEgoKdXBkYXRlZF9ieRgLIAEoCRIuCgpjcmVhdGVkX2F0GAggASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBIuCgp1cGRhdGVkX2F0GAkgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBotCgtMYWJlbHNFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBIs0CCgxSdW5uZXJTdGF0dXMSDwoHdmVyc2lvbhgBIAEoCRITCgthY3RpdmVfam9icxgCIAEoBRIbChNtYXhfY29uY3VycmVudF9qb2JzGAMgASgFEhsKE2F2YWlsYWJsZV9wcm92aWRlcnMYBCADKAkSZgoNdG9vbF92ZXJzaW9ucxgFIAMoCzI1LmFkbWlyYWwuYXBpLnJ1bm5lci52MS5SdW5uZXJTdGF0dXMuVG9vbFZlcnNpb25zRW50cnlCGLpIFZoBEhAgIgZyBBABGD8qBnIEEAEYIBJAChJhY3RpdmVfam9iX2RldGFpbHMYBiADKAsyJC5hZG1pcmFsLmFwaS5ydW5uZXIudjEuQWN0aXZlSm9iSW5mbxozChFUb29sVmVyc2lvbnNFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBIokBCg1BY3RpdmVKb2JJbmZvEhgKBmpvYl9pZBgBIAEoCUIIukgFcgOwAQESLgoFcGhhc2UYAiABKA4yHy5hZG1pcmFsLmFwaS5ydW5uZXIudjEuSm9iUGhhc2USLgoKc3RhcnRlZF9hdBgDIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAi7gIKA0pvYhIUCgJpZBgBIAEoCUIIukgFcgOwAQESGwoJcnVubmVyX2lkGAIgASgJQgi6SAVyA7ABARIdCgtyZXZpc2lvbl9pZBgDIAEoCUIIukgFcgOwAQESHwoNZGVwbG95bWVudF9pZBgEIAEoCUIIukgFcgOwAQESMAoIam9iX3R5cGUYBSABKA4yHi5hZG1pcmFsLmFwaS5ydW5uZXIudjEuSm9iVHlwZRIwCgZzdGF0dXMYBiABKA4yIC5hZG1pcmFsLmFwaS5ydW5uZXIudjEuSm9iU3RhdHVzEi4KCmNyZWF0ZWRfYXQYByABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEi4KCnN0YXJ0ZWRfYXQYCCABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEjAKDGNvbXBsZXRlZF9hdBgJIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAi7gIKCUpvYkJ1bmRsZRIUCgxhcnRpZmFjdF91cmwYASABKAkSGQoRYXJ0aWZhY3RfY2hlY2tzdW0YAiABKAkSQgoJdmFyaWFibGVzGAMgAygLMi8uYWRtaXJhbC5hcGkucnVubmVyLnYxLkpvYkJ1bmRsZS5WYXJpYWJsZXNFbnRyeRJPChBwcm92aWRlcl9jb25maWdzGAQgAygLMjUuYWRtaXJhbC5hcGkucnVubmVyLnYxLkpvYkJ1bmRsZS5Qcm92aWRlckNvbmZpZ3NFbnRyeRIWCg5iYWNrZW5kX2NvbmZpZxgFIAEoCRIZChF0ZXJyYWZvcm1fdmVyc2lvbhgGIAEoCRowCg5WYXJpYWJsZXNFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBGjYKFFByb3ZpZGVyQ29uZmlnc0VudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCToCOAEi7wEKCUpvYlJlc3VsdBIwCgZzdGF0dXMYASABKA4yIC5hZG1pcmFsLmFwaS5ydW5uZXIudjEuSm9iU3RhdHVzEhMKC3BsYW5fb3V0cHV0GAIgASgJEkUKDHBsYW5fc3VtbWFyeRgDIAEoCzIvLmFkbWlyYWwuYXBpLmRlcGxveW1lbnQudjEuVGVycmFmb3JtUGxhblN1bW1hcnkSFQoNZXJyb3JfbWVzc2FnZRgEIAEoCRIQCghsb2dzX3VybBgFIAEoCRIrCghkdXJhdGlvbhgGIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbiKxAgoTQ3JlYXRlUnVubmVyUmVxdWVzdBI6CgRuYW1lGAEgASgJQiy6SClyJxABGD8yIV5bYS16XShbYS16MC05LV17MCw2MX1bYS16MC05XSk/JBIdCgtkZXNjcmlwdGlvbhgCIAEoCUIIukgFcgMYgAgSLwoEa2luZBgDIAEoDjIhLmFkbWlyYWwuYXBpLnJ1bm5lci52MS5SdW5uZXJLaW5kEl8KBmxhYmVscxgEIAMoCzI2LmFkbWlyYWwuYXBpLnJ1bm5lci52MS5DcmVhdGVSdW5uZXJSZXF1ZXN0LkxhYmVsc0VudHJ5Qhe6SBSaAREQQCIGcgQQARg/KgVyAxiAAhotCgtMYWJlbHNFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBIl8KFENyZWF0ZVJ1bm5lclJlc3BvbnNlEi0KBnJ1bm5lchgBIAEoCzIdLmFkbWlyYWwuYXBpLnJ1bm5lci52MS5SdW5uZXISGAoQcGxhaW5fdGV4dF90b2tlbhgCIAEoCSIvChBHZXRSdW5uZXJSZXF1ZXN0EhsKCXJ1bm5lcl9pZBgBIAEoCUIIukgFcgOwAQEiQgoRR2V0UnVubmVyUmVzcG9uc2USLQoGcnVubmVyGAEgASgLMh0uYWRtaXJhbC5hcGkucnVubmVyLnYxLlJ1bm5lciJgChJMaXN0UnVubmVyc1JlcXVlc3QSGAoGZmlsdGVyGAEgASgJQgi6SAVyAxiACBIcCglwYWdlX3NpemUYAiABKAVCCbpIBhoEGGQoABISCgpwYWdlX3Rva2VuGAMgASgJIl4KE0xpc3RSdW5uZXJzUmVzcG9uc2USLgoHcnVubmVycxgBIAMoCzIdLmFkbWlyYWwuYXBpLnJ1bm5lci52MS5SdW5uZXISFwoPbmV4dF9wYWdlX3Rva2VuGAIgASgJIn0KE1VwZGF0ZVJ1bm5lclJlcXVlc3QSNQoGcnVubmVyGAEgASgLMh0uYWRtaXJhbC5hcGkucnVubmVyLnYxLlJ1bm5lckIGukgDyAEBEi8KC3VwZGF0ZV9tYXNrGAIgASgLMhouZ29vZ2xlLnByb3RvYnVmLkZpZWxkTWFzayJFChRVcGRhdGVSdW5uZXJSZXNwb25zZRItCgZydW5uZXIYASABKAsyHS5hZG1pcmFsLmFwaS5ydW5uZXIudjEuUnVubmVyIjIKE0RlbGV0ZVJ1bm5lclJlcXVlc3QSGwoJcnVubmVyX2lkGAEgASgJQgi6SAVyA7ABASIWChREZWxldGVSdW5uZXJSZXNwb25zZSI1ChZHZXRSdW5uZXJTdGF0dXNSZXF1ZXN0EhsKCXJ1bm5lcl9pZBgBIAEoCUIIukgFcgOwAQEiwQEKF0dldFJ1bm5lclN0YXR1c1Jlc3BvbnNlEkAKDWhlYWx0aF9zdGF0dXMYASABKA4yKS5hZG1pcmFsLmFwaS5ydW5uZXIudjEuUnVubmVySGVhbHRoU3RhdHVzEjMKBnN0YXR1cxgCIAEoCzIjLmFkbWlyYWwuYXBpLnJ1bm5lci52MS5SdW5uZXJTdGF0dXMSLwoLcmVwb3J0ZWRfYXQYAyABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wIqMBChhDcmVhdGVSdW5uZXJUb2tlblJlcXVlc3QSGwoJcnVubmVyX2lkGAEgASgJQgi6SAVyA7ABARI6CgRuYW1lGAIgASgJQiy6SClyJxABGD8yIV5bYS16XShbYS16MC05LV17MCw2MX1bYS16MC05XSk/JBIuCgpleHBpcmVzX2F0GAMgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCJrChlDcmVhdGVSdW5uZXJUb2tlblJlc3BvbnNlEjQKDGFjY2Vzc190b2tlbhgBIAEoCzIeLmFkbWlyYWwuY29tbW9uLnYxLkFjY2Vzc1Rva2VuEhgKEHBsYWluX3RleHRfdG9rZW4YAiABKAkiggEKF0xpc3RSdW5uZXJUb2tlbnNSZXF1ZXN0EhsKCXJ1bm5lcl9pZBgBIAEoCUIIukgFcgOwAQESGAoGZmlsdGVyGAIgASgJQgi6SAVyAxiACBIcCglwYWdlX3NpemUYAyABKAVCCbpIBhoEGGQoABISCgpwYWdlX3Rva2VuGAQgASgJImoKGExpc3RSdW5uZXJUb2tlbnNSZXNwb25zZRI1Cg1hY2Nlc3NfdG9rZW5zGAEgAygLMh4uYWRtaXJhbC5jb21tb24udjEuQWNjZXNzVG9rZW4SFwoPbmV4dF9wYWdlX3Rva2VuGAIgASgJIlAKFUdldFJ1bm5lclRva2VuUmVxdWVzdBIbCglydW5uZXJfaWQYASABKAlCCLpIBXIDsAEBEhoKCHRva2VuX2lkGAIgASgJQgi6SAVyA7ABASJOChZHZXRSdW5uZXJUb2tlblJlc3BvbnNlEjQKDGFjY2Vzc190b2tlbhgBIAEoCzIeLmFkbWlyYWwuY29tbW9uLnYxLkFjY2Vzc1Rva2VuIlMKGFJldm9rZVJ1bm5lclRva2VuUmVxdWVzdBIbCglydW5uZXJfaWQYASABKAlCCLpIBXIDsAEBEhoKCHRva2VuX2lkGAIgASgJQgi6SAVyA7ABASJRChlSZXZva2VSdW5uZXJUb2tlblJlc3BvbnNlEjQKDGFjY2Vzc190b2tlbhgBIAEoCzIeLmFkbWlyYWwuY29tbW9uLnYxLkFjY2Vzc1Rva2VuIm4KEEhlYXJ0YmVhdFJlcXVlc3QSOwoGc3RhdHVzGAEgASgLMiMuYWRtaXJhbC5hcGkucnVubmVyLnYxLlJ1bm5lclN0YXR1c0IGukgDyAEBEh0KC2luc3RhbmNlX2lkGAIgASgJQgi6SAVyA7ABASJAChFIZWFydGJlYXRSZXNwb25zZRILCgNhY2sYASABKAgSHgoWbmV4dF9oZWFydGJlYXRfc2Vjb25kcxgCIAEoBSIRCg9DbGFpbUpvYlJlcXVlc3QiOwoQQ2xhaW1Kb2JSZXNwb25zZRInCgNqb2IYASABKAsyGi5hZG1pcmFsLmFwaS5ydW5uZXIudjEuSm9iIi8KE0dldEpvYkJ1bmRsZVJlcXVlc3QSGAoGam9iX2lkGAEgASgJQgi6SAVyA7ABASJIChRHZXRKb2JCdW5kbGVSZXNwb25zZRIwCgZidW5kbGUYASABKAsyIC5hZG1pcmFsLmFwaS5ydW5uZXIudjEuSm9iQnVuZGxlImwKFlJlcG9ydEpvYlJlc3VsdFJlcXVlc3QSGAoGam9iX2lkGAEgASgJQgi6SAVyA7ABARI4CgZyZXN1bHQYAiABKAsyIC5hZG1pcmFsLmFwaS5ydW5uZXIudjEuSm9iUmVzdWx0Qga6SAPIAQEiJgoXUmVwb3J0Sm9iUmVzdWx0UmVzcG9uc2USCwoDYWNrGAEgASgIIoABChVMaXN0UnVubmVySm9ic1JlcXVlc3QSGwoJcnVubmVyX2lkGAEgASgJQgi6SAVyA7ABARIYCgZmaWx0ZXIYAiABKAlCCLpIBXIDGIAIEhwKCXBhZ2Vfc2l6ZRgDIAEoBUIJukgGGgQYZCgAEhIKCnBhZ2VfdG9rZW4YBCABKAkiWwoWTGlzdFJ1bm5lckpvYnNSZXNwb25zZRIoCgRqb2JzGAEgAygLMhouYWRtaXJhbC5hcGkucnVubmVyLnYxLkpvYhIXCg9uZXh0X3BhZ2VfdG9rZW4YAiABKAkqXgoKUnVubmVyS2luZBIbChdSVU5ORVJfS0lORF9VTlNQRUNJRklFRBAAEhkKFVJVTk5FUl9LSU5EX1RFUlJBRk9STRABEhgKFFJVTk5FUl9LSU5EX1dPUktGTE9XEAIqxwEKElJ1bm5lckhlYWx0aFN0YXR1cxIkCiBSVU5ORVJfSEVBTFRIX1NUQVRVU19VTlNQRUNJRklFRBAAEiAKHFJVTk5FUl9IRUFMVEhfU1RBVFVTX1BFTkRJTkcQARIgChxSVU5ORVJfSEVBTFRIX1NUQVRVU19IRUFMVEhZEAISIQodUlVOTkVSX0hFQUxUSF9TVEFUVVNfREVHUkFERUQQAxIkCiBSVU5ORVJfSEVBTFRIX1NUQVRVU19VTlJFQUNIQUJMRRAEKrsBCglKb2JTdGF0dXMSGgoWSk9CX1NUQVRVU19VTlNQRUNJRklFRBAAEhYKEkpPQl9TVEFUVVNfUEVORElORxABEhcKE0pPQl9TVEFUVVNfQVNTSUdORUQQAhIWChJKT0JfU1RBVFVTX1JVTk5JTkcQAxIYChRKT0JfU1RBVFVTX1NVQ0NFRURFRBAEEhUKEUpPQl9TVEFUVVNfRkFJTEVEEAUSGAoUSk9CX1NUQVRVU19DQU5DRUxMRUQQBiqBAQoHSm9iVHlwZRIYChRKT0JfVFlQRV9VTlNQRUNJRklFRBAAEhEKDUpPQl9UWVBFX1BMQU4QARISCg5KT0JfVFlQRV9BUFBMWRACEhkKFUpPQl9UWVBFX0RFU1RST1lfUExBThADEhoKFkpPQl9UWVBFX0RFU1RST1lfQVBQTFkQBCqLAQoISm9iUGhhc2USGQoVSk9CX1BIQVNFX1VOU1BFQ0lGSUVEEAASGgoWSk9CX1BIQVNFX0lOSVRJQUxJWklORxABEhYKEkpPQl9QSEFTRV9QTEFOTklORxACEhYKEkpPQl9QSEFTRV9BUFBMWUlORxADEhgKFEpPQl9QSEFTRV9GSU5BTElaSU5HEAQylxcKCVJ1bm5lckFQSRKuAQoMQ3JlYXRlUnVubmVyEiouYWRtaXJhbC5hcGkucnVubmVyLnYxLkNyZWF0ZVJ1bm5lclJlcXVlc3QaKy5hZG1pcmFsLmFwaS5ydW5uZXIudjEuQ3JlYXRlUnVubmVyUmVzcG9uc2UiRbpHGgoHUnVubmVycxIPQ3JlYXRlIGEgcnVubmVyopckDgoMcnVubmVyOndyaXRlgtPkkwIQOgEqIgsvdjEvcnVubmVycxKvAQoJR2V0UnVubmVyEicuYWRtaXJhbC5hcGkucnVubmVyLnYxLkdldFJ1bm5lclJlcXVlc3QaKC5hZG1pcmFsLmFwaS5ydW5uZXIudjEuR2V0UnVubmVyUmVzcG9uc2UiT7pHHAoHUnVubmVycxIRUmV0cmlldmUgYSBydW5uZXKilyQNCgtydW5uZXI6cmVhZILT5JMCGRIXL3YxL3J1bm5lcnMve3J1bm5lcl9pZH0SpAEKC0xpc3RSdW5uZXJzEikuYWRtaXJhbC5hcGkucnVubmVyLnYxLkxpc3RSdW5uZXJzUmVxdWVzdBoqLmFkbWlyYWwuYXBpLnJ1bm5lci52MS5MaXN0UnVubmVyc1Jlc3BvbnNlIj66RxcKB1J1bm5lcnMSDExpc3QgcnVubmVyc6KXJA0KC3J1bm5lcjpyZWFkgtPkkwINEgsvdjEvcnVubmVycxK6AQoMVXBkYXRlUnVubmVyEiouYWRtaXJhbC5hcGkucnVubmVyLnYxLlVwZGF0ZVJ1bm5lclJlcXVlc3QaKy5hZG1pcmFsLmFwaS5ydW5uZXIudjEuVXBkYXRlUnVubmVyUmVzcG9uc2UiUbpHGgoHUnVubmVycxIPVXBkYXRlIGEgcnVubmVyopckDgoMcnVubmVyOndyaXRlgtPkkwIcOgEqMhcvdjEvcnVubmVycy97cnVubmVyLmlkfRK3AQoMRGVsZXRlUnVubmVyEiouYWRtaXJhbC5hcGkucnVubmVyLnYxLkRlbGV0ZVJ1bm5lclJlcXVlc3QaKy5hZG1pcmFsLmFwaS5ydW5uZXIudjEuRGVsZXRlUnVubmVyUmVzcG9uc2UiTrpHGgoHUnVubmVycxIPRGVsZXRlIGEgcnVubmVyopckDgoMcnVubmVyOndyaXRlgtPkkwIZKhcvdjEvcnVubmVycy97cnVubmVyX2lkfRLNAQoPR2V0UnVubmVyU3RhdHVzEi0uYWRtaXJhbC5hcGkucnVubmVyLnYxLkdldFJ1bm5lclN0YXR1c1JlcXVlc3QaLi5hZG1pcmFsLmFwaS5ydW5uZXIudjEuR2V0UnVubmVyU3RhdHVzUmVzcG9uc2UiW7pHIQoHUnVubmVycxIWUmV0cmlldmUgcnVubmVyIHN0YXR1c6KXJA0KC3J1bm5lcjpyZWFkgtPkkwIgEh4vdjEvcnVubmVycy97cnVubmVyX2lkfS9zdGF0dXMS1gEKEUNyZWF0ZVJ1bm5lclRva2VuEi8uYWRtaXJhbC5hcGkucnVubmVyLnYxLkNyZWF0ZVJ1bm5lclRva2VuUmVxdWVzdBowLmFkbWlyYWwuYXBpLnJ1bm5lci52MS5DcmVhdGVSdW5uZXJUb2tlblJlc3BvbnNlIl66RyAKB1J1bm5lcnMSFUNyZWF0ZSBhIHJ1bm5lciB0b2tlbqKXJA4KDHJ1bm5lcjp3cml0ZYLT5JMCIzoBKiIeL3YxL3J1bm5lcnMve3J1bm5lcl9pZH0vdG9rZW5zEswBChBMaXN0UnVubmVyVG9rZW5zEi4uYWRtaXJhbC5hcGkucnVubmVyLnYxLkxpc3RSdW5uZXJUb2tlbnNSZXF1ZXN0Gi8uYWRtaXJhbC5hcGkucnVubmVyLnYxLkxpc3RSdW5uZXJUb2tlbnNSZXNwb25zZSJXukcdCgdSdW5uZXJzEhJMaXN0IHJ1bm5lciB0b2tlbnOilyQNCgtydW5uZXI6cmVhZILT5JMCIBIeL3YxL3J1bm5lcnMve3J1bm5lcl9pZH0vdG9rZW5zEtYBCg5HZXRSdW5uZXJUb2tlbhIsLmFkbWlyYWwuYXBpLnJ1bm5lci52MS5HZXRSdW5uZXJUb2tlblJlcXVlc3QaLS5hZG1pcmFsLmFwaS5ydW5uZXIudjEuR2V0UnVubmVyVG9rZW5SZXNwb25zZSJnukciCgdSdW5uZXJzEhdSZXRyaWV2ZSBhIHJ1bm5lciB0b2tlbqKXJA0KC3J1bm5lcjpyZWFkgtPkkwIrEikvdjEvcnVubmVycy97cnVubmVyX2lkfS90b2tlbnMve3Rva2VuX2lkfRLoAQoRUmV2b2tlUnVubmVyVG9rZW4SLy5hZG1pcmFsLmFwaS5ydW5uZXIudjEuUmV2b2tlUnVubmVyVG9rZW5SZXF1ZXN0GjAuYWRtaXJhbC5hcGkucnVubmVyLnYxLlJldm9rZVJ1bm5lclRva2VuUmVzcG9uc2UicLpHIAoHUnVubmVycxIVUmV2b2tlIGEgcnVubmVyIHRva2VuopckDgoMcnVubmVyOndyaXRlgtPkkwI1OgEqIjAvdjEvcnVubmVycy97cnVubmVyX2lkfS90b2tlbnMve3Rva2VuX2lkfS9yZXZva2USuAEKCUhlYXJ0YmVhdBInLmFkbWlyYWwuYXBpLnJ1bm5lci52MS5IZWFydGJlYXRSZXF1ZXN0GiguYWRtaXJhbC5hcGkucnVubmVyLnYxLkhlYXJ0YmVhdFJlc3BvbnNlIli6RyAKB1J1bm5lcnMSFVNlbmQgcnVubmVyIGhlYXJ0YmVhdKKXJBIKC3J1bm5lcjpleGVjEgNhZ3SC0+STAhk6ASoiFC92MS9ydW5uZXIvaGVhcnRiZWF0EqwBCghDbGFpbUpvYhImLmFkbWlyYWwuYXBpLnJ1bm5lci52MS5DbGFpbUpvYlJlcXVlc3QaJy5hZG1pcmFsLmFwaS5ydW5uZXIudjEuQ2xhaW1Kb2JSZXNwb25zZSJPukcWCgdSdW5uZXJzEgtDbGFpbSBhIGpvYqKXJBIKC3J1bm5lcjpleGVjEgNhZ3SC0+STAho6ASoiFS92MS9ydW5uZXIvam9icy9jbGFpbRLJAQoMR2V0Sm9iQnVuZGxlEiouYWRtaXJhbC5hcGkucnVubmVyLnYxLkdldEpvYkJ1bmRsZVJlcXVlc3QaKy5hZG1pcmFsLmFwaS5ydW5uZXIudjEuR2V0Sm9iQnVuZGxlUmVzcG9uc2UiYLpHIAoHUnVubmVycxIVUmV0cmlldmUgYSBqb2IgYnVuZGxlopckEgoLcnVubmVyOmV4ZWMSA2FndILT5JMCIRIfL3YxL3J1bm5lci9qb2JzL3tqb2JfaWR9L2J1bmRsZRLRAQoPUmVwb3J0Sm9iUmVzdWx0Ei0uYWRtaXJhbC5hcGkucnVubmVyLnYxLlJlcG9ydEpvYlJlc3VsdFJlcXVlc3QaLi5hZG1pcmFsLmFwaS5ydW5uZXIudjEuUmVwb3J0Sm9iUmVzdWx0UmVzcG9uc2UiX7pHHAoHUnVubmVycxIRUmVwb3J0IGpvYiByZXN1bHSilyQSCgtydW5uZXI6ZXhlYxIDYWd0gtPkkwIkOgEqIh8vdjEvcnVubmVyL2pvYnMve2pvYl9pZH0vcmVzdWx0EsIBCg5MaXN0UnVubmVySm9icxIsLmFkbWlyYWwuYXBpLnJ1bm5lci52MS5MaXN0UnVubmVySm9ic1JlcXVlc3QaLS5hZG1pcmFsLmFwaS5ydW5uZXIudjEuTGlzdFJ1bm5lckpvYnNSZXNwb25zZSJTukcbCgdSdW5uZXJzEhBMaXN0IHJ1bm5lciBqb2JzopckDQoLcnVubmVyOnJlYWSC0+STAh4SHC92MS9ydW5uZXJzL3tydW5uZXJfaWR9L2pvYnNC1wEKGWNvbS5hZG1pcmFsLmFwaS5ydW5uZXIudjFCC1J1bm5lclByb3RvUAFaNmdvLmFkbWlyYWwuaW8vc2RrL3Byb3RvL2FkbWlyYWwvYXBpL3J1bm5lci92MTtydW5uZXJ2MaICA0FBUqoCFUFkbWlyYWwuQXBpLlJ1bm5lci5WMcoCFUFkbWlyYWxcQXBpXFJ1bm5lclxWMeICIUFkbWlyYWxcQXBpXFJ1bm5lclxWMVxHUEJNZXRhZGF0YeoCGEFkbWlyYWw6OkFwaTo6UnVubmVyOjpWMWIGcHJvdG8z", [file_admiral_common_v1_annotations, file_admiral_common_v1_token, file_admiral_api_deployment_v1_deployment, file_buf_validate_validate, file_gnostic_openapi_v3_annotations, file_google_api_annotations, file_google_protobuf_duration, file_google_protobuf_field_mask, file_google_protobuf_timestamp]);

/**
 * Runner represents a registered infrastructure execution runner within a
 * tenant. Runners claim and execute Terraform operations (plan, apply, destroy)
 * dispatched by the deployment engine.
 *
 * @generated from message admiral.api.runner.v1.Runner
 */
export type Runner = Message<"admiral.api.runner.v1.Runner"> & {
  /**
   * Unique identifier for the runner (UUID).
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * Tenant this runner belongs to (UUID).
   *
   * @generated from field: string tenant_id = 2;
   */
  tenantId: string;

  /**
   * URL-safe, human-readable identifier (e.g., "prod-terraform-runner").
   * Unique within the tenant. Lowercase alphanumeric and hyphens only,
   * must start with a letter and end with an alphanumeric character (1-63 chars).
   *
   * @generated from field: string name = 3;
   */
  name: string;

  /**
   * Optional longer-form description of the runner's purpose
   * (e.g., "Terraform runner for production AWS infrastructure").
   *
   * @generated from field: string description = 4;
   */
  description: string;

  /**
   * The type of operations this runner executes.
   *
   * @generated from field: admiral.api.runner.v1.RunnerKind kind = 5;
   */
  kind: RunnerKind;

  /**
   * Arbitrary key-value labels for organizing and filtering runners
   * (e.g., `{"cloud": "aws", "team": "platform"}`).
   *
   * @generated from field: map<string, string> labels = 6;
   */
  labels: { [key: string]: string };

  /**
   * Derived health status based on heartbeat recency and capacity.
   *
   * @generated from field: admiral.api.runner.v1.RunnerHealthStatus health_status = 7;
   */
  healthStatus: RunnerHealthStatus;

  /**
   * User ID who created this runner (UUID, server-populated from token).
   *
   * @generated from field: string created_by = 10;
   */
  createdBy: string;

  /**
   * User ID who last updated this runner (UUID, server-populated from token).
   *
   * @generated from field: string updated_by = 11;
   */
  updatedBy: string;

  /**
   * When the runner record was created.
   *
   * @generated from field: google.protobuf.Timestamp created_at = 8;
   */
  createdAt?: Timestamp;

  /**
   * When the runner record was last updated.
   *
   * @generated from field: google.protobuf.Timestamp updated_at = 9;
   */
  updatedAt?: Timestamp;
};

/**
 * Describes the message admiral.api.runner.v1.Runner.
 * Use `create(RunnerSchema)` to create a new message.
 */
export const RunnerSchema: GenMessage<Runner> = /*@__PURE__*/
  messageDesc(file_admiral_api_runner_v1_runner, 0);

/**
 * RunnerStatus contains capacity and telemetry metrics for a runner, as
 * reported via Heartbeat. This message is used in both the push payload
 * (HeartbeatRequest) and the read response (GetRunnerStatusResponse).
 *
 * Server-derived fields (health_status) are NOT included here — they live
 * on the Runner record and are returned alongside this message in
 * GetRunnerStatusResponse.
 *
 * @generated from message admiral.api.runner.v1.RunnerStatus
 */
export type RunnerStatus = Message<"admiral.api.runner.v1.RunnerStatus"> & {
  /**
   * The runner binary version (e.g., "1.2.0").
   *
   * @generated from field: string version = 1;
   */
  version: string;

  /**
   * Number of jobs currently being executed by this runner.
   *
   * @generated from field: int32 active_jobs = 2;
   */
  activeJobs: number;

  /**
   * Maximum number of concurrent jobs this runner supports.
   *
   * @generated from field: int32 max_concurrent_jobs = 3;
   */
  maxConcurrentJobs: number;

  /**
   * Terraform providers available on this runner (e.g., ["aws", "google", "azurerm"]).
   *
   * @generated from field: repeated string available_providers = 4;
   */
  availableProviders: string[];

  /**
   * CLI tool versions installed on this runner, detected at startup and
   * reported on every heartbeat. Visible to admins via GetRunnerStatus.
   * The server uses tool_versions to match jobs to capable runners (e.g.,
   * a job requiring Terraform 1.9.x will only be assigned to a runner
   * reporting a compatible version).
   * Keys are tool names (e.g., "terraform", "tofu", "helm", "kustomize", "kubectl").
   * Values are semantic versions (e.g., "1.7.5", "1.9.0").
   *
   * @generated from field: map<string, string> tool_versions = 5;
   */
  toolVersions: { [key: string]: string };

  /**
   * Details of jobs currently being executed by this runner instance. The
   * worker thread updates job phase in shared memory; the heartbeat thread
   * reads and includes it on each tick. Gives the server visibility into
   * job progress for stuck-job detection and admin dashboards.
   *
   * @generated from field: repeated admiral.api.runner.v1.ActiveJobInfo active_job_details = 6;
   */
  activeJobDetails: ActiveJobInfo[];
};

/**
 * Describes the message admiral.api.runner.v1.RunnerStatus.
 * Use `create(RunnerStatusSchema)` to create a new message.
 */
export const RunnerStatusSchema: GenMessage<RunnerStatus> = /*@__PURE__*/
  messageDesc(file_admiral_api_runner_v1_runner, 1);

/**
 * ActiveJobInfo summarizes a job currently being executed by a runner instance.
 * Included in RunnerStatus to provide real-time job progress via heartbeat.
 *
 * @generated from message admiral.api.runner.v1.ActiveJobInfo
 */
export type ActiveJobInfo = Message<"admiral.api.runner.v1.ActiveJobInfo"> & {
  /**
   * The job being executed (UUID).
   *
   * @generated from field: string job_id = 1;
   */
  jobId: string;

  /**
   * Current execution phase reported by the worker thread.
   *
   * @generated from field: admiral.api.runner.v1.JobPhase phase = 2;
   */
  phase: JobPhase;

  /**
   * When execution of this job started (when the runner claimed it).
   *
   * @generated from field: google.protobuf.Timestamp started_at = 3;
   */
  startedAt?: Timestamp;
};

/**
 * Describes the message admiral.api.runner.v1.ActiveJobInfo.
 * Use `create(ActiveJobInfoSchema)` to create a new message.
 */
export const ActiveJobInfoSchema: GenMessage<ActiveJobInfo> = /*@__PURE__*/
  messageDesc(file_admiral_api_runner_v1_runner, 2);

/**
 * Job represents an infrastructure execution job assigned to a runner.
 * Jobs bridge the Deployment/Revision system and the Runner execution plane.
 *
 * @generated from message admiral.api.runner.v1.Job
 */
export type Job = Message<"admiral.api.runner.v1.Job"> & {
  /**
   * Unique identifier for the job (UUID).
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * The runner this job is assigned to (UUID).
   *
   * @generated from field: string runner_id = 2;
   */
  runnerId: string;

  /**
   * The revision this job belongs to (UUID).
   *
   * @generated from field: string revision_id = 3;
   */
  revisionId: string;

  /**
   * The deployment this job belongs to (UUID). Denormalized for convenience.
   *
   * @generated from field: string deployment_id = 4;
   */
  deploymentId: string;

  /**
   * The type of Terraform operation to execute.
   *
   * @generated from field: admiral.api.runner.v1.JobType job_type = 5;
   */
  jobType: JobType;

  /**
   * Current lifecycle status of the job.
   *
   * @generated from field: admiral.api.runner.v1.JobStatus status = 6;
   */
  status: JobStatus;

  /**
   * When the job was created.
   *
   * @generated from field: google.protobuf.Timestamp created_at = 7;
   */
  createdAt?: Timestamp;

  /**
   * When the runner started executing the job.
   *
   * @generated from field: google.protobuf.Timestamp started_at = 8;
   */
  startedAt?: Timestamp;

  /**
   * When the job finished (succeeded, failed, or cancelled).
   *
   * @generated from field: google.protobuf.Timestamp completed_at = 9;
   */
  completedAt?: Timestamp;
};

/**
 * Describes the message admiral.api.runner.v1.Job.
 * Use `create(JobSchema)` to create a new message.
 */
export const JobSchema: GenMessage<Job> = /*@__PURE__*/
  messageDesc(file_admiral_api_runner_v1_runner, 3);

/**
 * JobBundle contains everything a runner needs to execute a Terraform operation.
 * Fetched separately from ClaimJob to keep the claim response lightweight.
 *
 * @generated from message admiral.api.runner.v1.JobBundle
 */
export type JobBundle = Message<"admiral.api.runner.v1.JobBundle"> & {
  /**
   * Signed URL to download the rendered artifact bundle (tar.gz containing
   * .tf files, .tfvars, etc.). Time-limited.
   *
   * @generated from field: string artifact_url = 1;
   */
  artifactUrl: string;

  /**
   * SHA-256 checksum of the artifact bundle for integrity verification.
   *
   * @generated from field: string artifact_checksum = 2;
   */
  artifactChecksum: string;

  /**
   * Resolved variable values to inject as TF_VAR_* environment variables.
   * Sensitive values are included (runner is a trusted execution context).
   *
   * @generated from field: map<string, string> variables = 3;
   */
  variables: { [key: string]: string };

  /**
   * Provider configuration blocks (JSON-encoded). Keys are provider names
   * (e.g., "aws", "google"), values are JSON objects with provider config.
   *
   * @generated from field: map<string, string> provider_configs = 4;
   */
  providerConfigs: { [key: string]: string };

  /**
   * Terraform backend configuration (JSON-encoded). Contains the backend
   * type and its configuration for state storage.
   *
   * @generated from field: string backend_config = 5;
   */
  backendConfig: string;

  /**
   * The Terraform version to use for this operation (e.g., "1.7.5").
   *
   * @generated from field: string terraform_version = 6;
   */
  terraformVersion: string;
};

/**
 * Describes the message admiral.api.runner.v1.JobBundle.
 * Use `create(JobBundleSchema)` to create a new message.
 */
export const JobBundleSchema: GenMessage<JobBundle> = /*@__PURE__*/
  messageDesc(file_admiral_api_runner_v1_runner, 4);

/**
 * JobResult contains the outcome of a completed job, reported by the runner.
 *
 * @generated from message admiral.api.runner.v1.JobResult
 */
export type JobResult = Message<"admiral.api.runner.v1.JobResult"> & {
  /**
   * The final status of the job (SUCCEEDED or FAILED).
   *
   * @generated from field: admiral.api.runner.v1.JobStatus status = 1;
   */
  status: JobStatus;

  /**
   * (Plan jobs only) The Terraform plan output in human-readable format.
   *
   * @generated from field: string plan_output = 2;
   */
  planOutput: string;

  /**
   * (Plan jobs only) Summary of resource changes from the plan.
   *
   * @generated from field: admiral.api.deployment.v1.TerraformPlanSummary plan_summary = 3;
   */
  planSummary?: TerraformPlanSummary;

  /**
   * Error message if the job failed. Empty on success.
   *
   * @generated from field: string error_message = 4;
   */
  errorMessage: string;

  /**
   * URL to the full execution logs in external storage.
   *
   * @generated from field: string logs_url = 5;
   */
  logsUrl: string;

  /**
   * How long the Terraform operation took to execute.
   *
   * @generated from field: google.protobuf.Duration duration = 6;
   */
  duration?: Duration;
};

/**
 * Describes the message admiral.api.runner.v1.JobResult.
 * Use `create(JobResultSchema)` to create a new message.
 */
export const JobResultSchema: GenMessage<JobResult> = /*@__PURE__*/
  messageDesc(file_admiral_api_runner_v1_runner, 5);

/**
 * CreateRunnerRequest contains the parameters for creating a new runner.
 *
 * @generated from message admiral.api.runner.v1.CreateRunnerRequest
 */
export type CreateRunnerRequest = Message<"admiral.api.runner.v1.CreateRunnerRequest"> & {
  /**
   * URL-safe, human-readable identifier (e.g., "prod-terraform-runner").
   * Must be unique within the tenant. Lowercase alphanumeric and hyphens only.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Optional longer-form description of the runner's purpose.
   *
   * @generated from field: string description = 2;
   */
  description: string;

  /**
   * The type of operations this runner executes.
   *
   * @generated from field: admiral.api.runner.v1.RunnerKind kind = 3;
   */
  kind: RunnerKind;

  /**
   * Arbitrary key-value labels for organizing and filtering runners.
   *
   * @generated from field: map<string, string> labels = 4;
   */
  labels: { [key: string]: string };
};

/**
 * Describes the message admiral.api.runner.v1.CreateRunnerRequest.
 * Use `create(CreateRunnerRequestSchema)` to create a new message.
 */
export const CreateRunnerRequestSchema: GenMessage<CreateRunnerRequest> = /*@__PURE__*/
  messageDesc(file_admiral_api_runner_v1_runner, 6);

/**
 * CreateRunnerResponse contains the newly created runner and its initial
 * Agent Token (AGT).
 *
 * @generated from message admiral.api.runner.v1.CreateRunnerResponse
 */
export type CreateRunnerResponse = Message<"admiral.api.runner.v1.CreateRunnerResponse"> & {
  /**
   * The created runner. Health status will be PENDING until the runner
   * begins heartbeating.
   *
   * @generated from field: admiral.api.runner.v1.Runner runner = 1;
   */
  runner?: Runner;

  /**
   * The raw Agent Token secret (e.g., "adm_agt_pL2mN5oQ8rS1..."). This value
   * is shown exactly once and cannot be retrieved again. Deploy this token to
   * the runner binary for authentication.
   *
   * To create additional tokens (e.g., for rotation), use
   * CreateRunnerToken (POST /v1/runners/{runner_id}/tokens).
   *
   * @generated from field: string plain_text_token = 2;
   */
  plainTextToken: string;
};

/**
 * Describes the message admiral.api.runner.v1.CreateRunnerResponse.
 * Use `create(CreateRunnerResponseSchema)` to create a new message.
 */
export const CreateRunnerResponseSchema: GenMessage<CreateRunnerResponse> = /*@__PURE__*/
  messageDesc(file_admiral_api_runner_v1_runner, 7);

/**
 * GetRunnerRequest identifies a runner to retrieve.
 *
 * @generated from message admiral.api.runner.v1.GetRunnerRequest
 */
export type GetRunnerRequest = Message<"admiral.api.runner.v1.GetRunnerRequest"> & {
  /**
   * The unique identifier of the runner (UUID).
   *
   * @generated from field: string runner_id = 1;
   */
  runnerId: string;
};

/**
 * Describes the message admiral.api.runner.v1.GetRunnerRequest.
 * Use `create(GetRunnerRequestSchema)` to create a new message.
 */
export const GetRunnerRequestSchema: GenMessage<GetRunnerRequest> = /*@__PURE__*/
  messageDesc(file_admiral_api_runner_v1_runner, 8);

/**
 * GetRunnerResponse contains the runner record.
 *
 * @generated from message admiral.api.runner.v1.GetRunnerResponse
 */
export type GetRunnerResponse = Message<"admiral.api.runner.v1.GetRunnerResponse"> & {
  /**
   * The runner record, including server-derived health_status.
   *
   * @generated from field: admiral.api.runner.v1.Runner runner = 1;
   */
  runner?: Runner;
};

/**
 * Describes the message admiral.api.runner.v1.GetRunnerResponse.
 * Use `create(GetRunnerResponseSchema)` to create a new message.
 */
export const GetRunnerResponseSchema: GenMessage<GetRunnerResponse> = /*@__PURE__*/
  messageDesc(file_admiral_api_runner_v1_runner, 9);

/**
 * ListRunnersRequest contains pagination and filter parameters.
 *
 * @generated from message admiral.api.runner.v1.ListRunnersRequest
 */
export type ListRunnersRequest = Message<"admiral.api.runner.v1.ListRunnersRequest"> & {
  /**
   * Filter expression using the PEG filter DSL.
   *
   * @generated from field: string filter = 1;
   */
  filter: string;

  /**
   * Maximum number of runners to return per page.
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize: number;

  /**
   * Opaque pagination token from a previous response.
   *
   * @generated from field: string page_token = 3;
   */
  pageToken: string;
};

/**
 * Describes the message admiral.api.runner.v1.ListRunnersRequest.
 * Use `create(ListRunnersRequestSchema)` to create a new message.
 */
export const ListRunnersRequestSchema: GenMessage<ListRunnersRequest> = /*@__PURE__*/
  messageDesc(file_admiral_api_runner_v1_runner, 10);

/**
 * ListRunnersResponse contains a page of runners.
 *
 * @generated from message admiral.api.runner.v1.ListRunnersResponse
 */
export type ListRunnersResponse = Message<"admiral.api.runner.v1.ListRunnersResponse"> & {
  /**
   * The list of runners.
   *
   * @generated from field: repeated admiral.api.runner.v1.Runner runners = 1;
   */
  runners: Runner[];

  /**
   * Pagination token for the next page. Empty when there are no more results.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;
};

/**
 * Describes the message admiral.api.runner.v1.ListRunnersResponse.
 * Use `create(ListRunnersResponseSchema)` to create a new message.
 */
export const ListRunnersResponseSchema: GenMessage<ListRunnersResponse> = /*@__PURE__*/
  messageDesc(file_admiral_api_runner_v1_runner, 11);

/**
 * UpdateRunnerRequest contains the runner fields to update.
 *
 * @generated from message admiral.api.runner.v1.UpdateRunnerRequest
 */
export type UpdateRunnerRequest = Message<"admiral.api.runner.v1.UpdateRunnerRequest"> & {
  /**
   * The runner with updated fields. The `id` field is required.
   * Only fields specified in `update_mask` are updated.
   *
   * @generated from field: admiral.api.runner.v1.Runner runner = 1;
   */
  runner?: Runner;

  /**
   * The set of fields to update. If unset, all mutable fields are updated.
   * Supported fields: `name`, `description`, `labels`.
   *
   * @generated from field: google.protobuf.FieldMask update_mask = 2;
   */
  updateMask?: FieldMask;
};

/**
 * Describes the message admiral.api.runner.v1.UpdateRunnerRequest.
 * Use `create(UpdateRunnerRequestSchema)` to create a new message.
 */
export const UpdateRunnerRequestSchema: GenMessage<UpdateRunnerRequest> = /*@__PURE__*/
  messageDesc(file_admiral_api_runner_v1_runner, 12);

/**
 * UpdateRunnerResponse contains the updated runner.
 *
 * @generated from message admiral.api.runner.v1.UpdateRunnerResponse
 */
export type UpdateRunnerResponse = Message<"admiral.api.runner.v1.UpdateRunnerResponse"> & {
  /**
   * The updated runner.
   *
   * @generated from field: admiral.api.runner.v1.Runner runner = 1;
   */
  runner?: Runner;
};

/**
 * Describes the message admiral.api.runner.v1.UpdateRunnerResponse.
 * Use `create(UpdateRunnerResponseSchema)` to create a new message.
 */
export const UpdateRunnerResponseSchema: GenMessage<UpdateRunnerResponse> = /*@__PURE__*/
  messageDesc(file_admiral_api_runner_v1_runner, 13);

/**
 * DeleteRunnerRequest identifies a runner to delete.
 *
 * @generated from message admiral.api.runner.v1.DeleteRunnerRequest
 */
export type DeleteRunnerRequest = Message<"admiral.api.runner.v1.DeleteRunnerRequest"> & {
  /**
   * The unique identifier of the runner to delete (UUID).
   * All associated agent tokens will be revoked.
   *
   * @generated from field: string runner_id = 1;
   */
  runnerId: string;
};

/**
 * Describes the message admiral.api.runner.v1.DeleteRunnerRequest.
 * Use `create(DeleteRunnerRequestSchema)` to create a new message.
 */
export const DeleteRunnerRequestSchema: GenMessage<DeleteRunnerRequest> = /*@__PURE__*/
  messageDesc(file_admiral_api_runner_v1_runner, 14);

/**
 * DeleteRunnerResponse is empty on success.
 *
 * @generated from message admiral.api.runner.v1.DeleteRunnerResponse
 */
export type DeleteRunnerResponse = Message<"admiral.api.runner.v1.DeleteRunnerResponse"> & {
};

/**
 * Describes the message admiral.api.runner.v1.DeleteRunnerResponse.
 * Use `create(DeleteRunnerResponseSchema)` to create a new message.
 */
export const DeleteRunnerResponseSchema: GenMessage<DeleteRunnerResponse> = /*@__PURE__*/
  messageDesc(file_admiral_api_runner_v1_runner, 15);

/**
 * GetRunnerStatusRequest identifies a runner whose status to retrieve.
 *
 * @generated from message admiral.api.runner.v1.GetRunnerStatusRequest
 */
export type GetRunnerStatusRequest = Message<"admiral.api.runner.v1.GetRunnerStatusRequest"> & {
  /**
   * The unique identifier of the runner (UUID).
   *
   * @generated from field: string runner_id = 1;
   */
  runnerId: string;
};

/**
 * Describes the message admiral.api.runner.v1.GetRunnerStatusRequest.
 * Use `create(GetRunnerStatusRequestSchema)` to create a new message.
 */
export const GetRunnerStatusRequestSchema: GenMessage<GetRunnerStatusRequest> = /*@__PURE__*/
  messageDesc(file_admiral_api_runner_v1_runner, 16);

/**
 * GetRunnerStatusResponse contains the server-derived health status and the
 * latest capacity snapshot. If no heartbeat has been received yet, the
 * health_status will be PENDING and status will be absent.
 *
 * @generated from message admiral.api.runner.v1.GetRunnerStatusResponse
 */
export type GetRunnerStatusResponse = Message<"admiral.api.runner.v1.GetRunnerStatusResponse"> & {
  /**
   * Server-derived health status based on heartbeat recency and capacity.
   *
   * @generated from field: admiral.api.runner.v1.RunnerHealthStatus health_status = 1;
   */
  healthStatus: RunnerHealthStatus;

  /**
   * Latest capacity snapshot from the runner. Absent if no heartbeat has
   * been received yet.
   *
   * @generated from field: admiral.api.runner.v1.RunnerStatus status = 2;
   */
  status?: RunnerStatus;

  /**
   * When the latest heartbeat was received.
   *
   * @generated from field: google.protobuf.Timestamp reported_at = 3;
   */
  reportedAt?: Timestamp;
};

/**
 * Describes the message admiral.api.runner.v1.GetRunnerStatusResponse.
 * Use `create(GetRunnerStatusResponseSchema)` to create a new message.
 */
export const GetRunnerStatusResponseSchema: GenMessage<GetRunnerStatusResponse> = /*@__PURE__*/
  messageDesc(file_admiral_api_runner_v1_runner, 17);

/**
 * CreateRunnerTokenRequest contains the parameters for creating a new AGT
 * bound to a runner.
 *
 * @generated from message admiral.api.runner.v1.CreateRunnerTokenRequest
 */
export type CreateRunnerTokenRequest = Message<"admiral.api.runner.v1.CreateRunnerTokenRequest"> & {
  /**
   * The runner to bind this token to (UUID).
   *
   * @generated from field: string runner_id = 1;
   */
  runnerId: string;

  /**
   * URL-safe, human-readable identifier for the token (e.g., "prod-runner-key").
   * Must be unique within the runner's tokens. Lowercase alphanumeric and
   * hyphens only.
   *
   * @generated from field: string name = 2;
   */
  name: string;

  /**
   * Optional expiration time. If unset, the token does not expire.
   *
   * @generated from field: google.protobuf.Timestamp expires_at = 3;
   */
  expiresAt?: Timestamp;
};

/**
 * Describes the message admiral.api.runner.v1.CreateRunnerTokenRequest.
 * Use `create(CreateRunnerTokenRequestSchema)` to create a new message.
 */
export const CreateRunnerTokenRequestSchema: GenMessage<CreateRunnerTokenRequest> = /*@__PURE__*/
  messageDesc(file_admiral_api_runner_v1_runner, 18);

/**
 * CreateRunnerTokenResponse contains the newly created AGT.
 *
 * @generated from message admiral.api.runner.v1.CreateRunnerTokenResponse
 */
export type CreateRunnerTokenResponse = Message<"admiral.api.runner.v1.CreateRunnerTokenResponse"> & {
  /**
   * The created token metadata. Scopes are auto-assigned for runner AGTs.
   *
   * @generated from field: admiral.common.v1.AccessToken access_token = 1;
   */
  accessToken?: AccessToken;

  /**
   * The raw token secret (e.g., "adm_agt_pL2mN5oQ8rS1..."). This value is
   * shown exactly once and cannot be retrieved again. Store it securely.
   *
   * @generated from field: string plain_text_token = 2;
   */
  plainTextToken: string;
};

/**
 * Describes the message admiral.api.runner.v1.CreateRunnerTokenResponse.
 * Use `create(CreateRunnerTokenResponseSchema)` to create a new message.
 */
export const CreateRunnerTokenResponseSchema: GenMessage<CreateRunnerTokenResponse> = /*@__PURE__*/
  messageDesc(file_admiral_api_runner_v1_runner, 19);

/**
 * ListRunnerTokensRequest contains pagination and filter parameters.
 *
 * @generated from message admiral.api.runner.v1.ListRunnerTokensRequest
 */
export type ListRunnerTokensRequest = Message<"admiral.api.runner.v1.ListRunnerTokensRequest"> & {
  /**
   * The runner to list tokens for (UUID).
   *
   * @generated from field: string runner_id = 1;
   */
  runnerId: string;

  /**
   * Filter expression using the PEG filter DSL.
   *
   * @generated from field: string filter = 2;
   */
  filter: string;

  /**
   * Maximum number of tokens to return per page.
   *
   * @generated from field: int32 page_size = 3;
   */
  pageSize: number;

  /**
   * Opaque pagination token from a previous response.
   *
   * @generated from field: string page_token = 4;
   */
  pageToken: string;
};

/**
 * Describes the message admiral.api.runner.v1.ListRunnerTokensRequest.
 * Use `create(ListRunnerTokensRequestSchema)` to create a new message.
 */
export const ListRunnerTokensRequestSchema: GenMessage<ListRunnerTokensRequest> = /*@__PURE__*/
  messageDesc(file_admiral_api_runner_v1_runner, 20);

/**
 * ListRunnerTokensResponse contains a page of runner AGT metadata.
 *
 * @generated from message admiral.api.runner.v1.ListRunnerTokensResponse
 */
export type ListRunnerTokensResponse = Message<"admiral.api.runner.v1.ListRunnerTokensResponse"> & {
  /**
   * The list of tokens. Token secrets are never included.
   *
   * @generated from field: repeated admiral.common.v1.AccessToken access_tokens = 1;
   */
  accessTokens: AccessToken[];

  /**
   * Pagination token for the next page. Empty when there are no more results.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;
};

/**
 * Describes the message admiral.api.runner.v1.ListRunnerTokensResponse.
 * Use `create(ListRunnerTokensResponseSchema)` to create a new message.
 */
export const ListRunnerTokensResponseSchema: GenMessage<ListRunnerTokensResponse> = /*@__PURE__*/
  messageDesc(file_admiral_api_runner_v1_runner, 21);

/**
 * GetRunnerTokenRequest identifies a runner AGT to retrieve.
 *
 * @generated from message admiral.api.runner.v1.GetRunnerTokenRequest
 */
export type GetRunnerTokenRequest = Message<"admiral.api.runner.v1.GetRunnerTokenRequest"> & {
  /**
   * The runner the token belongs to (UUID).
   *
   * @generated from field: string runner_id = 1;
   */
  runnerId: string;

  /**
   * The unique identifier of the token (UUID).
   *
   * @generated from field: string token_id = 2;
   */
  tokenId: string;
};

/**
 * Describes the message admiral.api.runner.v1.GetRunnerTokenRequest.
 * Use `create(GetRunnerTokenRequestSchema)` to create a new message.
 */
export const GetRunnerTokenRequestSchema: GenMessage<GetRunnerTokenRequest> = /*@__PURE__*/
  messageDesc(file_admiral_api_runner_v1_runner, 22);

/**
 * GetRunnerTokenResponse contains the requested runner AGT metadata.
 *
 * @generated from message admiral.api.runner.v1.GetRunnerTokenResponse
 */
export type GetRunnerTokenResponse = Message<"admiral.api.runner.v1.GetRunnerTokenResponse"> & {
  /**
   * The token metadata. The token secret is never included.
   *
   * @generated from field: admiral.common.v1.AccessToken access_token = 1;
   */
  accessToken?: AccessToken;
};

/**
 * Describes the message admiral.api.runner.v1.GetRunnerTokenResponse.
 * Use `create(GetRunnerTokenResponseSchema)` to create a new message.
 */
export const GetRunnerTokenResponseSchema: GenMessage<GetRunnerTokenResponse> = /*@__PURE__*/
  messageDesc(file_admiral_api_runner_v1_runner, 23);

/**
 * RevokeRunnerTokenRequest identifies a runner AGT to revoke.
 *
 * @generated from message admiral.api.runner.v1.RevokeRunnerTokenRequest
 */
export type RevokeRunnerTokenRequest = Message<"admiral.api.runner.v1.RevokeRunnerTokenRequest"> & {
  /**
   * The runner the token belongs to (UUID).
   *
   * @generated from field: string runner_id = 1;
   */
  runnerId: string;

  /**
   * The unique identifier of the token to revoke (UUID).
   *
   * @generated from field: string token_id = 2;
   */
  tokenId: string;
};

/**
 * Describes the message admiral.api.runner.v1.RevokeRunnerTokenRequest.
 * Use `create(RevokeRunnerTokenRequestSchema)` to create a new message.
 */
export const RevokeRunnerTokenRequestSchema: GenMessage<RevokeRunnerTokenRequest> = /*@__PURE__*/
  messageDesc(file_admiral_api_runner_v1_runner, 24);

/**
 * RevokeRunnerTokenResponse contains the revoked runner AGT metadata.
 *
 * @generated from message admiral.api.runner.v1.RevokeRunnerTokenResponse
 */
export type RevokeRunnerTokenResponse = Message<"admiral.api.runner.v1.RevokeRunnerTokenResponse"> & {
  /**
   * The token metadata with updated status.
   *
   * @generated from field: admiral.common.v1.AccessToken access_token = 1;
   */
  accessToken?: AccessToken;
};

/**
 * Describes the message admiral.api.runner.v1.RevokeRunnerTokenResponse.
 * Use `create(RevokeRunnerTokenResponseSchema)` to create a new message.
 */
export const RevokeRunnerTokenResponseSchema: GenMessage<RevokeRunnerTokenResponse> = /*@__PURE__*/
  messageDesc(file_admiral_api_runner_v1_runner, 25);

/**
 * HeartbeatRequest contains the runner's alive signal and current capacity.
 * The runner is identified by the AGT's binding — no runner_id is required.
 *
 * @generated from message admiral.api.runner.v1.HeartbeatRequest
 */
export type HeartbeatRequest = Message<"admiral.api.runner.v1.HeartbeatRequest"> & {
  /**
   * Current capacity and telemetry metrics.
   *
   * @generated from field: admiral.api.runner.v1.RunnerStatus status = 1;
   */
  status?: RunnerStatus;

  /**
   * Random UUID generated at process startup to distinguish multiple runner
   * instances sharing the same AGT. The server uses this to track heartbeats
   * per instance and aggregate capacity metrics across all instances of the
   * same runner. A new instance_id is generated each time the runner process
   * starts — it is not persisted across restarts.
   *
   * @generated from field: string instance_id = 2;
   */
  instanceId: string;
};

/**
 * Describes the message admiral.api.runner.v1.HeartbeatRequest.
 * Use `create(HeartbeatRequestSchema)` to create a new message.
 */
export const HeartbeatRequestSchema: GenMessage<HeartbeatRequest> = /*@__PURE__*/
  messageDesc(file_admiral_api_runner_v1_runner, 26);

/**
 * HeartbeatResponse acknowledges the heartbeat.
 *
 * @generated from message admiral.api.runner.v1.HeartbeatResponse
 */
export type HeartbeatResponse = Message<"admiral.api.runner.v1.HeartbeatResponse"> & {
  /**
   * Whether the heartbeat was accepted.
   *
   * @generated from field: bool ack = 1;
   */
  ack: boolean;

  /**
   * Server-controlled interval (in seconds) before the runner should send
   * its next heartbeat. Allows the server to adjust frequency dynamically.
   *
   * @generated from field: int32 next_heartbeat_seconds = 2;
   */
  nextHeartbeatSeconds: number;
};

/**
 * Describes the message admiral.api.runner.v1.HeartbeatResponse.
 * Use `create(HeartbeatResponseSchema)` to create a new message.
 */
export const HeartbeatResponseSchema: GenMessage<HeartbeatResponse> = /*@__PURE__*/
  messageDesc(file_admiral_api_runner_v1_runner, 27);

/**
 * ClaimJobRequest is sent by the runner to poll for available work.
 * The runner is identified by the AGT's binding — no runner_id is required.
 *
 * @generated from message admiral.api.runner.v1.ClaimJobRequest
 */
export type ClaimJobRequest = Message<"admiral.api.runner.v1.ClaimJobRequest"> & {
};

/**
 * Describes the message admiral.api.runner.v1.ClaimJobRequest.
 * Use `create(ClaimJobRequestSchema)` to create a new message.
 */
export const ClaimJobRequestSchema: GenMessage<ClaimJobRequest> = /*@__PURE__*/
  messageDesc(file_admiral_api_runner_v1_runner, 28);

/**
 * ClaimJobResponse contains the next job to execute, if any.
 *
 * @generated from message admiral.api.runner.v1.ClaimJobResponse
 */
export type ClaimJobResponse = Message<"admiral.api.runner.v1.ClaimJobResponse"> & {
  /**
   * The job to execute. Absent if no work is available — the runner should
   * wait and poll again after its configured interval.
   *
   * @generated from field: admiral.api.runner.v1.Job job = 1;
   */
  job?: Job;
};

/**
 * Describes the message admiral.api.runner.v1.ClaimJobResponse.
 * Use `create(ClaimJobResponseSchema)` to create a new message.
 */
export const ClaimJobResponseSchema: GenMessage<ClaimJobResponse> = /*@__PURE__*/
  messageDesc(file_admiral_api_runner_v1_runner, 29);

/**
 * GetJobBundleRequest identifies a job whose artifact bundle to fetch.
 *
 * @generated from message admiral.api.runner.v1.GetJobBundleRequest
 */
export type GetJobBundleRequest = Message<"admiral.api.runner.v1.GetJobBundleRequest"> & {
  /**
   * The job to fetch the bundle for (UUID).
   *
   * @generated from field: string job_id = 1;
   */
  jobId: string;
};

/**
 * Describes the message admiral.api.runner.v1.GetJobBundleRequest.
 * Use `create(GetJobBundleRequestSchema)` to create a new message.
 */
export const GetJobBundleRequestSchema: GenMessage<GetJobBundleRequest> = /*@__PURE__*/
  messageDesc(file_admiral_api_runner_v1_runner, 30);

/**
 * GetJobBundleResponse contains the rendered artifacts for execution.
 *
 * @generated from message admiral.api.runner.v1.GetJobBundleResponse
 */
export type GetJobBundleResponse = Message<"admiral.api.runner.v1.GetJobBundleResponse"> & {
  /**
   * The artifact bundle with everything needed to execute the TF operation.
   *
   * @generated from field: admiral.api.runner.v1.JobBundle bundle = 1;
   */
  bundle?: JobBundle;
};

/**
 * Describes the message admiral.api.runner.v1.GetJobBundleResponse.
 * Use `create(GetJobBundleResponseSchema)` to create a new message.
 */
export const GetJobBundleResponseSchema: GenMessage<GetJobBundleResponse> = /*@__PURE__*/
  messageDesc(file_admiral_api_runner_v1_runner, 31);

/**
 * ReportJobResultRequest contains the outcome of a completed job.
 *
 * @generated from message admiral.api.runner.v1.ReportJobResultRequest
 */
export type ReportJobResultRequest = Message<"admiral.api.runner.v1.ReportJobResultRequest"> & {
  /**
   * The job being reported on (UUID).
   *
   * @generated from field: string job_id = 1;
   */
  jobId: string;

  /**
   * The job result with status, outputs, and error information.
   *
   * @generated from field: admiral.api.runner.v1.JobResult result = 2;
   */
  result?: JobResult;
};

/**
 * Describes the message admiral.api.runner.v1.ReportJobResultRequest.
 * Use `create(ReportJobResultRequestSchema)` to create a new message.
 */
export const ReportJobResultRequestSchema: GenMessage<ReportJobResultRequest> = /*@__PURE__*/
  messageDesc(file_admiral_api_runner_v1_runner, 32);

/**
 * ReportJobResultResponse acknowledges the result.
 *
 * @generated from message admiral.api.runner.v1.ReportJobResultResponse
 */
export type ReportJobResultResponse = Message<"admiral.api.runner.v1.ReportJobResultResponse"> & {
  /**
   * Whether the result was accepted.
   *
   * @generated from field: bool ack = 1;
   */
  ack: boolean;
};

/**
 * Describes the message admiral.api.runner.v1.ReportJobResultResponse.
 * Use `create(ReportJobResultResponseSchema)` to create a new message.
 */
export const ReportJobResultResponseSchema: GenMessage<ReportJobResultResponse> = /*@__PURE__*/
  messageDesc(file_admiral_api_runner_v1_runner, 33);

/**
 * ListRunnerJobsRequest contains pagination and filter parameters for listing
 * jobs assigned to a specific runner.
 *
 * @generated from message admiral.api.runner.v1.ListRunnerJobsRequest
 */
export type ListRunnerJobsRequest = Message<"admiral.api.runner.v1.ListRunnerJobsRequest"> & {
  /**
   * The runner whose jobs to list (UUID).
   *
   * @generated from field: string runner_id = 1;
   */
  runnerId: string;

  /**
   * Filter expression using the PEG filter DSL.
   *
   * Common filter fields:
   *   - `status` — filter by job status.
   *   - `job_type` — filter by job type (PLAN, APPLY, etc.).
   *   - `deployment_id` — jobs for a specific deployment.
   *
   * @generated from field: string filter = 2;
   */
  filter: string;

  /**
   * Maximum number of jobs to return per page.
   *
   * @generated from field: int32 page_size = 3;
   */
  pageSize: number;

  /**
   * Opaque pagination token from a previous response.
   *
   * @generated from field: string page_token = 4;
   */
  pageToken: string;
};

/**
 * Describes the message admiral.api.runner.v1.ListRunnerJobsRequest.
 * Use `create(ListRunnerJobsRequestSchema)` to create a new message.
 */
export const ListRunnerJobsRequestSchema: GenMessage<ListRunnerJobsRequest> = /*@__PURE__*/
  messageDesc(file_admiral_api_runner_v1_runner, 34);

/**
 * ListRunnerJobsResponse contains a page of jobs.
 *
 * @generated from message admiral.api.runner.v1.ListRunnerJobsResponse
 */
export type ListRunnerJobsResponse = Message<"admiral.api.runner.v1.ListRunnerJobsResponse"> & {
  /**
   * The list of jobs, ordered from newest to oldest.
   *
   * @generated from field: repeated admiral.api.runner.v1.Job jobs = 1;
   */
  jobs: Job[];

  /**
   * Pagination token for the next page. Empty when there are no more results.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;
};

/**
 * Describes the message admiral.api.runner.v1.ListRunnerJobsResponse.
 * Use `create(ListRunnerJobsResponseSchema)` to create a new message.
 */
export const ListRunnerJobsResponseSchema: GenMessage<ListRunnerJobsResponse> = /*@__PURE__*/
  messageDesc(file_admiral_api_runner_v1_runner, 35);

/**
 * RunnerKind identifies the type of operations a runner executes.
 *
 * @generated from enum admiral.api.runner.v1.RunnerKind
 */
export enum RunnerKind {
  /**
   * Default value. Must not be used.
   *
   * @generated from enum value: RUNNER_KIND_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Executes Terraform plan, apply, and destroy operations.
   *
   * @generated from enum value: RUNNER_KIND_TERRAFORM = 1;
   */
  TERRAFORM = 1,

  /**
   * Executes workflow operations (CI/CD pipelines, custom scripts).
   *
   * @generated from enum value: RUNNER_KIND_WORKFLOW = 2;
   */
  WORKFLOW = 2,
}

/**
 * Describes the enum admiral.api.runner.v1.RunnerKind.
 */
export const RunnerKindSchema: GenEnum<RunnerKind> = /*@__PURE__*/
  enumDesc(file_admiral_api_runner_v1_runner, 0);

/**
 * RunnerHealthStatus represents the derived health state of a runner.
 * The status is computed from heartbeat recency and capacity metrics.
 *
 * @generated from enum admiral.api.runner.v1.RunnerHealthStatus
 */
export enum RunnerHealthStatus {
  /**
   * Default value. Must not be used.
   *
   * @generated from enum value: RUNNER_HEALTH_STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Runner record exists but no heartbeat has been received yet.
   *
   * @generated from enum value: RUNNER_HEALTH_STATUS_PENDING = 1;
   */
  PENDING = 1,

  /**
   * Heartbeat received within expected interval, runner operational.
   *
   * @generated from enum value: RUNNER_HEALTH_STATUS_HEALTHY = 2;
   */
  HEALTHY = 2,

  /**
   * Runner is operational but reporting capacity constraints (e.g.,
   * active jobs at or near max_concurrent_jobs).
   *
   * @generated from enum value: RUNNER_HEALTH_STATUS_DEGRADED = 3;
   */
  DEGRADED = 3,

  /**
   * No heartbeat received within 3x the heartbeat interval.
   *
   * @generated from enum value: RUNNER_HEALTH_STATUS_UNREACHABLE = 4;
   */
  UNREACHABLE = 4,
}

/**
 * Describes the enum admiral.api.runner.v1.RunnerHealthStatus.
 */
export const RunnerHealthStatusSchema: GenEnum<RunnerHealthStatus> = /*@__PURE__*/
  enumDesc(file_admiral_api_runner_v1_runner, 1);

/**
 * JobStatus represents the lifecycle state of a runner job.
 *
 * @generated from enum admiral.api.runner.v1.JobStatus
 */
export enum JobStatus {
  /**
   * Default value. Must not be used.
   *
   * @generated from enum value: JOB_STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Job has been created but not yet assigned to a runner.
   *
   * @generated from enum value: JOB_STATUS_PENDING = 1;
   */
  PENDING = 1,

  /**
   * Job has been assigned to a runner and is waiting to be claimed.
   *
   * @generated from enum value: JOB_STATUS_ASSIGNED = 2;
   */
  ASSIGNED = 2,

  /**
   * Job has been claimed by the runner and is actively executing.
   *
   * @generated from enum value: JOB_STATUS_RUNNING = 3;
   */
  RUNNING = 3,

  /**
   * Job completed successfully.
   *
   * @generated from enum value: JOB_STATUS_SUCCEEDED = 4;
   */
  SUCCEEDED = 4,

  /**
   * Job failed. See JobResult.error_message for details.
   *
   * @generated from enum value: JOB_STATUS_FAILED = 5;
   */
  FAILED = 5,

  /**
   * Job was cancelled (e.g., parent deployment was cancelled).
   *
   * @generated from enum value: JOB_STATUS_CANCELLED = 6;
   */
  CANCELLED = 6,
}

/**
 * Describes the enum admiral.api.runner.v1.JobStatus.
 */
export const JobStatusSchema: GenEnum<JobStatus> = /*@__PURE__*/
  enumDesc(file_admiral_api_runner_v1_runner, 2);

/**
 * JobType identifies the kind of Terraform operation a job executes.
 *
 * @generated from enum admiral.api.runner.v1.JobType
 */
export enum JobType {
  /**
   * Default value. Must not be used.
   *
   * @generated from enum value: JOB_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Generate a Terraform execution plan.
   *
   * @generated from enum value: JOB_TYPE_PLAN = 1;
   */
  PLAN = 1,

  /**
   * Apply a Terraform plan.
   *
   * @generated from enum value: JOB_TYPE_APPLY = 2;
   */
  APPLY = 2,

  /**
   * Generate a Terraform destroy plan.
   *
   * @generated from enum value: JOB_TYPE_DESTROY_PLAN = 3;
   */
  DESTROY_PLAN = 3,

  /**
   * Apply a Terraform destroy plan (tear down resources).
   *
   * @generated from enum value: JOB_TYPE_DESTROY_APPLY = 4;
   */
  DESTROY_APPLY = 4,
}

/**
 * Describes the enum admiral.api.runner.v1.JobType.
 */
export const JobTypeSchema: GenEnum<JobType> = /*@__PURE__*/
  enumDesc(file_admiral_api_runner_v1_runner, 3);

/**
 * JobPhase represents the current execution phase of a job as reported by the
 * runner's worker thread. Used in heartbeat payloads to give the server
 * visibility into job progress between ClaimJob and ReportJobResult.
 *
 * @generated from enum admiral.api.runner.v1.JobPhase
 */
export enum JobPhase {
  /**
   * Default value. Must not be used.
   *
   * @generated from enum value: JOB_PHASE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Downloading artifact bundle and setting up the workspace.
   *
   * @generated from enum value: JOB_PHASE_INITIALIZING = 1;
   */
  INITIALIZING = 1,

  /**
   * Running `terraform plan` (or `tofu plan`).
   *
   * @generated from enum value: JOB_PHASE_PLANNING = 2;
   */
  PLANNING = 2,

  /**
   * Running `terraform apply` (or `tofu apply`).
   *
   * @generated from enum value: JOB_PHASE_APPLYING = 3;
   */
  APPLYING = 3,

  /**
   * Uploading results and cleaning up the workspace.
   *
   * @generated from enum value: JOB_PHASE_FINALIZING = 4;
   */
  FINALIZING = 4,
}

/**
 * Describes the enum admiral.api.runner.v1.JobPhase.
 */
export const JobPhaseSchema: GenEnum<JobPhase> = /*@__PURE__*/
  enumDesc(file_admiral_api_runner_v1_runner, 4);

/**
 * RunnerAPI manages infrastructure execution runners and their jobs.
 *
 * Runners are the execution plane for infrastructure operations (Terraform
 * plan, apply, destroy). Administrators create runners via CreateRunner,
 * which returns an Agent Token (AGT) for deploying the runner binary.
 * Once the runner boots and begins heartbeating, the server transitions
 * its health from PENDING to HEALTHY and the runner can start claiming jobs.
 *
 * The job lifecycle bridges Deployments and Runners:
 *   1. CreateDeployment resolves components and creates Revisions.
 *   2. For infrastructure revisions, the server creates a Job and assigns it
 *      to the environment's configured runner.
 *   3. The runner calls ClaimJob → GetJobBundle → executes TF → ReportJobResult.
 *   4. ReportJobResult transitions the parent Revision status.
 *
 * Admin routes follow /v1/runners/... (plural, with IDs).
 * Runner-facing routes use /v1/runner/... (singular, no ID — derived from
 * the AGT binding), matching the cluster agent pattern.
 *
 * All operations delegate to the platform RunnerAPI. The facade resolves the
 * caller's identity (user JWT or AGT → runner_id) and forwards.
 *
 * ---------------------------------------------------------------------------
 * Admin CRUD
 * ---------------------------------------------------------------------------
 *
 * @generated from service admiral.api.runner.v1.RunnerAPI
 */
export const RunnerAPI: GenService<{
  /**
   * CreateRunner creates a new runner record within the caller's tenant and
   * generates an initial Agent Token (AGT). The runner starts in PENDING
   * health status until it begins heartbeating.
   *
   * The response includes a `plain_text_token` — the raw AGT secret shown
   * exactly once. Deploy this token to the runner binary for authentication.
   *
   * Scope: `runner:write`
   *
   * @generated from rpc admiral.api.runner.v1.RunnerAPI.CreateRunner
   */
  createRunner: {
    methodKind: "unary";
    input: typeof CreateRunnerRequestSchema;
    output: typeof CreateRunnerResponseSchema;
  },
  /**
   * GetRunner retrieves a runner by ID.
   *
   * Returns the Runner record with its server-derived health_status. For
   * detailed telemetry (active jobs, capacity), use GetRunnerStatus instead.
   *
   * Scope: `runner:read`
   *
   * @generated from rpc admiral.api.runner.v1.RunnerAPI.GetRunner
   */
  getRunner: {
    methodKind: "unary";
    input: typeof GetRunnerRequestSchema;
    output: typeof GetRunnerResponseSchema;
  },
  /**
   * ListRunners returns a paginated list of runners within the caller's tenant.
   *
   * Scope: `runner:read`
   *
   * @generated from rpc admiral.api.runner.v1.RunnerAPI.ListRunners
   */
  listRunners: {
    methodKind: "unary";
    input: typeof ListRunnersRequestSchema;
    output: typeof ListRunnersResponseSchema;
  },
  /**
   * UpdateRunner updates a runner's mutable fields.
   * Use the `update_mask` to specify which fields to update.
   *
   * Scope: `runner:write`
   *
   * @generated from rpc admiral.api.runner.v1.RunnerAPI.UpdateRunner
   */
  updateRunner: {
    methodKind: "unary";
    input: typeof UpdateRunnerRequestSchema;
    output: typeof UpdateRunnerResponseSchema;
  },
  /**
   * DeleteRunner permanently deletes a runner record and revokes all
   * associated agent tokens. Any jobs assigned to this runner that are
   * not yet completed will be failed. This action cannot be undone.
   *
   * Scope: `runner:write`
   *
   * @generated from rpc admiral.api.runner.v1.RunnerAPI.DeleteRunner
   */
  deleteRunner: {
    methodKind: "unary";
    input: typeof DeleteRunnerRequestSchema;
    output: typeof DeleteRunnerResponseSchema;
  },
  /**
   * GetRunnerStatus retrieves the current telemetry snapshot for a runner.
   * Returns the latest capacity metrics reported via Heartbeat.
   *
   * Returns NOT_FOUND if the runner does not exist. If the runner exists but
   * has not heartbeated yet, health_status will be PENDING and status will
   * be absent.
   *
   * Scope: `runner:read`
   *
   * @generated from rpc admiral.api.runner.v1.RunnerAPI.GetRunnerStatus
   */
  getRunnerStatus: {
    methodKind: "unary";
    input: typeof GetRunnerStatusRequestSchema;
    output: typeof GetRunnerStatusResponseSchema;
  },
  /**
   * CreateRunnerToken creates a new Agent Token (AGT) bound to the specified
   * runner. Scopes are auto-assigned and cannot be overridden. The response
   * includes the raw token secret, which is shown exactly once.
   *
   * Use this to create additional AGTs for an existing runner (e.g., for
   * zero-downtime token rotation). The initial AGT is created automatically
   * by CreateRunner.
   *
   * Scope: `runner:write`
   *
   * @generated from rpc admiral.api.runner.v1.RunnerAPI.CreateRunnerToken
   */
  createRunnerToken: {
    methodKind: "unary";
    input: typeof CreateRunnerTokenRequestSchema;
    output: typeof CreateRunnerTokenResponseSchema;
  },
  /**
   * ListRunnerTokens returns a paginated list of AGTs bound to the specified
   * runner. Token secrets are never included.
   *
   * Scope: `runner:read`
   *
   * @generated from rpc admiral.api.runner.v1.RunnerAPI.ListRunnerTokens
   */
  listRunnerTokens: {
    methodKind: "unary";
    input: typeof ListRunnerTokensRequestSchema;
    output: typeof ListRunnerTokensResponseSchema;
  },
  /**
   * GetRunnerToken retrieves a single AGT by ID.
   * Returns metadata only — the token secret is never included.
   *
   * Scope: `runner:read`
   *
   * @generated from rpc admiral.api.runner.v1.RunnerAPI.GetRunnerToken
   */
  getRunnerToken: {
    methodKind: "unary";
    input: typeof GetRunnerTokenRequestSchema;
    output: typeof GetRunnerTokenResponseSchema;
  },
  /**
   * RevokeRunnerToken permanently revokes an AGT bound to this runner.
   * The runner will receive a 401 on its next request. If this is the only
   * active AGT for the runner, the runner will become disconnected.
   *
   * Scope: `runner:write`
   *
   * @generated from rpc admiral.api.runner.v1.RunnerAPI.RevokeRunnerToken
   */
  revokeRunnerToken: {
    methodKind: "unary";
    input: typeof RevokeRunnerTokenRequestSchema;
    output: typeof RevokeRunnerTokenResponseSchema;
  },
  /**
   * Heartbeat reports that the runner is alive and includes current capacity
   * metrics. The server uses heartbeat recency to derive health status.
   *
   * The runner is identified by the agent token — the server resolves the
   * runner from the AGT's binding. No runner_id is required in the request.
   *
   * This endpoint is runner-facing and restricted to agent tokens.
   *
   * Scope: `runner:exec` | Token types: `agt`
   *
   * @generated from rpc admiral.api.runner.v1.RunnerAPI.Heartbeat
   */
  heartbeat: {
    methodKind: "unary";
    input: typeof HeartbeatRequestSchema;
    output: typeof HeartbeatResponseSchema;
  },
  /**
   * ClaimJob polls for the next job assigned to this runner. Returns the job
   * metadata if work is available, or an empty response if no jobs are
   * pending. The runner should call this on a polling interval.
   *
   * The runner is identified by the agent token — no runner_id is required.
   *
   * This endpoint is runner-facing and restricted to agent tokens.
   *
   * Scope: `runner:exec` | Token types: `agt`
   *
   * @generated from rpc admiral.api.runner.v1.RunnerAPI.ClaimJob
   */
  claimJob: {
    methodKind: "unary";
    input: typeof ClaimJobRequestSchema;
    output: typeof ClaimJobResponseSchema;
  },
  /**
   * GetJobBundle fetches the rendered artifacts for a claimed job. Separated
   * from ClaimJob to keep the claim response lightweight — the runner first
   * claims a job, then fetches the (potentially large) artifact bundle.
   *
   * The bundle contains everything the runner needs to execute the Terraform
   * operation: rendered .tf files, resolved variables, provider configuration,
   * backend configuration, and the required Terraform version.
   *
   * This endpoint is runner-facing and restricted to agent tokens.
   *
   * Scope: `runner:exec` | Token types: `agt`
   *
   * @generated from rpc admiral.api.runner.v1.RunnerAPI.GetJobBundle
   */
  getJobBundle: {
    methodKind: "unary";
    input: typeof GetJobBundleRequestSchema;
    output: typeof GetJobBundleResponseSchema;
  },
  /**
   * ReportJobResult reports the outcome of a completed job. The runner sends
   * plan output (for plan jobs), apply results, error messages, and log
   * references. The server transitions the parent Revision status accordingly
   * (e.g., PLANNING→APPLYING, APPLYING→SUCCEEDED/FAILED).
   *
   * This endpoint is runner-facing and restricted to agent tokens.
   *
   * Scope: `runner:exec` | Token types: `agt`
   *
   * @generated from rpc admiral.api.runner.v1.RunnerAPI.ReportJobResult
   */
  reportJobResult: {
    methodKind: "unary";
    input: typeof ReportJobResultRequestSchema;
    output: typeof ReportJobResultResponseSchema;
  },
  /**
   * ListRunnerJobs returns a paginated list of jobs assigned to a runner.
   * Provides admin read-only visibility into runner workload.
   *
   * Scope: `runner:read`
   *
   * @generated from rpc admiral.api.runner.v1.RunnerAPI.ListRunnerJobs
   */
  listRunnerJobs: {
    methodKind: "unary";
    input: typeof ListRunnerJobsRequestSchema;
    output: typeof ListRunnerJobsResponseSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_admiral_api_runner_v1_runner, 0);

