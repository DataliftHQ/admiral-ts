// @generated by protoc-gen-es v2.11.0 with parameter "target=ts"
// @generated from file admiral/api/cluster/v1/cluster.proto (package admiral.api.cluster.v1, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv2";
import { fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv2";
import type { Cluster, ClusterHealthStatus, ClusterStatus, Workload, WorkloadEvent, WorkloadStatus } from "../../../cluster/v1/cluster_pb";
import { file_admiral_cluster_v1_cluster } from "../../../cluster/v1/cluster_pb";
import { file_admiral_common_v1_annotations } from "../../../common/v1/annotations_pb";
import type { AccessToken } from "../../../common/v1/token_pb";
import { file_admiral_common_v1_token } from "../../../common/v1/token_pb";
import { file_buf_validate_validate } from "../../../../buf/validate/validate_pb";
import { file_google_api_annotations } from "../../../../google/api/annotations_pb";
import type { FieldMask, Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_field_mask, file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file admiral/api/cluster/v1/cluster.proto.
 */
export const file_admiral_api_cluster_v1_cluster: GenFile = /*@__PURE__*/
  fileDesc("CiRhZG1pcmFsL2FwaS9jbHVzdGVyL3YxL2NsdXN0ZXIucHJvdG8SFmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEi6AEKFENyZWF0ZUNsdXN0ZXJSZXF1ZXN0EjgKBG5hbWUYASABKAlCKrpIJ3IlGD8yIV5bYS16XShbYS16MC05LV17MCw2MX1bYS16MC05XSk/JBIdCgtkZXNjcmlwdGlvbhgCIAEoCUIIukgFcgMYgAgSSAoGbGFiZWxzGAMgAygLMjguYWRtaXJhbC5hcGkuY2x1c3Rlci52MS5DcmVhdGVDbHVzdGVyUmVxdWVzdC5MYWJlbHNFbnRyeRotCgtMYWJlbHNFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBIl8KFUNyZWF0ZUNsdXN0ZXJSZXNwb25zZRIsCgdjbHVzdGVyGAEgASgLMhsuYWRtaXJhbC5jbHVzdGVyLnYxLkNsdXN0ZXISGAoQcGxhaW5fdGV4dF90b2tlbhgCIAEoCSIxChFHZXRDbHVzdGVyUmVxdWVzdBIcCgpjbHVzdGVyX2lkGAEgASgJQgi6SAVyA7ABASJCChJHZXRDbHVzdGVyUmVzcG9uc2USLAoHY2x1c3RlchgBIAEoCzIbLmFkbWlyYWwuY2x1c3Rlci52MS5DbHVzdGVyIkwKE0xpc3RDbHVzdGVyc1JlcXVlc3QSDgoGZmlsdGVyGAEgASgJEhEKCXBhZ2Vfc2l6ZRgCIAEoBRISCgpwYWdlX3Rva2VuGAMgASgJIl4KFExpc3RDbHVzdGVyc1Jlc3BvbnNlEi0KCGNsdXN0ZXJzGAEgAygLMhsuYWRtaXJhbC5jbHVzdGVyLnYxLkNsdXN0ZXISFwoPbmV4dF9wYWdlX3Rva2VuGAIgASgJIn0KFFVwZGF0ZUNsdXN0ZXJSZXF1ZXN0EjQKB2NsdXN0ZXIYASABKAsyGy5hZG1pcmFsLmNsdXN0ZXIudjEuQ2x1c3RlckIGukgDyAEBEi8KC3VwZGF0ZV9tYXNrGAIgASgLMhouZ29vZ2xlLnByb3RvYnVmLkZpZWxkTWFzayJFChVVcGRhdGVDbHVzdGVyUmVzcG9uc2USLAoHY2x1c3RlchgBIAEoCzIbLmFkbWlyYWwuY2x1c3Rlci52MS5DbHVzdGVyIjQKFERlbGV0ZUNsdXN0ZXJSZXF1ZXN0EhwKCmNsdXN0ZXJfaWQYASABKAlCCLpIBXIDsAEBIhcKFURlbGV0ZUNsdXN0ZXJSZXNwb25zZSI3ChdHZXRDbHVzdGVyU3RhdHVzUmVxdWVzdBIcCgpjbHVzdGVyX2lkGAEgASgJQgi6SAVyA7ABASK+AQoYR2V0Q2x1c3RlclN0YXR1c1Jlc3BvbnNlEj4KDWhlYWx0aF9zdGF0dXMYASABKA4yJy5hZG1pcmFsLmNsdXN0ZXIudjEuQ2x1c3RlckhlYWx0aFN0YXR1cxIxCgZzdGF0dXMYAiABKAsyIS5hZG1pcmFsLmNsdXN0ZXIudjEuQ2x1c3RlclN0YXR1cxIvCgtyZXBvcnRlZF9hdBgDIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAikAIKGlJlcG9ydENsdXN0ZXJTdGF0dXNSZXF1ZXN0EhwKCmNsdXN0ZXJfaWQYASABKAlCCLpIBXIDsAEBEjkKBnN0YXR1cxgCIAEoCzIhLmFkbWlyYWwuY2x1c3Rlci52MS5DbHVzdGVyU3RhdHVzQga6SAPIAQESNQoJd29ya2xvYWRzGAMgAygLMiIuYWRtaXJhbC5jbHVzdGVyLnYxLldvcmtsb2FkU3RhdHVzEjEKBmV2ZW50cxgEIAMoCzIhLmFkbWlyYWwuY2x1c3Rlci52MS5Xb3JrbG9hZEV2ZW50Ei8KC3JlcG9ydGVkX2F0GAUgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCJFChtSZXBvcnRDbHVzdGVyU3RhdHVzUmVzcG9uc2USCwoDYWNrGAEgASgIEhkKEW5leHRfcHVzaF9zZWNvbmRzGAIgASgFImsKFExpc3RXb3JrbG9hZHNSZXF1ZXN0EhwKCmNsdXN0ZXJfaWQYASABKAlCCLpIBXIDsAEBEg4KBmZpbHRlchgCIAEoCRIRCglwYWdlX3NpemUYAyABKAUSEgoKcGFnZV90b2tlbhgEIAEoCSJhChVMaXN0V29ya2xvYWRzUmVzcG9uc2USLwoJd29ya2xvYWRzGAEgAygLMhwuYWRtaXJhbC5jbHVzdGVyLnYxLldvcmtsb2FkEhcKD25leHRfcGFnZV90b2tlbhgCIAEoCSKjAQobUmVwb3J0V29ya2xvYWRTdGF0dXNSZXF1ZXN0EhwKCmNsdXN0ZXJfaWQYASABKAlCCLpIBXIDsAEBEjUKCXdvcmtsb2FkcxgCIAMoCzIiLmFkbWlyYWwuY2x1c3Rlci52MS5Xb3JrbG9hZFN0YXR1cxIvCgtyZXBvcnRlZF9hdBgDIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAiKwocUmVwb3J0V29ya2xvYWRTdGF0dXNSZXNwb25zZRILCgNhY2sYASABKAgipgEKGUNyZWF0ZUNsdXN0ZXJUb2tlblJlcXVlc3QSHAoKY2x1c3Rlcl9pZBgBIAEoCUIIukgFcgOwAQESOwoEbmFtZRgCIAEoCUItukgqcigQARj/ATIhXlthLXpdKFthLXowLTktXXswLDYxfVthLXowLTldKT8kEi4KCmV4cGlyZXNfYXQYAyABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wImwKGkNyZWF0ZUNsdXN0ZXJUb2tlblJlc3BvbnNlEjQKDGFjY2Vzc190b2tlbhgBIAEoCzIeLmFkbWlyYWwuY29tbW9uLnYxLkFjY2Vzc1Rva2VuEhgKEHBsYWluX3RleHRfdG9rZW4YAiABKAkibwoYTGlzdENsdXN0ZXJUb2tlbnNSZXF1ZXN0EhwKCmNsdXN0ZXJfaWQYASABKAlCCLpIBXIDsAEBEhEKCXBhZ2Vfc2l6ZRgCIAEoBRISCgpwYWdlX3Rva2VuGAMgASgJEg4KBmZpbHRlchgEIAEoCSJrChlMaXN0Q2x1c3RlclRva2Vuc1Jlc3BvbnNlEjUKDWFjY2Vzc190b2tlbnMYASADKAsyHi5hZG1pcmFsLmNvbW1vbi52MS5BY2Nlc3NUb2tlbhIXCg9uZXh0X3BhZ2VfdG9rZW4YAiABKAkiUgoWR2V0Q2x1c3RlclRva2VuUmVxdWVzdBIcCgpjbHVzdGVyX2lkGAEgASgJQgi6SAVyA7ABARIaCgh0b2tlbl9pZBgCIAEoCUIIukgFcgOwAQEiTwoXR2V0Q2x1c3RlclRva2VuUmVzcG9uc2USNAoMYWNjZXNzX3Rva2VuGAEgASgLMh4uYWRtaXJhbC5jb21tb24udjEuQWNjZXNzVG9rZW4iVQoZUmV2b2tlQ2x1c3RlclRva2VuUmVxdWVzdBIcCgpjbHVzdGVyX2lkGAEgASgJQgi6SAVyA7ABARIaCgh0b2tlbl9pZBgCIAEoCUIIukgFcgOwAQEiUgoaUmV2b2tlQ2x1c3RlclRva2VuUmVzcG9uc2USNAoMYWNjZXNzX3Rva2VuGAEgASgLMh4uYWRtaXJhbC5jb21tb24udjEuQWNjZXNzVG9rZW4yoRIKCkNsdXN0ZXJBUEkSmAEKDUNyZWF0ZUNsdXN0ZXISLC5hZG1pcmFsLmFwaS5jbHVzdGVyLnYxLkNyZWF0ZUNsdXN0ZXJSZXF1ZXN0Gi0uYWRtaXJhbC5hcGkuY2x1c3Rlci52MS5DcmVhdGVDbHVzdGVyUmVzcG9uc2UiKqKXJA8KDWNsdXN0ZXI6d3JpdGWC0+STAhE6ASoiDC92MS9jbHVzdGVycxKYAQoKR2V0Q2x1c3RlchIpLmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEuR2V0Q2x1c3RlclJlcXVlc3QaKi5hZG1pcmFsLmFwaS5jbHVzdGVyLnYxLkdldENsdXN0ZXJSZXNwb25zZSIzopckDgoMY2x1c3RlcjpyZWFkgtPkkwIbEhkvdjEvY2x1c3RlcnMve2NsdXN0ZXJfaWR9ErEBChBHZXRDbHVzdGVyU3RhdHVzEi8uYWRtaXJhbC5hcGkuY2x1c3Rlci52MS5HZXRDbHVzdGVyU3RhdHVzUmVxdWVzdBowLmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEuR2V0Q2x1c3RlclN0YXR1c1Jlc3BvbnNlIjqilyQOCgxjbHVzdGVyOnJlYWSC0+STAiISIC92MS9jbHVzdGVycy97Y2x1c3Rlcl9pZH0vc3RhdHVzEpEBCgxMaXN0Q2x1c3RlcnMSKy5hZG1pcmFsLmFwaS5jbHVzdGVyLnYxLkxpc3RDbHVzdGVyc1JlcXVlc3QaLC5hZG1pcmFsLmFwaS5jbHVzdGVyLnYxLkxpc3RDbHVzdGVyc1Jlc3BvbnNlIiailyQOCgxjbHVzdGVyOnJlYWSC0+STAg4SDC92MS9jbHVzdGVycxKlAQoNVXBkYXRlQ2x1c3RlchIsLmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEuVXBkYXRlQ2x1c3RlclJlcXVlc3QaLS5hZG1pcmFsLmFwaS5jbHVzdGVyLnYxLlVwZGF0ZUNsdXN0ZXJSZXNwb25zZSI3opckDwoNY2x1c3Rlcjp3cml0ZYLT5JMCHjoBKjIZL3YxL2NsdXN0ZXJzL3tjbHVzdGVyLmlkfRKiAQoNRGVsZXRlQ2x1c3RlchIsLmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEuRGVsZXRlQ2x1c3RlclJlcXVlc3QaLS5hZG1pcmFsLmFwaS5jbHVzdGVyLnYxLkRlbGV0ZUNsdXN0ZXJSZXNwb25zZSI0opckDwoNY2x1c3Rlcjp3cml0ZYLT5JMCGyoZL3YxL2NsdXN0ZXJzL3tjbHVzdGVyX2lkfRK7AQoSQ3JlYXRlQ2x1c3RlclRva2VuEjEuYWRtaXJhbC5hcGkuY2x1c3Rlci52MS5DcmVhdGVDbHVzdGVyVG9rZW5SZXF1ZXN0GjIuYWRtaXJhbC5hcGkuY2x1c3Rlci52MS5DcmVhdGVDbHVzdGVyVG9rZW5SZXNwb25zZSI+opckDwoNY2x1c3Rlcjp3cml0ZYLT5JMCJToBKiIgL3YxL2NsdXN0ZXJzL3tjbHVzdGVyX2lkfS90b2tlbnMStAEKEUxpc3RDbHVzdGVyVG9rZW5zEjAuYWRtaXJhbC5hcGkuY2x1c3Rlci52MS5MaXN0Q2x1c3RlclRva2Vuc1JlcXVlc3QaMS5hZG1pcmFsLmFwaS5jbHVzdGVyLnYxLkxpc3RDbHVzdGVyVG9rZW5zUmVzcG9uc2UiOqKXJA4KDGNsdXN0ZXI6cmVhZILT5JMCIhIgL3YxL2NsdXN0ZXJzL3tjbHVzdGVyX2lkfS90b2tlbnMSuQEKD0dldENsdXN0ZXJUb2tlbhIuLmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEuR2V0Q2x1c3RlclRva2VuUmVxdWVzdBovLmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEuR2V0Q2x1c3RlclRva2VuUmVzcG9uc2UiRaKXJA4KDGNsdXN0ZXI6cmVhZILT5JMCLRIrL3YxL2NsdXN0ZXJzL3tjbHVzdGVyX2lkfS90b2tlbnMve3Rva2VuX2lkfRLNAQoSUmV2b2tlQ2x1c3RlclRva2VuEjEuYWRtaXJhbC5hcGkuY2x1c3Rlci52MS5SZXZva2VDbHVzdGVyVG9rZW5SZXF1ZXN0GjIuYWRtaXJhbC5hcGkuY2x1c3Rlci52MS5SZXZva2VDbHVzdGVyVG9rZW5SZXNwb25zZSJQopckDwoNY2x1c3Rlcjp3cml0ZYLT5JMCNzoBKiIyL3YxL2NsdXN0ZXJzL3tjbHVzdGVyX2lkfS90b2tlbnMve3Rva2VuX2lkfS9yZXZva2USxAEKE1JlcG9ydENsdXN0ZXJTdGF0dXMSMi5hZG1pcmFsLmFwaS5jbHVzdGVyLnYxLlJlcG9ydENsdXN0ZXJTdGF0dXNSZXF1ZXN0GjMuYWRtaXJhbC5hcGkuY2x1c3Rlci52MS5SZXBvcnRDbHVzdGVyU3RhdHVzUmVzcG9uc2UiRKKXJBUKDmNsdXN0ZXI6c3RhdHVzEgNhZ3SC0+STAiU6ASoiIC92MS9jbHVzdGVycy97Y2x1c3Rlcl9pZH0vc3RhdHVzEqsBCg1MaXN0V29ya2xvYWRzEiwuYWRtaXJhbC5hcGkuY2x1c3Rlci52MS5MaXN0V29ya2xvYWRzUmVxdWVzdBotLmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEuTGlzdFdvcmtsb2Fkc1Jlc3BvbnNlIj2ilyQOCgxjbHVzdGVyOnJlYWSC0+STAiUSIy92MS9jbHVzdGVycy97Y2x1c3Rlcl9pZH0vd29ya2xvYWRzEtEBChRSZXBvcnRXb3JrbG9hZFN0YXR1cxIzLmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEuUmVwb3J0V29ya2xvYWRTdGF0dXNSZXF1ZXN0GjQuYWRtaXJhbC5hcGkuY2x1c3Rlci52MS5SZXBvcnRXb3JrbG9hZFN0YXR1c1Jlc3BvbnNlIk6ilyQVCg5jbHVzdGVyOnN0YXR1cxIDYWd0gtPkkwIvOgEqIiovdjEvY2x1c3RlcnMve2NsdXN0ZXJfaWR9L3dvcmtsb2Fkcy9zdGF0dXNC3wEKGmNvbS5hZG1pcmFsLmFwaS5jbHVzdGVyLnYxQgxDbHVzdGVyUHJvdG9QAVo4Z28uYWRtaXJhbC5pby9zZGsvcHJvdG8vYWRtaXJhbC9hcGkvY2x1c3Rlci92MTtjbHVzdGVydjGiAgNBQUOqAhZBZG1pcmFsLkFwaS5DbHVzdGVyLlYxygIWQWRtaXJhbFxBcGlcQ2x1c3RlclxWMeICIkFkbWlyYWxcQXBpXENsdXN0ZXJcVjFcR1BCTWV0YWRhdGHqAhlBZG1pcmFsOjpBcGk6OkNsdXN0ZXI6OlYxYgZwcm90bzM", [file_admiral_cluster_v1_cluster, file_admiral_common_v1_annotations, file_admiral_common_v1_token, file_buf_validate_validate, file_google_api_annotations, file_google_protobuf_field_mask, file_google_protobuf_timestamp]);

/**
 * CreateClusterRequest contains the parameters for creating a new cluster.
 *
 * @generated from message admiral.api.cluster.v1.CreateClusterRequest
 */
export type CreateClusterRequest = Message<"admiral.api.cluster.v1.CreateClusterRequest"> & {
  /**
   * URL-safe, human-readable identifier (e.g., "prod-us-east-1"). Must be
   * unique within the tenant. Lowercase alphanumeric and hyphens only.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Optional longer-form description of the cluster's purpose.
   *
   * @generated from field: string description = 2;
   */
  description: string;

  /**
   * Arbitrary key-value labels for organizing and filtering clusters
   * (e.g., `{"region": "us-east-1", "cloud": "aws"}`).
   *
   * @generated from field: map<string, string> labels = 3;
   */
  labels: { [key: string]: string };
};

/**
 * Describes the message admiral.api.cluster.v1.CreateClusterRequest.
 * Use `create(CreateClusterRequestSchema)` to create a new message.
 */
export const CreateClusterRequestSchema: GenMessage<CreateClusterRequest> = /*@__PURE__*/
  messageDesc(file_admiral_api_cluster_v1_cluster, 0);

/**
 * CreateClusterResponse contains the newly created cluster and its initial
 * Agent Token (AGT).
 *
 * @generated from message admiral.api.cluster.v1.CreateClusterResponse
 */
export type CreateClusterResponse = Message<"admiral.api.cluster.v1.CreateClusterResponse"> & {
  /**
   * The created cluster. Health status will be PENDING until an agent connects
   * and calls AgentAPI.RegisterAgent.
   *
   * @generated from field: admiral.cluster.v1.Cluster cluster = 1;
   */
  cluster?: Cluster;

  /**
   * The raw Agent Token secret (e.g., "adm_agt_pL2mN5oQ8rS1..."). This value
   * is shown exactly once and cannot be retrieved again. Deploy this token to
   * the K8s agent for authentication.
   *
   * To create additional tokens (e.g., for rotation), use
   * CreateClusterToken.
   *
   * @generated from field: string plain_text_token = 2;
   */
  plainTextToken: string;
};

/**
 * Describes the message admiral.api.cluster.v1.CreateClusterResponse.
 * Use `create(CreateClusterResponseSchema)` to create a new message.
 */
export const CreateClusterResponseSchema: GenMessage<CreateClusterResponse> = /*@__PURE__*/
  messageDesc(file_admiral_api_cluster_v1_cluster, 1);

/**
 * GetClusterRequest identifies a cluster to retrieve.
 *
 * @generated from message admiral.api.cluster.v1.GetClusterRequest
 */
export type GetClusterRequest = Message<"admiral.api.cluster.v1.GetClusterRequest"> & {
  /**
   * The unique identifier of the cluster (UUID).
   *
   * @generated from field: string cluster_id = 1;
   */
  clusterId: string;
};

/**
 * Describes the message admiral.api.cluster.v1.GetClusterRequest.
 * Use `create(GetClusterRequestSchema)` to create a new message.
 */
export const GetClusterRequestSchema: GenMessage<GetClusterRequest> = /*@__PURE__*/
  messageDesc(file_admiral_api_cluster_v1_cluster, 2);

/**
 * GetClusterResponse contains the cluster record.
 *
 * @generated from message admiral.api.cluster.v1.GetClusterResponse
 */
export type GetClusterResponse = Message<"admiral.api.cluster.v1.GetClusterResponse"> & {
  /**
   * The cluster record, including server-derived health_status.
   *
   * @generated from field: admiral.cluster.v1.Cluster cluster = 1;
   */
  cluster?: Cluster;
};

/**
 * Describes the message admiral.api.cluster.v1.GetClusterResponse.
 * Use `create(GetClusterResponseSchema)` to create a new message.
 */
export const GetClusterResponseSchema: GenMessage<GetClusterResponse> = /*@__PURE__*/
  messageDesc(file_admiral_api_cluster_v1_cluster, 3);

/**
 * ListClustersRequest contains pagination and filter parameters.
 *
 * @generated from message admiral.api.cluster.v1.ListClustersRequest
 */
export type ListClustersRequest = Message<"admiral.api.cluster.v1.ListClustersRequest"> & {
  /**
   * Filter expression using the PEG filter DSL.
   *
   * @generated from field: string filter = 1;
   */
  filter: string;

  /**
   * Maximum number of clusters to return per page.
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize: number;

  /**
   * Opaque pagination token from a previous response.
   *
   * @generated from field: string page_token = 3;
   */
  pageToken: string;
};

/**
 * Describes the message admiral.api.cluster.v1.ListClustersRequest.
 * Use `create(ListClustersRequestSchema)` to create a new message.
 */
export const ListClustersRequestSchema: GenMessage<ListClustersRequest> = /*@__PURE__*/
  messageDesc(file_admiral_api_cluster_v1_cluster, 4);

/**
 * ListClustersResponse contains a page of clusters.
 *
 * @generated from message admiral.api.cluster.v1.ListClustersResponse
 */
export type ListClustersResponse = Message<"admiral.api.cluster.v1.ListClustersResponse"> & {
  /**
   * The list of clusters.
   *
   * @generated from field: repeated admiral.cluster.v1.Cluster clusters = 1;
   */
  clusters: Cluster[];

  /**
   * Pagination token for the next page. Empty when there are no more results.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;
};

/**
 * Describes the message admiral.api.cluster.v1.ListClustersResponse.
 * Use `create(ListClustersResponseSchema)` to create a new message.
 */
export const ListClustersResponseSchema: GenMessage<ListClustersResponse> = /*@__PURE__*/
  messageDesc(file_admiral_api_cluster_v1_cluster, 5);

/**
 * UpdateClusterRequest contains the cluster fields to update.
 *
 * @generated from message admiral.api.cluster.v1.UpdateClusterRequest
 */
export type UpdateClusterRequest = Message<"admiral.api.cluster.v1.UpdateClusterRequest"> & {
  /**
   * The cluster with updated fields. The `id` field is required.
   * Only fields specified in `update_mask` are updated.
   *
   * @generated from field: admiral.cluster.v1.Cluster cluster = 1;
   */
  cluster?: Cluster;

  /**
   * The set of fields to update. If unset, all mutable fields are updated.
   * Supported fields: `name`, `description`, `labels`.
   *
   * @generated from field: google.protobuf.FieldMask update_mask = 2;
   */
  updateMask?: FieldMask;
};

/**
 * Describes the message admiral.api.cluster.v1.UpdateClusterRequest.
 * Use `create(UpdateClusterRequestSchema)` to create a new message.
 */
export const UpdateClusterRequestSchema: GenMessage<UpdateClusterRequest> = /*@__PURE__*/
  messageDesc(file_admiral_api_cluster_v1_cluster, 6);

/**
 * UpdateClusterResponse contains the updated cluster.
 *
 * @generated from message admiral.api.cluster.v1.UpdateClusterResponse
 */
export type UpdateClusterResponse = Message<"admiral.api.cluster.v1.UpdateClusterResponse"> & {
  /**
   * The updated cluster.
   *
   * @generated from field: admiral.cluster.v1.Cluster cluster = 1;
   */
  cluster?: Cluster;
};

/**
 * Describes the message admiral.api.cluster.v1.UpdateClusterResponse.
 * Use `create(UpdateClusterResponseSchema)` to create a new message.
 */
export const UpdateClusterResponseSchema: GenMessage<UpdateClusterResponse> = /*@__PURE__*/
  messageDesc(file_admiral_api_cluster_v1_cluster, 7);

/**
 * DeleteClusterRequest identifies a cluster to delete.
 *
 * @generated from message admiral.api.cluster.v1.DeleteClusterRequest
 */
export type DeleteClusterRequest = Message<"admiral.api.cluster.v1.DeleteClusterRequest"> & {
  /**
   * The unique identifier of the cluster to delete (UUID).
   * All associated agent tokens will be revoked.
   *
   * @generated from field: string cluster_id = 1;
   */
  clusterId: string;
};

/**
 * Describes the message admiral.api.cluster.v1.DeleteClusterRequest.
 * Use `create(DeleteClusterRequestSchema)` to create a new message.
 */
export const DeleteClusterRequestSchema: GenMessage<DeleteClusterRequest> = /*@__PURE__*/
  messageDesc(file_admiral_api_cluster_v1_cluster, 8);

/**
 * DeleteClusterResponse is empty on success.
 *
 * @generated from message admiral.api.cluster.v1.DeleteClusterResponse
 */
export type DeleteClusterResponse = Message<"admiral.api.cluster.v1.DeleteClusterResponse"> & {
};

/**
 * Describes the message admiral.api.cluster.v1.DeleteClusterResponse.
 * Use `create(DeleteClusterResponseSchema)` to create a new message.
 */
export const DeleteClusterResponseSchema: GenMessage<DeleteClusterResponse> = /*@__PURE__*/
  messageDesc(file_admiral_api_cluster_v1_cluster, 9);

/**
 * GetClusterStatusRequest identifies a cluster whose telemetry status to retrieve.
 *
 * @generated from message admiral.api.cluster.v1.GetClusterStatusRequest
 */
export type GetClusterStatusRequest = Message<"admiral.api.cluster.v1.GetClusterStatusRequest"> & {
  /**
   * The unique identifier of the cluster (UUID).
   *
   * @generated from field: string cluster_id = 1;
   */
  clusterId: string;
};

/**
 * Describes the message admiral.api.cluster.v1.GetClusterStatusRequest.
 * Use `create(GetClusterStatusRequestSchema)` to create a new message.
 */
export const GetClusterStatusRequestSchema: GenMessage<GetClusterStatusRequest> = /*@__PURE__*/
  messageDesc(file_admiral_api_cluster_v1_cluster, 10);

/**
 * GetClusterStatusResponse contains the server-derived health status and the
 * latest telemetry snapshot. If no agent has reported telemetry yet, the
 * health_status will be PENDING and status will be absent.
 *
 * @generated from message admiral.api.cluster.v1.GetClusterStatusResponse
 */
export type GetClusterStatusResponse = Message<"admiral.api.cluster.v1.GetClusterStatusResponse"> & {
  /**
   * Server-derived health status based on agent connectivity, node readiness,
   * and workload health.
   *
   * @generated from field: admiral.cluster.v1.ClusterHealthStatus health_status = 1;
   */
  healthStatus: ClusterHealthStatus;

  /**
   * Latest telemetry snapshot from the agent. Absent if no telemetry has
   * been reported yet.
   *
   * @generated from field: admiral.cluster.v1.ClusterStatus status = 2;
   */
  status?: ClusterStatus;

  /**
   * When the latest telemetry was reported by the agent.
   *
   * @generated from field: google.protobuf.Timestamp reported_at = 3;
   */
  reportedAt?: Timestamp;
};

/**
 * Describes the message admiral.api.cluster.v1.GetClusterStatusResponse.
 * Use `create(GetClusterStatusResponseSchema)` to create a new message.
 */
export const GetClusterStatusResponseSchema: GenMessage<GetClusterStatusResponse> = /*@__PURE__*/
  messageDesc(file_admiral_api_cluster_v1_cluster, 11);

/**
 * ReportClusterStatusRequest contains a combined telemetry payload from a K8s agent.
 * Admiral splits this into three storage tiers: current snapshot, time-series
 * metrics, and events.
 *
 * @generated from message admiral.api.cluster.v1.ReportClusterStatusRequest
 */
export type ReportClusterStatusRequest = Message<"admiral.api.cluster.v1.ReportClusterStatusRequest"> & {
  /**
   * The cluster this status report is for (UUID).
   *
   * @generated from field: string cluster_id = 1;
   */
  clusterId: string;

  /**
   * Cluster-level telemetry snapshot.
   *
   * @generated from field: admiral.cluster.v1.ClusterStatus status = 2;
   */
  status?: ClusterStatus;

  /**
   * Per-workload status snapshots.
   *
   * @generated from field: repeated admiral.cluster.v1.WorkloadStatus workloads = 3;
   */
  workloads: WorkloadStatus[];

  /**
   * Kubernetes events observed since the last push.
   *
   * @generated from field: repeated admiral.cluster.v1.WorkloadEvent events = 4;
   */
  events: WorkloadEvent[];

  /**
   * When the agent generated this report.
   *
   * @generated from field: google.protobuf.Timestamp reported_at = 5;
   */
  reportedAt?: Timestamp;
};

/**
 * Describes the message admiral.api.cluster.v1.ReportClusterStatusRequest.
 * Use `create(ReportClusterStatusRequestSchema)` to create a new message.
 */
export const ReportClusterStatusRequestSchema: GenMessage<ReportClusterStatusRequest> = /*@__PURE__*/
  messageDesc(file_admiral_api_cluster_v1_cluster, 12);

/**
 * ReportClusterStatusResponse acknowledges a telemetry push.
 *
 * @generated from message admiral.api.cluster.v1.ReportClusterStatusResponse
 */
export type ReportClusterStatusResponse = Message<"admiral.api.cluster.v1.ReportClusterStatusResponse"> & {
  /**
   * Whether the report was accepted.
   *
   * @generated from field: bool ack = 1;
   */
  ack: boolean;

  /**
   * Server-controlled interval (in seconds) before the agent should send
   * its next status push. Allows the server to adjust push frequency dynamically.
   *
   * @generated from field: int32 next_push_seconds = 2;
   */
  nextPushSeconds: number;
};

/**
 * Describes the message admiral.api.cluster.v1.ReportClusterStatusResponse.
 * Use `create(ReportClusterStatusResponseSchema)` to create a new message.
 */
export const ReportClusterStatusResponseSchema: GenMessage<ReportClusterStatusResponse> = /*@__PURE__*/
  messageDesc(file_admiral_api_cluster_v1_cluster, 13);

/**
 * ListWorkloadsRequest contains pagination and filter parameters for listing
 * workloads in a specific cluster.
 *
 * @generated from message admiral.api.cluster.v1.ListWorkloadsRequest
 */
export type ListWorkloadsRequest = Message<"admiral.api.cluster.v1.ListWorkloadsRequest"> & {
  /**
   * The cluster whose workloads to list (UUID).
   *
   * @generated from field: string cluster_id = 1;
   */
  clusterId: string;

  /**
   * Filter expression using the PEG filter DSL.
   *
   * @generated from field: string filter = 2;
   */
  filter: string;

  /**
   * Maximum number of workloads to return per page.
   *
   * @generated from field: int32 page_size = 3;
   */
  pageSize: number;

  /**
   * Opaque pagination token from a previous response.
   *
   * @generated from field: string page_token = 4;
   */
  pageToken: string;
};

/**
 * Describes the message admiral.api.cluster.v1.ListWorkloadsRequest.
 * Use `create(ListWorkloadsRequestSchema)` to create a new message.
 */
export const ListWorkloadsRequestSchema: GenMessage<ListWorkloadsRequest> = /*@__PURE__*/
  messageDesc(file_admiral_api_cluster_v1_cluster, 14);

/**
 * ListWorkloadsResponse contains a page of workloads.
 *
 * @generated from message admiral.api.cluster.v1.ListWorkloadsResponse
 */
export type ListWorkloadsResponse = Message<"admiral.api.cluster.v1.ListWorkloadsResponse"> & {
  /**
   * The list of workloads.
   *
   * @generated from field: repeated admiral.cluster.v1.Workload workloads = 1;
   */
  workloads: Workload[];

  /**
   * Pagination token for the next page. Empty when there are no more results.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;
};

/**
 * Describes the message admiral.api.cluster.v1.ListWorkloadsResponse.
 * Use `create(ListWorkloadsResponseSchema)` to create a new message.
 */
export const ListWorkloadsResponseSchema: GenMessage<ListWorkloadsResponse> = /*@__PURE__*/
  messageDesc(file_admiral_api_cluster_v1_cluster, 15);

/**
 * ReportWorkloadStatusRequest contains incremental workload telemetry from a K8s agent.
 *
 * @generated from message admiral.api.cluster.v1.ReportWorkloadStatusRequest
 */
export type ReportWorkloadStatusRequest = Message<"admiral.api.cluster.v1.ReportWorkloadStatusRequest"> & {
  /**
   * The cluster these workloads belong to (UUID).
   *
   * @generated from field: string cluster_id = 1;
   */
  clusterId: string;

  /**
   * Per-workload status snapshots.
   *
   * @generated from field: repeated admiral.cluster.v1.WorkloadStatus workloads = 2;
   */
  workloads: WorkloadStatus[];

  /**
   * When the agent generated this report.
   *
   * @generated from field: google.protobuf.Timestamp reported_at = 3;
   */
  reportedAt?: Timestamp;
};

/**
 * Describes the message admiral.api.cluster.v1.ReportWorkloadStatusRequest.
 * Use `create(ReportWorkloadStatusRequestSchema)` to create a new message.
 */
export const ReportWorkloadStatusRequestSchema: GenMessage<ReportWorkloadStatusRequest> = /*@__PURE__*/
  messageDesc(file_admiral_api_cluster_v1_cluster, 16);

/**
 * ReportWorkloadStatusResponse acknowledges a workload telemetry push.
 *
 * @generated from message admiral.api.cluster.v1.ReportWorkloadStatusResponse
 */
export type ReportWorkloadStatusResponse = Message<"admiral.api.cluster.v1.ReportWorkloadStatusResponse"> & {
  /**
   * Whether the report was accepted.
   *
   * @generated from field: bool ack = 1;
   */
  ack: boolean;
};

/**
 * Describes the message admiral.api.cluster.v1.ReportWorkloadStatusResponse.
 * Use `create(ReportWorkloadStatusResponseSchema)` to create a new message.
 */
export const ReportWorkloadStatusResponseSchema: GenMessage<ReportWorkloadStatusResponse> = /*@__PURE__*/
  messageDesc(file_admiral_api_cluster_v1_cluster, 17);

/**
 * CreateClusterTokenRequest contains the parameters for creating a new AGT
 * bound to a cluster.
 *
 * @generated from message admiral.api.cluster.v1.CreateClusterTokenRequest
 */
export type CreateClusterTokenRequest = Message<"admiral.api.cluster.v1.CreateClusterTokenRequest"> & {
  /**
   * The cluster to bind this token to (UUID).
   *
   * @generated from field: string cluster_id = 1;
   */
  clusterId: string;

  /**
   * URL-safe, human-readable identifier for the token (e.g., "prod-agent-key").
   * Must be unique within the cluster's tokens. Lowercase alphanumeric and
   * hyphens only.
   *
   * @generated from field: string name = 2;
   */
  name: string;

  /**
   * Optional expiration time. If unset, the token does not expire.
   *
   * @generated from field: google.protobuf.Timestamp expires_at = 3;
   */
  expiresAt?: Timestamp;
};

/**
 * Describes the message admiral.api.cluster.v1.CreateClusterTokenRequest.
 * Use `create(CreateClusterTokenRequestSchema)` to create a new message.
 */
export const CreateClusterTokenRequestSchema: GenMessage<CreateClusterTokenRequest> = /*@__PURE__*/
  messageDesc(file_admiral_api_cluster_v1_cluster, 18);

/**
 * CreateClusterTokenResponse contains the newly created AGT.
 *
 * @generated from message admiral.api.cluster.v1.CreateClusterTokenResponse
 */
export type CreateClusterTokenResponse = Message<"admiral.api.cluster.v1.CreateClusterTokenResponse"> & {
  /**
   * The created token metadata. Scopes are auto-assigned for cluster AGTs.
   *
   * @generated from field: admiral.common.v1.AccessToken access_token = 1;
   */
  accessToken?: AccessToken;

  /**
   * The raw token secret (e.g., "adm_agt_pL2mN5oQ8rS1..."). This value is
   * shown exactly once and cannot be retrieved again. Store it securely.
   *
   * @generated from field: string plain_text_token = 2;
   */
  plainTextToken: string;
};

/**
 * Describes the message admiral.api.cluster.v1.CreateClusterTokenResponse.
 * Use `create(CreateClusterTokenResponseSchema)` to create a new message.
 */
export const CreateClusterTokenResponseSchema: GenMessage<CreateClusterTokenResponse> = /*@__PURE__*/
  messageDesc(file_admiral_api_cluster_v1_cluster, 19);

/**
 * ListClusterTokensRequest contains pagination and filter parameters.
 *
 * @generated from message admiral.api.cluster.v1.ListClusterTokensRequest
 */
export type ListClusterTokensRequest = Message<"admiral.api.cluster.v1.ListClusterTokensRequest"> & {
  /**
   * The cluster whose tokens to list (UUID).
   *
   * @generated from field: string cluster_id = 1;
   */
  clusterId: string;

  /**
   * Maximum number of tokens to return per page.
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize: number;

  /**
   * Opaque pagination token from a previous response.
   *
   * @generated from field: string page_token = 3;
   */
  pageToken: string;

  /**
   * Filter expression using the PEG filter DSL.
   *
   * @generated from field: string filter = 4;
   */
  filter: string;
};

/**
 * Describes the message admiral.api.cluster.v1.ListClusterTokensRequest.
 * Use `create(ListClusterTokensRequestSchema)` to create a new message.
 */
export const ListClusterTokensRequestSchema: GenMessage<ListClusterTokensRequest> = /*@__PURE__*/
  messageDesc(file_admiral_api_cluster_v1_cluster, 20);

/**
 * ListClusterTokensResponse contains a page of cluster AGT metadata.
 *
 * @generated from message admiral.api.cluster.v1.ListClusterTokensResponse
 */
export type ListClusterTokensResponse = Message<"admiral.api.cluster.v1.ListClusterTokensResponse"> & {
  /**
   * The list of tokens. Token secrets are never included.
   *
   * @generated from field: repeated admiral.common.v1.AccessToken access_tokens = 1;
   */
  accessTokens: AccessToken[];

  /**
   * Pagination token for the next page. Empty when there are no more results.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;
};

/**
 * Describes the message admiral.api.cluster.v1.ListClusterTokensResponse.
 * Use `create(ListClusterTokensResponseSchema)` to create a new message.
 */
export const ListClusterTokensResponseSchema: GenMessage<ListClusterTokensResponse> = /*@__PURE__*/
  messageDesc(file_admiral_api_cluster_v1_cluster, 21);

/**
 * GetClusterTokenRequest identifies a cluster AGT to retrieve.
 *
 * @generated from message admiral.api.cluster.v1.GetClusterTokenRequest
 */
export type GetClusterTokenRequest = Message<"admiral.api.cluster.v1.GetClusterTokenRequest"> & {
  /**
   * The cluster the token belongs to (UUID).
   *
   * @generated from field: string cluster_id = 1;
   */
  clusterId: string;

  /**
   * The unique identifier of the token (UUID).
   *
   * @generated from field: string token_id = 2;
   */
  tokenId: string;
};

/**
 * Describes the message admiral.api.cluster.v1.GetClusterTokenRequest.
 * Use `create(GetClusterTokenRequestSchema)` to create a new message.
 */
export const GetClusterTokenRequestSchema: GenMessage<GetClusterTokenRequest> = /*@__PURE__*/
  messageDesc(file_admiral_api_cluster_v1_cluster, 22);

/**
 * GetClusterTokenResponse contains the requested cluster AGT metadata.
 *
 * @generated from message admiral.api.cluster.v1.GetClusterTokenResponse
 */
export type GetClusterTokenResponse = Message<"admiral.api.cluster.v1.GetClusterTokenResponse"> & {
  /**
   * The token metadata. The token secret is never included.
   *
   * @generated from field: admiral.common.v1.AccessToken access_token = 1;
   */
  accessToken?: AccessToken;
};

/**
 * Describes the message admiral.api.cluster.v1.GetClusterTokenResponse.
 * Use `create(GetClusterTokenResponseSchema)` to create a new message.
 */
export const GetClusterTokenResponseSchema: GenMessage<GetClusterTokenResponse> = /*@__PURE__*/
  messageDesc(file_admiral_api_cluster_v1_cluster, 23);

/**
 * RevokeClusterTokenRequest identifies a cluster AGT to revoke.
 *
 * @generated from message admiral.api.cluster.v1.RevokeClusterTokenRequest
 */
export type RevokeClusterTokenRequest = Message<"admiral.api.cluster.v1.RevokeClusterTokenRequest"> & {
  /**
   * The cluster the token belongs to (UUID).
   *
   * @generated from field: string cluster_id = 1;
   */
  clusterId: string;

  /**
   * The unique identifier of the token to revoke (UUID).
   *
   * @generated from field: string token_id = 2;
   */
  tokenId: string;
};

/**
 * Describes the message admiral.api.cluster.v1.RevokeClusterTokenRequest.
 * Use `create(RevokeClusterTokenRequestSchema)` to create a new message.
 */
export const RevokeClusterTokenRequestSchema: GenMessage<RevokeClusterTokenRequest> = /*@__PURE__*/
  messageDesc(file_admiral_api_cluster_v1_cluster, 24);

/**
 * RevokeClusterTokenResponse contains the revoked cluster AGT metadata.
 *
 * @generated from message admiral.api.cluster.v1.RevokeClusterTokenResponse
 */
export type RevokeClusterTokenResponse = Message<"admiral.api.cluster.v1.RevokeClusterTokenResponse"> & {
  /**
   * The token metadata with updated status.
   *
   * @generated from field: admiral.common.v1.AccessToken access_token = 1;
   */
  accessToken?: AccessToken;
};

/**
 * Describes the message admiral.api.cluster.v1.RevokeClusterTokenResponse.
 * Use `create(RevokeClusterTokenResponseSchema)` to create a new message.
 */
export const RevokeClusterTokenResponseSchema: GenMessage<RevokeClusterTokenResponse> = /*@__PURE__*/
  messageDesc(file_admiral_api_cluster_v1_cluster, 25);

/**
 * ClusterAPI manages Kubernetes clusters and their workload telemetry.
 *
 * Administrators create clusters via CreateCluster, which returns an Agent
 * Token (AGT) for deploying the K8s agent. Once the agent boots and calls
 * AgentAPI.RegisterAgent, the cluster transitions from PENDING to HEALTHY
 * and begins receiving telemetry.
 *
 * The telemetry model has three tiers: current snapshot (upserted per push),
 * time-series metrics (rolling 48-hour window), and events (rolling 7-day window).
 *
 * @generated from service admiral.api.cluster.v1.ClusterAPI
 */
export const ClusterAPI: GenService<{
  /**
   * CreateCluster creates a new cluster record within the caller's tenant and
   * generates an initial Agent Token (AGT) for the K8s agent. The cluster
   * starts in PENDING status until an agent registers against it.
   *
   * The response includes a `plain_text_token` -- the raw AGT secret shown
   * exactly once. Deploy this token to the K8s agent (e.g., via Helm values
   * or a Kubernetes Secret). The agent uses it to authenticate with
   * AgentAPI.RegisterAgent on first boot.
   *
   * Scope: `cluster:write`
   *
   * @generated from rpc admiral.api.cluster.v1.ClusterAPI.CreateCluster
   */
  createCluster: {
    methodKind: "unary";
    input: typeof CreateClusterRequestSchema;
    output: typeof CreateClusterResponseSchema;
  },
  /**
   * GetCluster retrieves a cluster by ID.
   *
   * Returns the Cluster record with its server-derived health_status. For
   * detailed telemetry (node counts, resource usage, workload summary), use
   * GetClusterStatus instead.
   *
   * Scope: `cluster:read`
   *
   * @generated from rpc admiral.api.cluster.v1.ClusterAPI.GetCluster
   */
  getCluster: {
    methodKind: "unary";
    input: typeof GetClusterRequestSchema;
    output: typeof GetClusterResponseSchema;
  },
  /**
   * GetClusterStatus retrieves the current telemetry snapshot for a cluster.
   * Returns the latest metrics pushed by the agent, along with server-derived
   * health status and workload summary counts.
   *
   * Returns NOT_FOUND if the cluster does not exist. If the cluster exists but
   * no agent has reported telemetry yet, the response will have health_status
   * PENDING and no status message.
   *
   * Scope: `cluster:read`
   *
   * @generated from rpc admiral.api.cluster.v1.ClusterAPI.GetClusterStatus
   */
  getClusterStatus: {
    methodKind: "unary";
    input: typeof GetClusterStatusRequestSchema;
    output: typeof GetClusterStatusResponseSchema;
  },
  /**
   * ListClusters returns a paginated list of clusters within the caller's tenant.
   *
   * Scope: `cluster:read`
   *
   * @generated from rpc admiral.api.cluster.v1.ClusterAPI.ListClusters
   */
  listClusters: {
    methodKind: "unary";
    input: typeof ListClustersRequestSchema;
    output: typeof ListClustersResponseSchema;
  },
  /**
   * UpdateCluster updates a cluster's mutable fields.
   * Use the `update_mask` to specify which fields to update.
   *
   * Scope: `cluster:write`
   *
   * @generated from rpc admiral.api.cluster.v1.ClusterAPI.UpdateCluster
   */
  updateCluster: {
    methodKind: "unary";
    input: typeof UpdateClusterRequestSchema;
    output: typeof UpdateClusterResponseSchema;
  },
  /**
   * DeleteCluster permanently deletes a cluster record and revokes all
   * associated agent tokens. This action cannot be undone.
   *
   * Scope: `cluster:write`
   *
   * @generated from rpc admiral.api.cluster.v1.ClusterAPI.DeleteCluster
   */
  deleteCluster: {
    methodKind: "unary";
    input: typeof DeleteClusterRequestSchema;
    output: typeof DeleteClusterResponseSchema;
  },
  /**
   * CreateClusterToken creates a new Agent Token (AGT) bound to the specified
   * cluster. Scopes are auto-assigned and cannot be overridden. The response
   * includes the raw token secret, which is shown exactly once.
   *
   * Use this to create additional AGTs for an existing cluster (e.g., for
   * zero-downtime token rotation). The initial AGT is created automatically
   * by CreateCluster.
   *
   * Scope: `cluster:write`
   *
   * @generated from rpc admiral.api.cluster.v1.ClusterAPI.CreateClusterToken
   */
  createClusterToken: {
    methodKind: "unary";
    input: typeof CreateClusterTokenRequestSchema;
    output: typeof CreateClusterTokenResponseSchema;
  },
  /**
   * ListClusterTokens returns a paginated list of AGTs bound to the specified
   * cluster. Token secrets are never included.
   *
   * Scope: `cluster:read`
   *
   * @generated from rpc admiral.api.cluster.v1.ClusterAPI.ListClusterTokens
   */
  listClusterTokens: {
    methodKind: "unary";
    input: typeof ListClusterTokensRequestSchema;
    output: typeof ListClusterTokensResponseSchema;
  },
  /**
   * GetClusterToken retrieves a single AGT by ID.
   * Returns metadata only -- the token secret is never included.
   *
   * Scope: `cluster:read`
   *
   * @generated from rpc admiral.api.cluster.v1.ClusterAPI.GetClusterToken
   */
  getClusterToken: {
    methodKind: "unary";
    input: typeof GetClusterTokenRequestSchema;
    output: typeof GetClusterTokenResponseSchema;
  },
  /**
   * RevokeClusterToken permanently revokes an AGT bound to this cluster.
   * The agent will receive a 401 on its next request. If this is the only
   * active AGT for the cluster, the agent will become disconnected.
   *
   * Scope: `cluster:write`
   *
   * @generated from rpc admiral.api.cluster.v1.ClusterAPI.RevokeClusterToken
   */
  revokeClusterToken: {
    methodKind: "unary";
    input: typeof RevokeClusterTokenRequestSchema;
    output: typeof RevokeClusterTokenResponseSchema;
  },
  /**
   * ReportClusterStatus receives a combined telemetry snapshot from a K8s agent.
   * The payload includes cluster-level metrics, per-workload status, and
   * Kubernetes events. Admiral splits this into three storage tiers on receipt.
   *
   * This endpoint is agent-facing and restricted to agent tokens.
   *
   * Scope: `cluster:status` | Token types: `agt`
   *
   * @generated from rpc admiral.api.cluster.v1.ClusterAPI.ReportClusterStatus
   */
  reportClusterStatus: {
    methodKind: "unary";
    input: typeof ReportClusterStatusRequestSchema;
    output: typeof ReportClusterStatusResponseSchema;
  },
  /**
   * ListWorkloads returns a paginated list of workloads running in a specific cluster.
   *
   * Scope: `cluster:read`
   *
   * @generated from rpc admiral.api.cluster.v1.ClusterAPI.ListWorkloads
   */
  listWorkloads: {
    methodKind: "unary";
    input: typeof ListWorkloadsRequestSchema;
    output: typeof ListWorkloadsResponseSchema;
  },
  /**
   * ReportWorkloadStatus receives workload-only telemetry from a K8s agent.
   * Used for incremental workload updates between full cluster status pushes.
   *
   * This endpoint is agent-facing and restricted to agent tokens.
   *
   * Scope: `cluster:status` | Token types: `agt`
   *
   * @generated from rpc admiral.api.cluster.v1.ClusterAPI.ReportWorkloadStatus
   */
  reportWorkloadStatus: {
    methodKind: "unary";
    input: typeof ReportWorkloadStatusRequestSchema;
    output: typeof ReportWorkloadStatusResponseSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_admiral_api_cluster_v1_cluster, 0);

