// @generated by protoc-gen-es v2.11.0 with parameter "target=ts"
// @generated from file admiral/api/cluster/v1/cluster.proto (package admiral.api.cluster.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv2";
import { enumDesc, fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv2";
import { file_admiral_common_v1_annotations } from "../../../common/v1/annotations_pb";
import type { AccessToken } from "../../../common/v1/token_pb";
import { file_admiral_common_v1_token } from "../../../common/v1/token_pb";
import { file_buf_validate_validate } from "../../../../buf/validate/validate_pb";
import { file_google_api_annotations } from "../../../../google/api/annotations_pb";
import type { FieldMask, Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_field_mask, file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file admiral/api/cluster/v1/cluster.proto.
 */
export const file_admiral_api_cluster_v1_cluster: GenFile = /*@__PURE__*/
  fileDesc("CiRhZG1pcmFsL2FwaS9jbHVzdGVyL3YxL2NsdXN0ZXIucHJvdG8SFmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEi/QMKB0NsdXN0ZXISFAoCaWQYASABKAlCCLpIBXIDsAEBEhsKCXRlbmFudF9pZBgCIAEoCUIIukgFcgOwAQESOgoEbmFtZRgDIAEoCUIsukgpcicQARg/MiFeW2Etel0oW2EtejAtOS1dezAsNjF9W2EtejAtOV0pPyQSHQoLZGVzY3JpcHRpb24YBCABKAlCCLpIBXIDGIAIElQKBmxhYmVscxgFIAMoCzIrLmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEuQ2x1c3Rlci5MYWJlbHNFbnRyeUIXukgUmgEREEAiBnIEEAEYPyoFcgMYgAISEwoLY2x1c3Rlcl91aWQYBiABKAkSQgoNaGVhbHRoX3N0YXR1cxgHIAEoDjIrLmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEuQ2x1c3RlckhlYWx0aFN0YXR1cxISCgpjcmVhdGVkX2J5GAogASgJEhIKCnVwZGF0ZWRfYnkYCyABKAkSLgoKY3JlYXRlZF9hdBgIIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASLgoKdXBkYXRlZF9hdBgJIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAaLQoLTGFiZWxzRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgJOgI4ASKYAwoNQ2x1c3RlclN0YXR1cxITCgtrOHNfdmVyc2lvbhgBIAEoCRISCgpub2RlX2NvdW50GAIgASgFEhMKC25vZGVzX3JlYWR5GAMgASgFEhQKDHBvZF9jYXBhY2l0eRgEIAEoBRIRCglwb2RfY291bnQYBSABKAUSFAoMcG9kc19ydW5uaW5nGAYgASgFEhQKDHBvZHNfcGVuZGluZxgHIAEoBRITCgtwb2RzX2ZhaWxlZBgIIAEoBRIfChdjcHVfY2FwYWNpdHlfbWlsbGljb3JlcxgJIAEoAxIbChNjcHVfdXNlZF9taWxsaWNvcmVzGAogASgDEh0KFW1lbW9yeV9jYXBhY2l0eV9ieXRlcxgLIAEoAxIZChFtZW1vcnlfdXNlZF9ieXRlcxgMIAEoAxIXCg93b3JrbG9hZHNfdG90YWwYDSABKAUSGQoRd29ya2xvYWRzX2hlYWx0aHkYDiABKAUSGgoSd29ya2xvYWRzX2RlZ3JhZGVkGA8gASgFEhcKD3dvcmtsb2Fkc19lcnJvchgQIAEoBSKWBQoIV29ya2xvYWQSCgoCaWQYASABKAkSEgoKY2x1c3Rlcl9pZBgCIAEoCRIRCgluYW1lc3BhY2UYAyABKAkSDAoEbmFtZRgEIAEoCRIMCgRraW5kGAUgASgJEjwKBmxhYmVscxgGIAMoCzIsLmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEuV29ya2xvYWQuTGFiZWxzRW50cnkSQwoNaGVhbHRoX3N0YXR1cxgHIAEoDjIsLmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEuV29ya2xvYWRIZWFsdGhTdGF0dXMSFQoNc3RhdHVzX3JlYXNvbhgIIAEoCRIYChByZXBsaWNhc19kZXNpcmVkGAkgASgFEhYKDnJlcGxpY2FzX3JlYWR5GAogASgFEhoKEnJlcGxpY2FzX2F2YWlsYWJsZRgLIAEoBRIfChdjcHVfcmVxdWVzdHNfbWlsbGljb3JlcxgMIAEoAxIdChVjcHVfbGltaXRzX21pbGxpY29yZXMYDSABKAMSGwoTY3B1X3VzZWRfbWlsbGljb3JlcxgOIAEoAxIdChVtZW1vcnlfcmVxdWVzdHNfYnl0ZXMYDyABKAMSGwoTbWVtb3J5X2xpbWl0c19ieXRlcxgQIAEoAxIZChFtZW1vcnlfdXNlZF9ieXRlcxgRIAEoAxI7Cgpjb250YWluZXJzGBIgAygLMicuYWRtaXJhbC5hcGkuY2x1c3Rlci52MS5Db250YWluZXJTdGF0dXMSMwoPbGFzdF91cGRhdGVkX2F0GBMgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBotCgtMYWJlbHNFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBImMKD0NvbnRhaW5lclN0YXR1cxIMCgRuYW1lGAEgASgJEg0KBWltYWdlGAIgASgJEhUKDXJlc3RhcnRfY291bnQYAyABKAUSDQoFc3RhdGUYBCABKAkSDQoFcmVhZHkYBSABKAgiQAoPT2JqZWN0UmVmZXJlbmNlEgwKBGtpbmQYASABKAkSEQoJbmFtZXNwYWNlGAIgASgJEgwKBG5hbWUYAyABKAki9QEKDVdvcmtsb2FkRXZlbnQSCwoDdWlkGAEgASgJEgwKBHR5cGUYAiABKAkSDgoGcmVhc29uGAMgASgJEjoKCXJlZ2FyZGluZxgEIAEoCzInLmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEuT2JqZWN0UmVmZXJlbmNlEg8KB21lc3NhZ2UYBSABKAkSLgoKZmlyc3Rfc2VlbhgGIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASLQoJbGFzdF9zZWVuGAcgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBINCgVjb3VudBgIIAEoBSKDAgoUQ3JlYXRlQ2x1c3RlclJlcXVlc3QSOgoEbmFtZRgBIAEoCUIsukgpcicQARg/MiFeW2Etel0oW2EtejAtOS1dezAsNjF9W2EtejAtOV0pPyQSHQoLZGVzY3JpcHRpb24YAiABKAlCCLpIBXIDGIAIEmEKBmxhYmVscxgDIAMoCzI4LmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEuQ3JlYXRlQ2x1c3RlclJlcXVlc3QuTGFiZWxzRW50cnlCF7pIFJoBERBAIgZyBBABGD8qBXIDGIACGi0KC0xhYmVsc0VudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCToCOAEiYwoVQ3JlYXRlQ2x1c3RlclJlc3BvbnNlEjAKB2NsdXN0ZXIYASABKAsyHy5hZG1pcmFsLmFwaS5jbHVzdGVyLnYxLkNsdXN0ZXISGAoQcGxhaW5fdGV4dF90b2tlbhgCIAEoCSIxChFHZXRDbHVzdGVyUmVxdWVzdBIcCgpjbHVzdGVyX2lkGAEgASgJQgi6SAVyA7ABASJGChJHZXRDbHVzdGVyUmVzcG9uc2USMAoHY2x1c3RlchgBIAEoCzIfLmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEuQ2x1c3RlciJhChNMaXN0Q2x1c3RlcnNSZXF1ZXN0EhgKBmZpbHRlchgBIAEoCUIIukgFcgMYgAgSHAoJcGFnZV9zaXplGAIgASgFQgm6SAYaBBhkKAASEgoKcGFnZV90b2tlbhgDIAEoCSJiChRMaXN0Q2x1c3RlcnNSZXNwb25zZRIxCghjbHVzdGVycxgBIAMoCzIfLmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEuQ2x1c3RlchIXCg9uZXh0X3BhZ2VfdG9rZW4YAiABKAkigQEKFFVwZGF0ZUNsdXN0ZXJSZXF1ZXN0EjgKB2NsdXN0ZXIYASABKAsyHy5hZG1pcmFsLmFwaS5jbHVzdGVyLnYxLkNsdXN0ZXJCBrpIA8gBARIvCgt1cGRhdGVfbWFzaxgCIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5GaWVsZE1hc2siSQoVVXBkYXRlQ2x1c3RlclJlc3BvbnNlEjAKB2NsdXN0ZXIYASABKAsyHy5hZG1pcmFsLmFwaS5jbHVzdGVyLnYxLkNsdXN0ZXIiNAoURGVsZXRlQ2x1c3RlclJlcXVlc3QSHAoKY2x1c3Rlcl9pZBgBIAEoCUIIukgFcgOwAQEiFwoVRGVsZXRlQ2x1c3RlclJlc3BvbnNlIjcKF0dldENsdXN0ZXJTdGF0dXNSZXF1ZXN0EhwKCmNsdXN0ZXJfaWQYASABKAlCCLpIBXIDsAEBIsYBChhHZXRDbHVzdGVyU3RhdHVzUmVzcG9uc2USQgoNaGVhbHRoX3N0YXR1cxgBIAEoDjIrLmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEuQ2x1c3RlckhlYWx0aFN0YXR1cxI1CgZzdGF0dXMYAiABKAsyJS5hZG1pcmFsLmFwaS5jbHVzdGVyLnYxLkNsdXN0ZXJTdGF0dXMSLwoLcmVwb3J0ZWRfYXQYAyABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wIv4BChpSZXBvcnRDbHVzdGVyU3RhdHVzUmVxdWVzdBI9CgZzdGF0dXMYASABKAsyJS5hZG1pcmFsLmFwaS5jbHVzdGVyLnYxLkNsdXN0ZXJTdGF0dXNCBrpIA8gBARI5Cgl3b3JrbG9hZHMYAiADKAsyJi5hZG1pcmFsLmFwaS5jbHVzdGVyLnYxLldvcmtsb2FkU3RhdHVzEjUKBmV2ZW50cxgDIAMoCzIlLmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEuV29ya2xvYWRFdmVudBIvCgtyZXBvcnRlZF9hdBgEIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAitgQKDldvcmtsb2FkU3RhdHVzEhEKCW5hbWVzcGFjZRgBIAEoCRIMCgRuYW1lGAIgASgJEgwKBGtpbmQYAyABKAkSQgoGbGFiZWxzGAQgAygLMjIuYWRtaXJhbC5hcGkuY2x1c3Rlci52MS5Xb3JrbG9hZFN0YXR1cy5MYWJlbHNFbnRyeRIYChByZXBsaWNhc19kZXNpcmVkGAUgASgFEhYKDnJlcGxpY2FzX3JlYWR5GAYgASgFEhoKEnJlcGxpY2FzX2F2YWlsYWJsZRgHIAEoBRIfChdjcHVfcmVxdWVzdHNfbWlsbGljb3JlcxgIIAEoAxIdChVjcHVfbGltaXRzX21pbGxpY29yZXMYCSABKAMSGwoTY3B1X3VzZWRfbWlsbGljb3JlcxgKIAEoAxIdChVtZW1vcnlfcmVxdWVzdHNfYnl0ZXMYCyABKAMSGwoTbWVtb3J5X2xpbWl0c19ieXRlcxgMIAEoAxIZChFtZW1vcnlfdXNlZF9ieXRlcxgNIAEoAxJDCg1oZWFsdGhfc3RhdHVzGA4gASgOMiwuYWRtaXJhbC5hcGkuY2x1c3Rlci52MS5Xb3JrbG9hZEhlYWx0aFN0YXR1cxI7Cgpjb250YWluZXJzGA8gAygLMicuYWRtaXJhbC5hcGkuY2x1c3Rlci52MS5Db250YWluZXJTdGF0dXMaLQoLTGFiZWxzRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgJOgI4ASJFChtSZXBvcnRDbHVzdGVyU3RhdHVzUmVzcG9uc2USCwoDYWNrGAEgASgIEhkKEW5leHRfcHVzaF9zZWNvbmRzGAIgASgFIoABChRMaXN0V29ya2xvYWRzUmVxdWVzdBIcCgpjbHVzdGVyX2lkGAEgASgJQgi6SAVyA7ABARIYCgZmaWx0ZXIYAiABKAlCCLpIBXIDGIAIEhwKCXBhZ2Vfc2l6ZRgDIAEoBUIJukgGGgQYZCgAEhIKCnBhZ2VfdG9rZW4YBCABKAkiZQoVTGlzdFdvcmtsb2Fkc1Jlc3BvbnNlEjMKCXdvcmtsb2FkcxgBIAMoCzIgLmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEuV29ya2xvYWQSFwoPbmV4dF9wYWdlX3Rva2VuGAIgASgJIqcBChtSZXBvcnRXb3JrbG9hZFN0YXR1c1JlcXVlc3QSHAoKY2x1c3Rlcl9pZBgBIAEoCUIIukgFcgOwAQESOQoJd29ya2xvYWRzGAIgAygLMiYuYWRtaXJhbC5hcGkuY2x1c3Rlci52MS5Xb3JrbG9hZFN0YXR1cxIvCgtyZXBvcnRlZF9hdBgDIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAiKwocUmVwb3J0V29ya2xvYWRTdGF0dXNSZXNwb25zZRILCgNhY2sYASABKAgipQEKGUNyZWF0ZUNsdXN0ZXJUb2tlblJlcXVlc3QSHAoKY2x1c3Rlcl9pZBgBIAEoCUIIukgFcgOwAQESOgoEbmFtZRgCIAEoCUIsukgpcicQARg/MiFeW2Etel0oW2EtejAtOS1dezAsNjF9W2EtejAtOV0pPyQSLgoKZXhwaXJlc19hdBgDIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAibAoaQ3JlYXRlQ2x1c3RlclRva2VuUmVzcG9uc2USNAoMYWNjZXNzX3Rva2VuGAEgASgLMh4uYWRtaXJhbC5jb21tb24udjEuQWNjZXNzVG9rZW4SGAoQcGxhaW5fdGV4dF90b2tlbhgCIAEoCSKEAQoYTGlzdENsdXN0ZXJUb2tlbnNSZXF1ZXN0EhwKCmNsdXN0ZXJfaWQYASABKAlCCLpIBXIDsAEBEhgKBmZpbHRlchgCIAEoCUIIukgFcgMYgAgSHAoJcGFnZV9zaXplGAMgASgFQgm6SAYaBBhkKAASEgoKcGFnZV90b2tlbhgEIAEoCSJrChlMaXN0Q2x1c3RlclRva2Vuc1Jlc3BvbnNlEjUKDWFjY2Vzc190b2tlbnMYASADKAsyHi5hZG1pcmFsLmNvbW1vbi52MS5BY2Nlc3NUb2tlbhIXCg9uZXh0X3BhZ2VfdG9rZW4YAiABKAkiUgoWR2V0Q2x1c3RlclRva2VuUmVxdWVzdBIcCgpjbHVzdGVyX2lkGAEgASgJQgi6SAVyA7ABARIaCgh0b2tlbl9pZBgCIAEoCUIIukgFcgOwAQEiTwoXR2V0Q2x1c3RlclRva2VuUmVzcG9uc2USNAoMYWNjZXNzX3Rva2VuGAEgASgLMh4uYWRtaXJhbC5jb21tb24udjEuQWNjZXNzVG9rZW4iVQoZUmV2b2tlQ2x1c3RlclRva2VuUmVxdWVzdBIcCgpjbHVzdGVyX2lkGAEgASgJQgi6SAVyA7ABARIaCgh0b2tlbl9pZBgCIAEoCUIIukgFcgOwAQEiUgoaUmV2b2tlQ2x1c3RlclRva2VuUmVzcG9uc2USNAoMYWNjZXNzX3Rva2VuGAEgASgLMh4uYWRtaXJhbC5jb21tb24udjEuQWNjZXNzVG9rZW4ifQoOUmV2aXNpb25CdW5kbGUSFAoMYXJ0aWZhY3RfdXJsGAEgASgJEhkKEWFydGlmYWN0X2NoZWNrc3VtGAIgASgJEhEKCW5hbWVzcGFjZRgDIAEoCRIWCg5jb21wb25lbnRfbmFtZRgEIAEoCRIPCgd2ZXJzaW9uGAUgASgJIm0KDlJldmlzaW9uUmVzdWx0Eg8KB3N1Y2Nlc3MYASABKAgSFQoNZXJyb3JfbWVzc2FnZRgCIAEoCRIZChFyZXNvdXJjZXNfYXBwbGllZBgDIAEoBRIYChByZXNvdXJjZXNfZmFpbGVkGAQgASgFIjkKGEdldFJldmlzaW9uQnVuZGxlUmVxdWVzdBIdCgtyZXZpc2lvbl9pZBgBIAEoCUIIukgFcgOwAQEiUwoZR2V0UmV2aXNpb25CdW5kbGVSZXNwb25zZRI2CgZidW5kbGUYASABKAsyJi5hZG1pcmFsLmFwaS5jbHVzdGVyLnYxLlJldmlzaW9uQnVuZGxlInwKG1JlcG9ydFJldmlzaW9uUmVzdWx0UmVxdWVzdBIdCgtyZXZpc2lvbl9pZBgBIAEoCUIIukgFcgOwAQESPgoGcmVzdWx0GAIgASgLMiYuYWRtaXJhbC5hcGkuY2x1c3Rlci52MS5SZXZpc2lvblJlc3VsdEIGukgDyAEBIisKHFJlcG9ydFJldmlzaW9uUmVzdWx0UmVzcG9uc2USCwoDYWNrGAEgASgIKu4BChNDbHVzdGVySGVhbHRoU3RhdHVzEiUKIUNMVVNURVJfSEVBTFRIX1NUQVRVU19VTlNQRUNJRklFRBAAEiEKHUNMVVNURVJfSEVBTFRIX1NUQVRVU19QRU5ESU5HEAESIQodQ0xVU1RFUl9IRUFMVEhfU1RBVFVTX0hFQUxUSFkQAhIiCh5DTFVTVEVSX0hFQUxUSF9TVEFUVVNfREVHUkFERUQQAxIfChtDTFVTVEVSX0hFQUxUSF9TVEFUVVNfRVJST1IQBBIlCiFDTFVTVEVSX0hFQUxUSF9TVEFUVVNfVU5SRUFDSEFCTEUQBSqpAQoUV29ya2xvYWRIZWFsdGhTdGF0dXMSJgoiV09SS0xPQURfSEVBTFRIX1NUQVRVU19VTlNQRUNJRklFRBAAEiIKHldPUktMT0FEX0hFQUxUSF9TVEFUVVNfSEVBTFRIWRABEiMKH1dPUktMT0FEX0hFQUxUSF9TVEFUVVNfREVHUkFERUQQAhIgChxXT1JLTE9BRF9IRUFMVEhfU1RBVFVTX0VSUk9SEAMyqRUKCkNsdXN0ZXJBUEkSmAEKDUNyZWF0ZUNsdXN0ZXISLC5hZG1pcmFsLmFwaS5jbHVzdGVyLnYxLkNyZWF0ZUNsdXN0ZXJSZXF1ZXN0Gi0uYWRtaXJhbC5hcGkuY2x1c3Rlci52MS5DcmVhdGVDbHVzdGVyUmVzcG9uc2UiKqKXJA8KDWNsdXN0ZXI6d3JpdGWC0+STAhE6ASoiDC92MS9jbHVzdGVycxKYAQoKR2V0Q2x1c3RlchIpLmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEuR2V0Q2x1c3RlclJlcXVlc3QaKi5hZG1pcmFsLmFwaS5jbHVzdGVyLnYxLkdldENsdXN0ZXJSZXNwb25zZSIzopckDgoMY2x1c3RlcjpyZWFkgtPkkwIbEhkvdjEvY2x1c3RlcnMve2NsdXN0ZXJfaWR9ErEBChBHZXRDbHVzdGVyU3RhdHVzEi8uYWRtaXJhbC5hcGkuY2x1c3Rlci52MS5HZXRDbHVzdGVyU3RhdHVzUmVxdWVzdBowLmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEuR2V0Q2x1c3RlclN0YXR1c1Jlc3BvbnNlIjqilyQOCgxjbHVzdGVyOnJlYWSC0+STAiISIC92MS9jbHVzdGVycy97Y2x1c3Rlcl9pZH0vc3RhdHVzEpEBCgxMaXN0Q2x1c3RlcnMSKy5hZG1pcmFsLmFwaS5jbHVzdGVyLnYxLkxpc3RDbHVzdGVyc1JlcXVlc3QaLC5hZG1pcmFsLmFwaS5jbHVzdGVyLnYxLkxpc3RDbHVzdGVyc1Jlc3BvbnNlIiailyQOCgxjbHVzdGVyOnJlYWSC0+STAg4SDC92MS9jbHVzdGVycxKlAQoNVXBkYXRlQ2x1c3RlchIsLmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEuVXBkYXRlQ2x1c3RlclJlcXVlc3QaLS5hZG1pcmFsLmFwaS5jbHVzdGVyLnYxLlVwZGF0ZUNsdXN0ZXJSZXNwb25zZSI3opckDwoNY2x1c3Rlcjp3cml0ZYLT5JMCHjoBKjIZL3YxL2NsdXN0ZXJzL3tjbHVzdGVyLmlkfRKiAQoNRGVsZXRlQ2x1c3RlchIsLmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEuRGVsZXRlQ2x1c3RlclJlcXVlc3QaLS5hZG1pcmFsLmFwaS5jbHVzdGVyLnYxLkRlbGV0ZUNsdXN0ZXJSZXNwb25zZSI0opckDwoNY2x1c3Rlcjp3cml0ZYLT5JMCGyoZL3YxL2NsdXN0ZXJzL3tjbHVzdGVyX2lkfRK7AQoSQ3JlYXRlQ2x1c3RlclRva2VuEjEuYWRtaXJhbC5hcGkuY2x1c3Rlci52MS5DcmVhdGVDbHVzdGVyVG9rZW5SZXF1ZXN0GjIuYWRtaXJhbC5hcGkuY2x1c3Rlci52MS5DcmVhdGVDbHVzdGVyVG9rZW5SZXNwb25zZSI+opckDwoNY2x1c3Rlcjp3cml0ZYLT5JMCJToBKiIgL3YxL2NsdXN0ZXJzL3tjbHVzdGVyX2lkfS90b2tlbnMStAEKEUxpc3RDbHVzdGVyVG9rZW5zEjAuYWRtaXJhbC5hcGkuY2x1c3Rlci52MS5MaXN0Q2x1c3RlclRva2Vuc1JlcXVlc3QaMS5hZG1pcmFsLmFwaS5jbHVzdGVyLnYxLkxpc3RDbHVzdGVyVG9rZW5zUmVzcG9uc2UiOqKXJA4KDGNsdXN0ZXI6cmVhZILT5JMCIhIgL3YxL2NsdXN0ZXJzL3tjbHVzdGVyX2lkfS90b2tlbnMSuQEKD0dldENsdXN0ZXJUb2tlbhIuLmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEuR2V0Q2x1c3RlclRva2VuUmVxdWVzdBovLmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEuR2V0Q2x1c3RlclRva2VuUmVzcG9uc2UiRaKXJA4KDGNsdXN0ZXI6cmVhZILT5JMCLRIrL3YxL2NsdXN0ZXJzL3tjbHVzdGVyX2lkfS90b2tlbnMve3Rva2VuX2lkfRLNAQoSUmV2b2tlQ2x1c3RlclRva2VuEjEuYWRtaXJhbC5hcGkuY2x1c3Rlci52MS5SZXZva2VDbHVzdGVyVG9rZW5SZXF1ZXN0GjIuYWRtaXJhbC5hcGkuY2x1c3Rlci52MS5SZXZva2VDbHVzdGVyVG9rZW5SZXNwb25zZSJQopckDwoNY2x1c3Rlcjp3cml0ZYLT5JMCNzoBKiIyL3YxL2NsdXN0ZXJzL3tjbHVzdGVyX2lkfS90b2tlbnMve3Rva2VuX2lkfS9yZXZva2UStAEKE1JlcG9ydENsdXN0ZXJTdGF0dXMSMi5hZG1pcmFsLmFwaS5jbHVzdGVyLnYxLlJlcG9ydENsdXN0ZXJTdGF0dXNSZXF1ZXN0GjMuYWRtaXJhbC5hcGkuY2x1c3Rlci52MS5SZXBvcnRDbHVzdGVyU3RhdHVzUmVzcG9uc2UiNKKXJBUKDmNsdXN0ZXI6c3RhdHVzEgNhZ3SC0+STAhU6ASoiEC92MS9hZ2VudC9zdGF0dXMSqwEKDUxpc3RXb3JrbG9hZHMSLC5hZG1pcmFsLmFwaS5jbHVzdGVyLnYxLkxpc3RXb3JrbG9hZHNSZXF1ZXN0Gi0uYWRtaXJhbC5hcGkuY2x1c3Rlci52MS5MaXN0V29ya2xvYWRzUmVzcG9uc2UiPaKXJA4KDGNsdXN0ZXI6cmVhZILT5JMCJRIjL3YxL2NsdXN0ZXJzL3tjbHVzdGVyX2lkfS93b3JrbG9hZHMS0QEKFFJlcG9ydFdvcmtsb2FkU3RhdHVzEjMuYWRtaXJhbC5hcGkuY2x1c3Rlci52MS5SZXBvcnRXb3JrbG9hZFN0YXR1c1JlcXVlc3QaNC5hZG1pcmFsLmFwaS5jbHVzdGVyLnYxLlJlcG9ydFdvcmtsb2FkU3RhdHVzUmVzcG9uc2UiTqKXJBUKDmNsdXN0ZXI6c3RhdHVzEgNhZ3SC0+STAi86ASoiKi92MS9jbHVzdGVycy97Y2x1c3Rlcl9pZH0vd29ya2xvYWRzL3N0YXR1cxLDAQoRR2V0UmV2aXNpb25CdW5kbGUSMC5hZG1pcmFsLmFwaS5jbHVzdGVyLnYxLkdldFJldmlzaW9uQnVuZGxlUmVxdWVzdBoxLmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEuR2V0UmV2aXNpb25CdW5kbGVSZXNwb25zZSJJopckFQoOY2x1c3RlcjpkZXBsb3kSA2FndILT5JMCKhIoL3YxL2FnZW50L3JldmlzaW9ucy97cmV2aXNpb25faWR9L2J1bmRsZRLPAQoUUmVwb3J0UmV2aXNpb25SZXN1bHQSMy5hZG1pcmFsLmFwaS5jbHVzdGVyLnYxLlJlcG9ydFJldmlzaW9uUmVzdWx0UmVxdWVzdBo0LmFkbWlyYWwuYXBpLmNsdXN0ZXIudjEuUmVwb3J0UmV2aXNpb25SZXN1bHRSZXNwb25zZSJMopckFQoOY2x1c3RlcjpkZXBsb3kSA2FndILT5JMCLToBKiIoL3YxL2FnZW50L3JldmlzaW9ucy97cmV2aXNpb25faWR9L3Jlc3VsdELfAQoaY29tLmFkbWlyYWwuYXBpLmNsdXN0ZXIudjFCDENsdXN0ZXJQcm90b1ABWjhnby5hZG1pcmFsLmlvL3Nkay9wcm90by9hZG1pcmFsL2FwaS9jbHVzdGVyL3YxO2NsdXN0ZXJ2MaICA0FBQ6oCFkFkbWlyYWwuQXBpLkNsdXN0ZXIuVjHKAhZBZG1pcmFsXEFwaVxDbHVzdGVyXFYx4gIiQWRtaXJhbFxBcGlcQ2x1c3RlclxWMVxHUEJNZXRhZGF0YeoCGUFkbWlyYWw6OkFwaTo6Q2x1c3Rlcjo6VjFiBnByb3RvMw", [file_admiral_common_v1_annotations, file_admiral_common_v1_token, file_buf_validate_validate, file_google_api_annotations, file_google_protobuf_field_mask, file_google_protobuf_timestamp]);

/**
 * Cluster represents a registered Kubernetes cluster within a tenant.
 *
 * @generated from message admiral.api.cluster.v1.Cluster
 */
export type Cluster = Message<"admiral.api.cluster.v1.Cluster"> & {
  /**
   * Unique identifier for the cluster (UUID).
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * Tenant this cluster belongs to (UUID).
   *
   * @generated from field: string tenant_id = 2;
   */
  tenantId: string;

  /**
   * URL-safe, human-readable identifier (e.g., "prod-us-east-1"). Unique
   * within the tenant. Lowercase alphanumeric and hyphens only, must start
   * with a letter and end with an alphanumeric character (1-63 chars).
   *
   * @generated from field: string name = 3;
   */
  name: string;

  /**
   * Optional longer-form description of the cluster's purpose
   * (e.g., "Primary production cluster serving US East traffic").
   *
   * @generated from field: string description = 4;
   */
  description: string;

  /**
   * Arbitrary key-value labels for organizing and filtering clusters
   * (e.g., `{"region": "us-east-1", "cloud": "aws"}`).
   *
   * @generated from field: map<string, string> labels = 5;
   */
  labels: { [key: string]: string };

  /**
   * The Kubernetes kube-system namespace UID, bound at agent registration
   * using a first-write-wins strategy. Used to detect when a token is
   * accidentally deployed to a different physical cluster.
   *
   * @generated from field: string cluster_uid = 6;
   */
  clusterUid: string;

  /**
   * Derived health status based on agent connectivity and workload state.
   *
   * @generated from field: admiral.api.cluster.v1.ClusterHealthStatus health_status = 7;
   */
  healthStatus: ClusterHealthStatus;

  /**
   * User ID who created this cluster (UUID, server-populated from token).
   *
   * @generated from field: string created_by = 10;
   */
  createdBy: string;

  /**
   * User ID who last updated this cluster (UUID, server-populated from token).
   *
   * @generated from field: string updated_by = 11;
   */
  updatedBy: string;

  /**
   * When the cluster record was created.
   *
   * @generated from field: google.protobuf.Timestamp created_at = 8;
   */
  createdAt?: Timestamp;

  /**
   * When the cluster record was last updated.
   *
   * @generated from field: google.protobuf.Timestamp updated_at = 9;
   */
  updatedAt?: Timestamp;
};

/**
 * Describes the message admiral.api.cluster.v1.Cluster.
 * Use `create(ClusterSchema)` to create a new message.
 */
export const ClusterSchema: GenMessage<Cluster> = /*@__PURE__*/
  messageDesc(file_admiral_api_cluster_v1_cluster, 0);

/**
 * ClusterStatus contains the raw telemetry metrics for a cluster, as reported
 * by the K8s agent. This message is used in both the push payload
 * (ReportClusterStatusRequest) and the read response (GetClusterStatusResponse).
 *
 * Server-derived fields (health_status, agent connectivity) are NOT included
 * here — they live on the Cluster and Agent records respectively, and are
 * returned alongside this message in GetClusterStatusResponse.
 *
 * @generated from message admiral.api.cluster.v1.ClusterStatus
 */
export type ClusterStatus = Message<"admiral.api.cluster.v1.ClusterStatus"> & {
  /**
   * Kubernetes version reported by the agent (e.g., "1.29.2").
   *
   * @generated from field: string k8s_version = 1;
   */
  k8sVersion: string;

  /**
   * Total number of nodes in the cluster.
   *
   * @generated from field: int32 node_count = 2;
   */
  nodeCount: number;

  /**
   * Number of nodes in Ready condition.
   *
   * @generated from field: int32 nodes_ready = 3;
   */
  nodesReady: number;

  /**
   * Maximum number of pods the cluster can schedule.
   *
   * @generated from field: int32 pod_capacity = 4;
   */
  podCapacity: number;

  /**
   * Total number of pods across all namespaces.
   *
   * @generated from field: int32 pod_count = 5;
   */
  podCount: number;

  /**
   * Number of pods in Running phase.
   *
   * @generated from field: int32 pods_running = 6;
   */
  podsRunning: number;

  /**
   * Number of pods in Pending phase.
   *
   * @generated from field: int32 pods_pending = 7;
   */
  podsPending: number;

  /**
   * Number of pods in Failed phase.
   *
   * @generated from field: int32 pods_failed = 8;
   */
  podsFailed: number;

  /**
   * Total CPU capacity across all nodes, in millicores.
   *
   * @generated from field: int64 cpu_capacity_millicores = 9;
   */
  cpuCapacityMillicores: bigint;

  /**
   * Current CPU usage across all nodes, in millicores.
   *
   * @generated from field: int64 cpu_used_millicores = 10;
   */
  cpuUsedMillicores: bigint;

  /**
   * Total memory capacity across all nodes, in bytes.
   *
   * @generated from field: int64 memory_capacity_bytes = 11;
   */
  memoryCapacityBytes: bigint;

  /**
   * Current memory usage across all nodes, in bytes.
   *
   * @generated from field: int64 memory_used_bytes = 12;
   */
  memoryUsedBytes: bigint;

  /**
   * Total number of tracked workloads.
   *
   * @generated from field: int32 workloads_total = 13;
   */
  workloadsTotal: number;

  /**
   * Number of workloads in healthy state.
   *
   * @generated from field: int32 workloads_healthy = 14;
   */
  workloadsHealthy: number;

  /**
   * Number of workloads in degraded state.
   *
   * @generated from field: int32 workloads_degraded = 15;
   */
  workloadsDegraded: number;

  /**
   * Number of workloads in error state.
   *
   * @generated from field: int32 workloads_error = 16;
   */
  workloadsError: number;
};

/**
 * Describes the message admiral.api.cluster.v1.ClusterStatus.
 * Use `create(ClusterStatusSchema)` to create a new message.
 */
export const ClusterStatusSchema: GenMessage<ClusterStatus> = /*@__PURE__*/
  messageDesc(file_admiral_api_cluster_v1_cluster, 1);

/**
 * Workload represents a Kubernetes workload (Deployment, StatefulSet,
 * DaemonSet, etc.) as observed by the agent.
 *
 * @generated from message admiral.api.cluster.v1.Workload
 */
export type Workload = Message<"admiral.api.cluster.v1.Workload"> & {
  /**
   * Unique identifier for the workload within Admiral (UUID).
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * The cluster this workload belongs to (UUID).
   *
   * @generated from field: string cluster_id = 2;
   */
  clusterId: string;

  /**
   * Kubernetes namespace.
   *
   * @generated from field: string namespace = 3;
   */
  namespace: string;

  /**
   * Workload name.
   *
   * @generated from field: string name = 4;
   */
  name: string;

  /**
   * Kubernetes resource kind (e.g., "Deployment", "StatefulSet", "DaemonSet").
   *
   * @generated from field: string kind = 5;
   */
  kind: string;

  /**
   * Kubernetes labels on the workload.
   *
   * @generated from field: map<string, string> labels = 6;
   */
  labels: { [key: string]: string };

  /**
   * Derived health status.
   *
   * @generated from field: admiral.api.cluster.v1.WorkloadHealthStatus health_status = 7;
   */
  healthStatus: WorkloadHealthStatus;

  /**
   * Human-readable reason for the current status (e.g., "MinimumReplicasUnavailable").
   *
   * @generated from field: string status_reason = 8;
   */
  statusReason: string;

  /**
   * Number of desired replicas.
   *
   * @generated from field: int32 replicas_desired = 9;
   */
  replicasDesired: number;

  /**
   * Number of ready replicas.
   *
   * @generated from field: int32 replicas_ready = 10;
   */
  replicasReady: number;

  /**
   * Number of available replicas.
   *
   * @generated from field: int32 replicas_available = 11;
   */
  replicasAvailable: number;

  /**
   * CPU requests across all containers, in millicores.
   *
   * @generated from field: int64 cpu_requests_millicores = 12;
   */
  cpuRequestsMillicores: bigint;

  /**
   * CPU limits across all containers, in millicores.
   *
   * @generated from field: int64 cpu_limits_millicores = 13;
   */
  cpuLimitsMillicores: bigint;

  /**
   * Current CPU usage across all containers, in millicores.
   *
   * @generated from field: int64 cpu_used_millicores = 14;
   */
  cpuUsedMillicores: bigint;

  /**
   * Memory requests across all containers, in bytes.
   *
   * @generated from field: int64 memory_requests_bytes = 15;
   */
  memoryRequestsBytes: bigint;

  /**
   * Memory limits across all containers, in bytes.
   *
   * @generated from field: int64 memory_limits_bytes = 16;
   */
  memoryLimitsBytes: bigint;

  /**
   * Current memory usage across all containers, in bytes.
   *
   * @generated from field: int64 memory_used_bytes = 17;
   */
  memoryUsedBytes: bigint;

  /**
   * Status of individual containers in this workload.
   *
   * @generated from field: repeated admiral.api.cluster.v1.ContainerStatus containers = 18;
   */
  containers: ContainerStatus[];

  /**
   * When this workload's status was last updated.
   *
   * @generated from field: google.protobuf.Timestamp last_updated_at = 19;
   */
  lastUpdatedAt?: Timestamp;
};

/**
 * Describes the message admiral.api.cluster.v1.Workload.
 * Use `create(WorkloadSchema)` to create a new message.
 */
export const WorkloadSchema: GenMessage<Workload> = /*@__PURE__*/
  messageDesc(file_admiral_api_cluster_v1_cluster, 2);

/**
 * ContainerStatus describes the current state of a single container.
 *
 * @generated from message admiral.api.cluster.v1.ContainerStatus
 */
export type ContainerStatus = Message<"admiral.api.cluster.v1.ContainerStatus"> & {
  /**
   * Container name within the pod spec.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Container image reference (e.g., "registry.example.com/api:v2.1.4").
   *
   * @generated from field: string image = 2;
   */
  image: string;

  /**
   * Cumulative number of container restarts.
   *
   * @generated from field: int32 restart_count = 3;
   */
  restartCount: number;

  /**
   * Current container state (e.g., "running", "waiting", "terminated").
   *
   * @generated from field: string state = 4;
   */
  state: string;

  /**
   * Whether the container's readiness probe is passing.
   *
   * @generated from field: bool ready = 5;
   */
  ready: boolean;
};

/**
 * Describes the message admiral.api.cluster.v1.ContainerStatus.
 * Use `create(ContainerStatusSchema)` to create a new message.
 */
export const ContainerStatusSchema: GenMessage<ContainerStatus> = /*@__PURE__*/
  messageDesc(file_admiral_api_cluster_v1_cluster, 3);

/**
 * ObjectReference is a lightweight reference to a Kubernetes object.
 *
 * @generated from message admiral.api.cluster.v1.ObjectReference
 */
export type ObjectReference = Message<"admiral.api.cluster.v1.ObjectReference"> & {
  /**
   * Kubernetes resource kind (e.g., "Pod", "ReplicaSet").
   *
   * @generated from field: string kind = 1;
   */
  kind: string;

  /**
   * Kubernetes namespace.
   *
   * @generated from field: string namespace = 2;
   */
  namespace: string;

  /**
   * Object name.
   *
   * @generated from field: string name = 3;
   */
  name: string;
};

/**
 * Describes the message admiral.api.cluster.v1.ObjectReference.
 * Use `create(ObjectReferenceSchema)` to create a new message.
 */
export const ObjectReferenceSchema: GenMessage<ObjectReference> = /*@__PURE__*/
  messageDesc(file_admiral_api_cluster_v1_cluster, 4);

/**
 * WorkloadEvent represents a Kubernetes event related to a workload or its
 * child objects (pods, replicasets). Events are deduplicated by their K8s UID.
 *
 * @generated from message admiral.api.cluster.v1.WorkloadEvent
 */
export type WorkloadEvent = Message<"admiral.api.cluster.v1.WorkloadEvent"> & {
  /**
   * Kubernetes event UID, used for deduplication.
   *
   * @generated from field: string uid = 1;
   */
  uid: string;

  /**
   * Event type: "Normal" or "Warning".
   *
   * @generated from field: string type = 2;
   */
  type: string;

  /**
   * Short machine-readable reason (e.g., "BackOff", "FailedScheduling").
   *
   * @generated from field: string reason = 3;
   */
  reason: string;

  /**
   * The Kubernetes object this event is about.
   *
   * @generated from field: admiral.api.cluster.v1.ObjectReference regarding = 4;
   */
  regarding?: ObjectReference;

  /**
   * Human-readable event message.
   *
   * @generated from field: string message = 5;
   */
  message: string;

  /**
   * When this event was first observed.
   *
   * @generated from field: google.protobuf.Timestamp first_seen = 6;
   */
  firstSeen?: Timestamp;

  /**
   * When this event was most recently observed.
   *
   * @generated from field: google.protobuf.Timestamp last_seen = 7;
   */
  lastSeen?: Timestamp;

  /**
   * Number of times this event has occurred.
   *
   * @generated from field: int32 count = 8;
   */
  count: number;
};

/**
 * Describes the message admiral.api.cluster.v1.WorkloadEvent.
 * Use `create(WorkloadEventSchema)` to create a new message.
 */
export const WorkloadEventSchema: GenMessage<WorkloadEvent> = /*@__PURE__*/
  messageDesc(file_admiral_api_cluster_v1_cluster, 5);

/**
 * CreateClusterRequest contains the parameters for creating a new cluster.
 *
 * @generated from message admiral.api.cluster.v1.CreateClusterRequest
 */
export type CreateClusterRequest = Message<"admiral.api.cluster.v1.CreateClusterRequest"> & {
  /**
   * URL-safe, human-readable identifier (e.g., "prod-us-east-1"). Must be
   * unique within the tenant. Lowercase alphanumeric and hyphens only.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Optional longer-form description of the cluster's purpose.
   *
   * @generated from field: string description = 2;
   */
  description: string;

  /**
   * Arbitrary key-value labels for organizing and filtering clusters
   * (e.g., `{"region": "us-east-1", "cloud": "aws"}`).
   *
   * @generated from field: map<string, string> labels = 3;
   */
  labels: { [key: string]: string };
};

/**
 * Describes the message admiral.api.cluster.v1.CreateClusterRequest.
 * Use `create(CreateClusterRequestSchema)` to create a new message.
 */
export const CreateClusterRequestSchema: GenMessage<CreateClusterRequest> = /*@__PURE__*/
  messageDesc(file_admiral_api_cluster_v1_cluster, 6);

/**
 * CreateClusterResponse contains the newly created cluster and its initial
 * Agent Token (AGT).
 *
 * @generated from message admiral.api.cluster.v1.CreateClusterResponse
 */
export type CreateClusterResponse = Message<"admiral.api.cluster.v1.CreateClusterResponse"> & {
  /**
   * The created cluster. Health status will be PENDING until an agent connects
   * and calls AgentAPI.RegisterAgent.
   *
   * @generated from field: admiral.api.cluster.v1.Cluster cluster = 1;
   */
  cluster?: Cluster;

  /**
   * The raw Agent Token secret (e.g., "adm_agt_pL2mN5oQ8rS1..."). This value
   * is shown exactly once and cannot be retrieved again. Deploy this token to
   * the K8s agent for authentication.
   *
   * To create additional tokens (e.g., for rotation), use
   * CreateClusterToken (POST /v1/clusters/{cluster_id}/tokens).
   *
   * @generated from field: string plain_text_token = 2;
   */
  plainTextToken: string;
};

/**
 * Describes the message admiral.api.cluster.v1.CreateClusterResponse.
 * Use `create(CreateClusterResponseSchema)` to create a new message.
 */
export const CreateClusterResponseSchema: GenMessage<CreateClusterResponse> = /*@__PURE__*/
  messageDesc(file_admiral_api_cluster_v1_cluster, 7);

/**
 * GetClusterRequest identifies a cluster to retrieve.
 *
 * @generated from message admiral.api.cluster.v1.GetClusterRequest
 */
export type GetClusterRequest = Message<"admiral.api.cluster.v1.GetClusterRequest"> & {
  /**
   * The unique identifier of the cluster (UUID).
   *
   * @generated from field: string cluster_id = 1;
   */
  clusterId: string;
};

/**
 * Describes the message admiral.api.cluster.v1.GetClusterRequest.
 * Use `create(GetClusterRequestSchema)` to create a new message.
 */
export const GetClusterRequestSchema: GenMessage<GetClusterRequest> = /*@__PURE__*/
  messageDesc(file_admiral_api_cluster_v1_cluster, 8);

/**
 * GetClusterResponse contains the cluster record.
 *
 * @generated from message admiral.api.cluster.v1.GetClusterResponse
 */
export type GetClusterResponse = Message<"admiral.api.cluster.v1.GetClusterResponse"> & {
  /**
   * The cluster record, including server-derived health_status.
   *
   * @generated from field: admiral.api.cluster.v1.Cluster cluster = 1;
   */
  cluster?: Cluster;
};

/**
 * Describes the message admiral.api.cluster.v1.GetClusterResponse.
 * Use `create(GetClusterResponseSchema)` to create a new message.
 */
export const GetClusterResponseSchema: GenMessage<GetClusterResponse> = /*@__PURE__*/
  messageDesc(file_admiral_api_cluster_v1_cluster, 9);

/**
 * ListClustersRequest contains pagination and filter parameters.
 *
 * @generated from message admiral.api.cluster.v1.ListClustersRequest
 */
export type ListClustersRequest = Message<"admiral.api.cluster.v1.ListClustersRequest"> & {
  /**
   * Filter expression using the PEG filter DSL
   *
   * @generated from field: string filter = 1;
   */
  filter: string;

  /**
   * Maximum number of clusters to return per page.
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize: number;

  /**
   * Opaque pagination token from a previous response.
   *
   * @generated from field: string page_token = 3;
   */
  pageToken: string;
};

/**
 * Describes the message admiral.api.cluster.v1.ListClustersRequest.
 * Use `create(ListClustersRequestSchema)` to create a new message.
 */
export const ListClustersRequestSchema: GenMessage<ListClustersRequest> = /*@__PURE__*/
  messageDesc(file_admiral_api_cluster_v1_cluster, 10);

/**
 * ListClustersResponse contains a page of clusters.
 *
 * @generated from message admiral.api.cluster.v1.ListClustersResponse
 */
export type ListClustersResponse = Message<"admiral.api.cluster.v1.ListClustersResponse"> & {
  /**
   * The list of clusters.
   *
   * @generated from field: repeated admiral.api.cluster.v1.Cluster clusters = 1;
   */
  clusters: Cluster[];

  /**
   * Pagination token for the next page. Empty when there are no more results.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;
};

/**
 * Describes the message admiral.api.cluster.v1.ListClustersResponse.
 * Use `create(ListClustersResponseSchema)` to create a new message.
 */
export const ListClustersResponseSchema: GenMessage<ListClustersResponse> = /*@__PURE__*/
  messageDesc(file_admiral_api_cluster_v1_cluster, 11);

/**
 * UpdateClusterRequest contains the cluster fields to update.
 *
 * @generated from message admiral.api.cluster.v1.UpdateClusterRequest
 */
export type UpdateClusterRequest = Message<"admiral.api.cluster.v1.UpdateClusterRequest"> & {
  /**
   * The cluster with updated fields. The `id` field is required.
   * Only fields specified in `update_mask` are updated.
   *
   * @generated from field: admiral.api.cluster.v1.Cluster cluster = 1;
   */
  cluster?: Cluster;

  /**
   * The set of fields to update. If unset, all mutable fields are updated.
   * Supported fields: `name`, `description`, `labels`.
   *
   * @generated from field: google.protobuf.FieldMask update_mask = 2;
   */
  updateMask?: FieldMask;
};

/**
 * Describes the message admiral.api.cluster.v1.UpdateClusterRequest.
 * Use `create(UpdateClusterRequestSchema)` to create a new message.
 */
export const UpdateClusterRequestSchema: GenMessage<UpdateClusterRequest> = /*@__PURE__*/
  messageDesc(file_admiral_api_cluster_v1_cluster, 12);

/**
 * UpdateClusterResponse contains the updated cluster.
 *
 * @generated from message admiral.api.cluster.v1.UpdateClusterResponse
 */
export type UpdateClusterResponse = Message<"admiral.api.cluster.v1.UpdateClusterResponse"> & {
  /**
   * The updated cluster.
   *
   * @generated from field: admiral.api.cluster.v1.Cluster cluster = 1;
   */
  cluster?: Cluster;
};

/**
 * Describes the message admiral.api.cluster.v1.UpdateClusterResponse.
 * Use `create(UpdateClusterResponseSchema)` to create a new message.
 */
export const UpdateClusterResponseSchema: GenMessage<UpdateClusterResponse> = /*@__PURE__*/
  messageDesc(file_admiral_api_cluster_v1_cluster, 13);

/**
 * DeleteClusterRequest identifies a cluster to delete.
 *
 * @generated from message admiral.api.cluster.v1.DeleteClusterRequest
 */
export type DeleteClusterRequest = Message<"admiral.api.cluster.v1.DeleteClusterRequest"> & {
  /**
   * The unique identifier of the cluster to delete (UUID).
   * All associated agent tokens will be revoked.
   *
   * @generated from field: string cluster_id = 1;
   */
  clusterId: string;
};

/**
 * Describes the message admiral.api.cluster.v1.DeleteClusterRequest.
 * Use `create(DeleteClusterRequestSchema)` to create a new message.
 */
export const DeleteClusterRequestSchema: GenMessage<DeleteClusterRequest> = /*@__PURE__*/
  messageDesc(file_admiral_api_cluster_v1_cluster, 14);

/**
 * DeleteClusterResponse is empty on success.
 *
 * @generated from message admiral.api.cluster.v1.DeleteClusterResponse
 */
export type DeleteClusterResponse = Message<"admiral.api.cluster.v1.DeleteClusterResponse"> & {
};

/**
 * Describes the message admiral.api.cluster.v1.DeleteClusterResponse.
 * Use `create(DeleteClusterResponseSchema)` to create a new message.
 */
export const DeleteClusterResponseSchema: GenMessage<DeleteClusterResponse> = /*@__PURE__*/
  messageDesc(file_admiral_api_cluster_v1_cluster, 15);

/**
 * GetClusterStatusRequest identifies a cluster whose telemetry status to retrieve.
 *
 * @generated from message admiral.api.cluster.v1.GetClusterStatusRequest
 */
export type GetClusterStatusRequest = Message<"admiral.api.cluster.v1.GetClusterStatusRequest"> & {
  /**
   * The unique identifier of the cluster (UUID).
   *
   * @generated from field: string cluster_id = 1;
   */
  clusterId: string;
};

/**
 * Describes the message admiral.api.cluster.v1.GetClusterStatusRequest.
 * Use `create(GetClusterStatusRequestSchema)` to create a new message.
 */
export const GetClusterStatusRequestSchema: GenMessage<GetClusterStatusRequest> = /*@__PURE__*/
  messageDesc(file_admiral_api_cluster_v1_cluster, 16);

/**
 * GetClusterStatusResponse contains the server-derived health status and the
 * latest telemetry snapshot. If no agent has reported telemetry yet, the
 * health_status will be PENDING and status will be absent.
 *
 * @generated from message admiral.api.cluster.v1.GetClusterStatusResponse
 */
export type GetClusterStatusResponse = Message<"admiral.api.cluster.v1.GetClusterStatusResponse"> & {
  /**
   * Server-derived health status based on agent connectivity, node readiness,
   * and workload health.
   *
   * @generated from field: admiral.api.cluster.v1.ClusterHealthStatus health_status = 1;
   */
  healthStatus: ClusterHealthStatus;

  /**
   * Latest telemetry snapshot from the agent. Absent if no telemetry has
   * been reported yet.
   *
   * @generated from field: admiral.api.cluster.v1.ClusterStatus status = 2;
   */
  status?: ClusterStatus;

  /**
   * When the latest telemetry was reported by the agent.
   *
   * @generated from field: google.protobuf.Timestamp reported_at = 3;
   */
  reportedAt?: Timestamp;
};

/**
 * Describes the message admiral.api.cluster.v1.GetClusterStatusResponse.
 * Use `create(GetClusterStatusResponseSchema)` to create a new message.
 */
export const GetClusterStatusResponseSchema: GenMessage<GetClusterStatusResponse> = /*@__PURE__*/
  messageDesc(file_admiral_api_cluster_v1_cluster, 17);

/**
 * ReportClusterStatusRequest contains a combined telemetry payload from a K8s agent.
 * Admiral splits this into three storage tiers: current snapshot, time-series
 * metrics, and events.
 *
 * The cluster is identified by the agent token's binding — no cluster_id is
 * required. The server resolves the cluster from the AGT.
 *
 * @generated from message admiral.api.cluster.v1.ReportClusterStatusRequest
 */
export type ReportClusterStatusRequest = Message<"admiral.api.cluster.v1.ReportClusterStatusRequest"> & {
  /**
   * Cluster-level telemetry snapshot.
   *
   * @generated from field: admiral.api.cluster.v1.ClusterStatus status = 1;
   */
  status?: ClusterStatus;

  /**
   * Per-workload status snapshots.
   *
   * @generated from field: repeated admiral.api.cluster.v1.WorkloadStatus workloads = 2;
   */
  workloads: WorkloadStatus[];

  /**
   * Kubernetes events observed since the last push.
   *
   * @generated from field: repeated admiral.api.cluster.v1.WorkloadEvent events = 3;
   */
  events: WorkloadEvent[];

  /**
   * When the agent generated this report.
   *
   * @generated from field: google.protobuf.Timestamp reported_at = 4;
   */
  reportedAt?: Timestamp;
};

/**
 * Describes the message admiral.api.cluster.v1.ReportClusterStatusRequest.
 * Use `create(ReportClusterStatusRequestSchema)` to create a new message.
 */
export const ReportClusterStatusRequestSchema: GenMessage<ReportClusterStatusRequest> = /*@__PURE__*/
  messageDesc(file_admiral_api_cluster_v1_cluster, 18);

/**
 * WorkloadStatus is the agent-reported status for a single workload within
 * a telemetry push payload.
 *
 * @generated from message admiral.api.cluster.v1.WorkloadStatus
 */
export type WorkloadStatus = Message<"admiral.api.cluster.v1.WorkloadStatus"> & {
  /**
   * Kubernetes namespace.
   *
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * Workload name.
   *
   * @generated from field: string name = 2;
   */
  name: string;

  /**
   * Kubernetes resource kind (e.g., "Deployment", "StatefulSet").
   *
   * @generated from field: string kind = 3;
   */
  kind: string;

  /**
   * Kubernetes labels on the workload.
   *
   * @generated from field: map<string, string> labels = 4;
   */
  labels: { [key: string]: string };

  /**
   * Number of desired replicas.
   *
   * @generated from field: int32 replicas_desired = 5;
   */
  replicasDesired: number;

  /**
   * Number of ready replicas.
   *
   * @generated from field: int32 replicas_ready = 6;
   */
  replicasReady: number;

  /**
   * Number of available replicas.
   *
   * @generated from field: int32 replicas_available = 7;
   */
  replicasAvailable: number;

  /**
   * CPU requests across all containers, in millicores.
   *
   * @generated from field: int64 cpu_requests_millicores = 8;
   */
  cpuRequestsMillicores: bigint;

  /**
   * CPU limits across all containers, in millicores.
   *
   * @generated from field: int64 cpu_limits_millicores = 9;
   */
  cpuLimitsMillicores: bigint;

  /**
   * Current CPU usage across all containers, in millicores.
   *
   * @generated from field: int64 cpu_used_millicores = 10;
   */
  cpuUsedMillicores: bigint;

  /**
   * Memory requests across all containers, in bytes.
   *
   * @generated from field: int64 memory_requests_bytes = 11;
   */
  memoryRequestsBytes: bigint;

  /**
   * Memory limits across all containers, in bytes.
   *
   * @generated from field: int64 memory_limits_bytes = 12;
   */
  memoryLimitsBytes: bigint;

  /**
   * Current memory usage across all containers, in bytes.
   *
   * @generated from field: int64 memory_used_bytes = 13;
   */
  memoryUsedBytes: bigint;

  /**
   * Derived health status.
   *
   * @generated from field: admiral.api.cluster.v1.WorkloadHealthStatus health_status = 14;
   */
  healthStatus: WorkloadHealthStatus;

  /**
   * Status of individual containers.
   *
   * @generated from field: repeated admiral.api.cluster.v1.ContainerStatus containers = 15;
   */
  containers: ContainerStatus[];
};

/**
 * Describes the message admiral.api.cluster.v1.WorkloadStatus.
 * Use `create(WorkloadStatusSchema)` to create a new message.
 */
export const WorkloadStatusSchema: GenMessage<WorkloadStatus> = /*@__PURE__*/
  messageDesc(file_admiral_api_cluster_v1_cluster, 19);

/**
 * ReportClusterStatusResponse acknowledges a telemetry push.
 *
 * @generated from message admiral.api.cluster.v1.ReportClusterStatusResponse
 */
export type ReportClusterStatusResponse = Message<"admiral.api.cluster.v1.ReportClusterStatusResponse"> & {
  /**
   * Whether the report was accepted.
   *
   * @generated from field: bool ack = 1;
   */
  ack: boolean;

  /**
   * Server-controlled interval (in seconds) before the agent should send
   * its next status push. Allows the server to adjust push frequency dynamically.
   *
   * @generated from field: int32 next_push_seconds = 2;
   */
  nextPushSeconds: number;
};

/**
 * Describes the message admiral.api.cluster.v1.ReportClusterStatusResponse.
 * Use `create(ReportClusterStatusResponseSchema)` to create a new message.
 */
export const ReportClusterStatusResponseSchema: GenMessage<ReportClusterStatusResponse> = /*@__PURE__*/
  messageDesc(file_admiral_api_cluster_v1_cluster, 20);

/**
 * ListWorkloadsRequest contains pagination and filter parameters for listing
 * workloads in a specific cluster.
 *
 * @generated from message admiral.api.cluster.v1.ListWorkloadsRequest
 */
export type ListWorkloadsRequest = Message<"admiral.api.cluster.v1.ListWorkloadsRequest"> & {
  /**
   * The cluster whose workloads to list (UUID).
   *
   * @generated from field: string cluster_id = 1;
   */
  clusterId: string;

  /**
   * Filter expression using the PEG filter DSL
   *
   * @generated from field: string filter = 2;
   */
  filter: string;

  /**
   * Maximum number of workloads to return per page.
   *
   * @generated from field: int32 page_size = 3;
   */
  pageSize: number;

  /**
   * Opaque pagination token from a previous response.
   *
   * @generated from field: string page_token = 4;
   */
  pageToken: string;
};

/**
 * Describes the message admiral.api.cluster.v1.ListWorkloadsRequest.
 * Use `create(ListWorkloadsRequestSchema)` to create a new message.
 */
export const ListWorkloadsRequestSchema: GenMessage<ListWorkloadsRequest> = /*@__PURE__*/
  messageDesc(file_admiral_api_cluster_v1_cluster, 21);

/**
 * ListWorkloadsResponse contains a page of workloads.
 *
 * @generated from message admiral.api.cluster.v1.ListWorkloadsResponse
 */
export type ListWorkloadsResponse = Message<"admiral.api.cluster.v1.ListWorkloadsResponse"> & {
  /**
   * The list of workloads.
   *
   * @generated from field: repeated admiral.api.cluster.v1.Workload workloads = 1;
   */
  workloads: Workload[];

  /**
   * Pagination token for the next page. Empty when there are no more results.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;
};

/**
 * Describes the message admiral.api.cluster.v1.ListWorkloadsResponse.
 * Use `create(ListWorkloadsResponseSchema)` to create a new message.
 */
export const ListWorkloadsResponseSchema: GenMessage<ListWorkloadsResponse> = /*@__PURE__*/
  messageDesc(file_admiral_api_cluster_v1_cluster, 22);

/**
 * ReportWorkloadStatusRequest contains incremental workload telemetry from a K8s agent.
 *
 * @generated from message admiral.api.cluster.v1.ReportWorkloadStatusRequest
 */
export type ReportWorkloadStatusRequest = Message<"admiral.api.cluster.v1.ReportWorkloadStatusRequest"> & {
  /**
   * The cluster these workloads belong to (UUID).
   *
   * @generated from field: string cluster_id = 1;
   */
  clusterId: string;

  /**
   * Per-workload status snapshots.
   *
   * @generated from field: repeated admiral.api.cluster.v1.WorkloadStatus workloads = 2;
   */
  workloads: WorkloadStatus[];

  /**
   * When the agent generated this report.
   *
   * @generated from field: google.protobuf.Timestamp reported_at = 3;
   */
  reportedAt?: Timestamp;
};

/**
 * Describes the message admiral.api.cluster.v1.ReportWorkloadStatusRequest.
 * Use `create(ReportWorkloadStatusRequestSchema)` to create a new message.
 */
export const ReportWorkloadStatusRequestSchema: GenMessage<ReportWorkloadStatusRequest> = /*@__PURE__*/
  messageDesc(file_admiral_api_cluster_v1_cluster, 23);

/**
 * ReportWorkloadStatusResponse acknowledges a workload telemetry push.
 *
 * @generated from message admiral.api.cluster.v1.ReportWorkloadStatusResponse
 */
export type ReportWorkloadStatusResponse = Message<"admiral.api.cluster.v1.ReportWorkloadStatusResponse"> & {
  /**
   * Whether the report was accepted.
   *
   * @generated from field: bool ack = 1;
   */
  ack: boolean;
};

/**
 * Describes the message admiral.api.cluster.v1.ReportWorkloadStatusResponse.
 * Use `create(ReportWorkloadStatusResponseSchema)` to create a new message.
 */
export const ReportWorkloadStatusResponseSchema: GenMessage<ReportWorkloadStatusResponse> = /*@__PURE__*/
  messageDesc(file_admiral_api_cluster_v1_cluster, 24);

/**
 * CreateClusterTokenRequest contains the parameters for creating a new AGT
 * bound to a cluster.
 *
 * @generated from message admiral.api.cluster.v1.CreateClusterTokenRequest
 */
export type CreateClusterTokenRequest = Message<"admiral.api.cluster.v1.CreateClusterTokenRequest"> & {
  /**
   * The cluster to bind this token to (UUID).
   *
   * @generated from field: string cluster_id = 1;
   */
  clusterId: string;

  /**
   * URL-safe, human-readable identifier for the token (e.g., "prod-agent-key").
   * Must be unique within the cluster's tokens. Lowercase alphanumeric and
   * hyphens only.
   *
   * @generated from field: string name = 2;
   */
  name: string;

  /**
   * Optional expiration time. If unset, the token does not expire.
   *
   * @generated from field: google.protobuf.Timestamp expires_at = 3;
   */
  expiresAt?: Timestamp;
};

/**
 * Describes the message admiral.api.cluster.v1.CreateClusterTokenRequest.
 * Use `create(CreateClusterTokenRequestSchema)` to create a new message.
 */
export const CreateClusterTokenRequestSchema: GenMessage<CreateClusterTokenRequest> = /*@__PURE__*/
  messageDesc(file_admiral_api_cluster_v1_cluster, 25);

/**
 * CreateClusterTokenResponse contains the newly created AGT.
 *
 * @generated from message admiral.api.cluster.v1.CreateClusterTokenResponse
 */
export type CreateClusterTokenResponse = Message<"admiral.api.cluster.v1.CreateClusterTokenResponse"> & {
  /**
   * The created token metadata. Scopes are auto-assigned for cluster AGTs.
   *
   * @generated from field: admiral.common.v1.AccessToken access_token = 1;
   */
  accessToken?: AccessToken;

  /**
   * The raw token secret (e.g., "adm_agt_pL2mN5oQ8rS1..."). This value is
   * shown exactly once and cannot be retrieved again. Store it securely.
   *
   * @generated from field: string plain_text_token = 2;
   */
  plainTextToken: string;
};

/**
 * Describes the message admiral.api.cluster.v1.CreateClusterTokenResponse.
 * Use `create(CreateClusterTokenResponseSchema)` to create a new message.
 */
export const CreateClusterTokenResponseSchema: GenMessage<CreateClusterTokenResponse> = /*@__PURE__*/
  messageDesc(file_admiral_api_cluster_v1_cluster, 26);

/**
 * ListClusterTokensRequest contains pagination and filter parameters.
 *
 * @generated from message admiral.api.cluster.v1.ListClusterTokensRequest
 */
export type ListClusterTokensRequest = Message<"admiral.api.cluster.v1.ListClusterTokensRequest"> & {
  /**
   * The cluster to list tokens for (UUID).
   *
   * @generated from field: string cluster_id = 1;
   */
  clusterId: string;

  /**
   * Filter expression using the PEG filter DSL.
   *
   * @generated from field: string filter = 2;
   */
  filter: string;

  /**
   * Maximum number of tokens to return per page.
   *
   * @generated from field: int32 page_size = 3;
   */
  pageSize: number;

  /**
   * Opaque pagination token from a previous response.
   *
   * @generated from field: string page_token = 4;
   */
  pageToken: string;
};

/**
 * Describes the message admiral.api.cluster.v1.ListClusterTokensRequest.
 * Use `create(ListClusterTokensRequestSchema)` to create a new message.
 */
export const ListClusterTokensRequestSchema: GenMessage<ListClusterTokensRequest> = /*@__PURE__*/
  messageDesc(file_admiral_api_cluster_v1_cluster, 27);

/**
 * ListClusterTokensResponse contains a page of cluster AGT metadata.
 *
 * @generated from message admiral.api.cluster.v1.ListClusterTokensResponse
 */
export type ListClusterTokensResponse = Message<"admiral.api.cluster.v1.ListClusterTokensResponse"> & {
  /**
   * The list of tokens. Token secrets are never included.
   *
   * @generated from field: repeated admiral.common.v1.AccessToken access_tokens = 1;
   */
  accessTokens: AccessToken[];

  /**
   * Pagination token for the next page. Empty when there are no more results.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;
};

/**
 * Describes the message admiral.api.cluster.v1.ListClusterTokensResponse.
 * Use `create(ListClusterTokensResponseSchema)` to create a new message.
 */
export const ListClusterTokensResponseSchema: GenMessage<ListClusterTokensResponse> = /*@__PURE__*/
  messageDesc(file_admiral_api_cluster_v1_cluster, 28);

/**
 * GetClusterTokenRequest identifies a cluster AGT to retrieve.
 *
 * @generated from message admiral.api.cluster.v1.GetClusterTokenRequest
 */
export type GetClusterTokenRequest = Message<"admiral.api.cluster.v1.GetClusterTokenRequest"> & {
  /**
   * The cluster the token belongs to (UUID).
   *
   * @generated from field: string cluster_id = 1;
   */
  clusterId: string;

  /**
   * The unique identifier of the token (UUID).
   *
   * @generated from field: string token_id = 2;
   */
  tokenId: string;
};

/**
 * Describes the message admiral.api.cluster.v1.GetClusterTokenRequest.
 * Use `create(GetClusterTokenRequestSchema)` to create a new message.
 */
export const GetClusterTokenRequestSchema: GenMessage<GetClusterTokenRequest> = /*@__PURE__*/
  messageDesc(file_admiral_api_cluster_v1_cluster, 29);

/**
 * GetClusterTokenResponse contains the requested cluster AGT metadata.
 *
 * @generated from message admiral.api.cluster.v1.GetClusterTokenResponse
 */
export type GetClusterTokenResponse = Message<"admiral.api.cluster.v1.GetClusterTokenResponse"> & {
  /**
   * The token metadata. The token secret is never included.
   *
   * @generated from field: admiral.common.v1.AccessToken access_token = 1;
   */
  accessToken?: AccessToken;
};

/**
 * Describes the message admiral.api.cluster.v1.GetClusterTokenResponse.
 * Use `create(GetClusterTokenResponseSchema)` to create a new message.
 */
export const GetClusterTokenResponseSchema: GenMessage<GetClusterTokenResponse> = /*@__PURE__*/
  messageDesc(file_admiral_api_cluster_v1_cluster, 30);

/**
 * RevokeClusterTokenRequest identifies a cluster AGT to revoke.
 *
 * @generated from message admiral.api.cluster.v1.RevokeClusterTokenRequest
 */
export type RevokeClusterTokenRequest = Message<"admiral.api.cluster.v1.RevokeClusterTokenRequest"> & {
  /**
   * The cluster the token belongs to (UUID).
   *
   * @generated from field: string cluster_id = 1;
   */
  clusterId: string;

  /**
   * The unique identifier of the token to revoke (UUID).
   *
   * @generated from field: string token_id = 2;
   */
  tokenId: string;
};

/**
 * Describes the message admiral.api.cluster.v1.RevokeClusterTokenRequest.
 * Use `create(RevokeClusterTokenRequestSchema)` to create a new message.
 */
export const RevokeClusterTokenRequestSchema: GenMessage<RevokeClusterTokenRequest> = /*@__PURE__*/
  messageDesc(file_admiral_api_cluster_v1_cluster, 31);

/**
 * RevokeClusterTokenResponse contains the revoked cluster AGT metadata.
 *
 * @generated from message admiral.api.cluster.v1.RevokeClusterTokenResponse
 */
export type RevokeClusterTokenResponse = Message<"admiral.api.cluster.v1.RevokeClusterTokenResponse"> & {
  /**
   * The token metadata with updated status.
   *
   * @generated from field: admiral.common.v1.AccessToken access_token = 1;
   */
  accessToken?: AccessToken;
};

/**
 * Describes the message admiral.api.cluster.v1.RevokeClusterTokenResponse.
 * Use `create(RevokeClusterTokenResponseSchema)` to create a new message.
 */
export const RevokeClusterTokenResponseSchema: GenMessage<RevokeClusterTokenResponse> = /*@__PURE__*/
  messageDesc(file_admiral_api_cluster_v1_cluster, 32);

/**
 * RevisionBundle contains pre-rendered Kubernetes manifests for a workload
 * revision, ready for server-side apply by the K8s agent.
 *
 * @generated from message admiral.api.cluster.v1.RevisionBundle
 */
export type RevisionBundle = Message<"admiral.api.cluster.v1.RevisionBundle"> & {
  /**
   * Signed URL to download the rendered manifest bundle (tar.gz containing
   * ordered Kubernetes YAML manifests). Time-limited.
   *
   * @generated from field: string artifact_url = 1;
   */
  artifactUrl: string;

  /**
   * SHA-256 checksum of the artifact bundle for integrity verification.
   *
   * @generated from field: string artifact_checksum = 2;
   */
  artifactChecksum: string;

  /**
   * The Kubernetes namespace to apply manifests into. Resolved from the
   * environment's KubernetesConfig.namespace (or defaults to the environment
   * name).
   *
   * @generated from field: string namespace = 3;
   */
  namespace: string;

  /**
   * Component name for logging and status tracking.
   *
   * @generated from field: string component_name = 4;
   */
  componentName: string;

  /**
   * The source version being deployed (e.g., chart version, git ref).
   *
   * @generated from field: string version = 5;
   */
  version: string;
};

/**
 * Describes the message admiral.api.cluster.v1.RevisionBundle.
 * Use `create(RevisionBundleSchema)` to create a new message.
 */
export const RevisionBundleSchema: GenMessage<RevisionBundle> = /*@__PURE__*/
  messageDesc(file_admiral_api_cluster_v1_cluster, 33);

/**
 * RevisionResult contains the outcome of applying a workload revision,
 * reported by the K8s agent.
 *
 * @generated from message admiral.api.cluster.v1.RevisionResult
 */
export type RevisionResult = Message<"admiral.api.cluster.v1.RevisionResult"> & {
  /**
   * Whether the revision was applied successfully.
   *
   * @generated from field: bool success = 1;
   */
  success: boolean;

  /**
   * Error message if the revision failed. Empty on success.
   *
   * @generated from field: string error_message = 2;
   */
  errorMessage: string;

  /**
   * Number of Kubernetes resources applied.
   *
   * @generated from field: int32 resources_applied = 3;
   */
  resourcesApplied: number;

  /**
   * Number of Kubernetes resources that failed to apply.
   *
   * @generated from field: int32 resources_failed = 4;
   */
  resourcesFailed: number;
};

/**
 * Describes the message admiral.api.cluster.v1.RevisionResult.
 * Use `create(RevisionResultSchema)` to create a new message.
 */
export const RevisionResultSchema: GenMessage<RevisionResult> = /*@__PURE__*/
  messageDesc(file_admiral_api_cluster_v1_cluster, 34);

/**
 * GetRevisionBundleRequest identifies a revision whose artifact bundle to fetch.
 *
 * @generated from message admiral.api.cluster.v1.GetRevisionBundleRequest
 */
export type GetRevisionBundleRequest = Message<"admiral.api.cluster.v1.GetRevisionBundleRequest"> & {
  /**
   * The revision to fetch the bundle for (UUID).
   *
   * @generated from field: string revision_id = 1;
   */
  revisionId: string;
};

/**
 * Describes the message admiral.api.cluster.v1.GetRevisionBundleRequest.
 * Use `create(GetRevisionBundleRequestSchema)` to create a new message.
 */
export const GetRevisionBundleRequestSchema: GenMessage<GetRevisionBundleRequest> = /*@__PURE__*/
  messageDesc(file_admiral_api_cluster_v1_cluster, 35);

/**
 * GetRevisionBundleResponse contains the rendered manifests for the revision.
 *
 * @generated from message admiral.api.cluster.v1.GetRevisionBundleResponse
 */
export type GetRevisionBundleResponse = Message<"admiral.api.cluster.v1.GetRevisionBundleResponse"> & {
  /**
   * The artifact bundle with everything needed to apply the workload.
   *
   * @generated from field: admiral.api.cluster.v1.RevisionBundle bundle = 1;
   */
  bundle?: RevisionBundle;
};

/**
 * Describes the message admiral.api.cluster.v1.GetRevisionBundleResponse.
 * Use `create(GetRevisionBundleResponseSchema)` to create a new message.
 */
export const GetRevisionBundleResponseSchema: GenMessage<GetRevisionBundleResponse> = /*@__PURE__*/
  messageDesc(file_admiral_api_cluster_v1_cluster, 36);

/**
 * ReportRevisionResultRequest contains the outcome of applying a workload
 * revision to the cluster.
 *
 * @generated from message admiral.api.cluster.v1.ReportRevisionResultRequest
 */
export type ReportRevisionResultRequest = Message<"admiral.api.cluster.v1.ReportRevisionResultRequest"> & {
  /**
   * The revision being reported on (UUID).
   *
   * @generated from field: string revision_id = 1;
   */
  revisionId: string;

  /**
   * The result of applying the revision.
   *
   * @generated from field: admiral.api.cluster.v1.RevisionResult result = 2;
   */
  result?: RevisionResult;
};

/**
 * Describes the message admiral.api.cluster.v1.ReportRevisionResultRequest.
 * Use `create(ReportRevisionResultRequestSchema)` to create a new message.
 */
export const ReportRevisionResultRequestSchema: GenMessage<ReportRevisionResultRequest> = /*@__PURE__*/
  messageDesc(file_admiral_api_cluster_v1_cluster, 37);

/**
 * ReportRevisionResultResponse acknowledges the result.
 *
 * @generated from message admiral.api.cluster.v1.ReportRevisionResultResponse
 */
export type ReportRevisionResultResponse = Message<"admiral.api.cluster.v1.ReportRevisionResultResponse"> & {
  /**
   * Whether the result was accepted.
   *
   * @generated from field: bool ack = 1;
   */
  ack: boolean;
};

/**
 * Describes the message admiral.api.cluster.v1.ReportRevisionResultResponse.
 * Use `create(ReportRevisionResultResponseSchema)` to create a new message.
 */
export const ReportRevisionResultResponseSchema: GenMessage<ReportRevisionResultResponse> = /*@__PURE__*/
  messageDesc(file_admiral_api_cluster_v1_cluster, 38);

/**
 * ClusterHealthStatus represents the derived health state of a cluster.
 * The status is computed from agent connectivity, node readiness, and workload health.
 *
 * @generated from enum admiral.api.cluster.v1.ClusterHealthStatus
 */
export enum ClusterHealthStatus {
  /**
   * Default value. Must not be used.
   *
   * @generated from enum value: CLUSTER_HEALTH_STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Cluster record exists but no agent has registered yet.
   *
   * @generated from enum value: CLUSTER_HEALTH_STATUS_PENDING = 1;
   */
  PENDING = 1,

  /**
   * Agent connected, all nodes ready, less than 10% workloads degraded.
   *
   * @generated from enum value: CLUSTER_HEALTH_STATUS_HEALTHY = 2;
   */
  HEALTHY = 2,

  /**
   * Agent connected, some nodes not ready or workloads in error/degraded state.
   *
   * @generated from enum value: CLUSTER_HEALTH_STATUS_DEGRADED = 3;
   */
  DEGRADED = 3,

  /**
   * Agent connected, more than 25% nodes not ready or workloads in error state.
   *
   * @generated from enum value: CLUSTER_HEALTH_STATUS_ERROR = 4;
   */
  ERROR = 4,

  /**
   * No heartbeat received within 3x the heartbeat interval.
   *
   * @generated from enum value: CLUSTER_HEALTH_STATUS_UNREACHABLE = 5;
   */
  UNREACHABLE = 5,
}

/**
 * Describes the enum admiral.api.cluster.v1.ClusterHealthStatus.
 */
export const ClusterHealthStatusSchema: GenEnum<ClusterHealthStatus> = /*@__PURE__*/
  enumDesc(file_admiral_api_cluster_v1_cluster, 0);

/**
 * WorkloadHealthStatus represents the derived health state of a single workload.
 *
 * @generated from enum admiral.api.cluster.v1.WorkloadHealthStatus
 */
export enum WorkloadHealthStatus {
  /**
   * Default value. Must not be used.
   *
   * @generated from enum value: WORKLOAD_HEALTH_STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * All desired replicas ready, no CrashLoopBackOff, restarts stable.
   *
   * @generated from enum value: WORKLOAD_HEALTH_STATUS_HEALTHY = 1;
   */
  HEALTHY = 1,

  /**
   * Some replicas not ready, restarts increasing, or pods pending over 5 minutes.
   *
   * @generated from enum value: WORKLOAD_HEALTH_STATUS_DEGRADED = 2;
   */
  DEGRADED = 2,

  /**
   * Zero ready replicas, all containers CrashLoopBackOff, or deployment stuck.
   *
   * @generated from enum value: WORKLOAD_HEALTH_STATUS_ERROR = 3;
   */
  ERROR = 3,
}

/**
 * Describes the enum admiral.api.cluster.v1.WorkloadHealthStatus.
 */
export const WorkloadHealthStatusSchema: GenEnum<WorkloadHealthStatus> = /*@__PURE__*/
  enumDesc(file_admiral_api_cluster_v1_cluster, 1);

/**
 * ClusterAPI manages Kubernetes clusters and their workload telemetry.
 *
 * Administrators create clusters via CreateCluster, which returns an Agent
 * Token (AGT) for deploying the K8s agent. Once the agent boots and calls
 * AgentAPI.RegisterAgent, the cluster transitions from PENDING to HEALTHY
 * and begins receiving telemetry.
 *
 * The telemetry model has three tiers: current snapshot (upserted per push),
 * time-series metrics (rolling 48-hour window), and events (rolling 7-day window).
 *
 * @generated from service admiral.api.cluster.v1.ClusterAPI
 */
export const ClusterAPI: GenService<{
  /**
   * CreateCluster creates a new cluster record within the caller's tenant and
   * generates an initial Agent Token (AGT) for the K8s agent. The cluster
   * starts in PENDING status until an agent registers against it.
   *
   * The response includes a `plain_text_token` — the raw AGT secret shown
   * exactly once. Deploy this token to the K8s agent (e.g., via Helm values
   * or a Kubernetes Secret). The agent uses it to authenticate with
   * AgentAPI.RegisterAgent on first boot.
   *
   * Scope: `cluster:write`
   *
   * @generated from rpc admiral.api.cluster.v1.ClusterAPI.CreateCluster
   */
  createCluster: {
    methodKind: "unary";
    input: typeof CreateClusterRequestSchema;
    output: typeof CreateClusterResponseSchema;
  },
  /**
   * GetCluster retrieves a cluster by ID.
   *
   * Returns the Cluster record with its server-derived health_status. For
   * detailed telemetry (node counts, resource usage, workload summary), use
   * GetClusterStatus instead.
   *
   * Scope: `cluster:read`
   *
   * @generated from rpc admiral.api.cluster.v1.ClusterAPI.GetCluster
   */
  getCluster: {
    methodKind: "unary";
    input: typeof GetClusterRequestSchema;
    output: typeof GetClusterResponseSchema;
  },
  /**
   * GetClusterStatus retrieves the current telemetry snapshot for a cluster.
   * Returns the latest metrics pushed by the agent, along with server-derived
   * health status and workload summary counts.
   *
   * Returns NOT_FOUND if the cluster does not exist. If the cluster exists but
   * no agent has reported telemetry yet, the response will have health_status
   * PENDING and no status message.
   *
   * Scope: `cluster:read`
   *
   * @generated from rpc admiral.api.cluster.v1.ClusterAPI.GetClusterStatus
   */
  getClusterStatus: {
    methodKind: "unary";
    input: typeof GetClusterStatusRequestSchema;
    output: typeof GetClusterStatusResponseSchema;
  },
  /**
   * ListClusters returns a paginated list of clusters within the caller's tenant.
   *
   * Scope: `cluster:read`
   *
   * @generated from rpc admiral.api.cluster.v1.ClusterAPI.ListClusters
   */
  listClusters: {
    methodKind: "unary";
    input: typeof ListClustersRequestSchema;
    output: typeof ListClustersResponseSchema;
  },
  /**
   * UpdateCluster updates a cluster's mutable fields.
   * Use the `update_mask` to specify which fields to update.
   *
   * Scope: `cluster:write`
   *
   * @generated from rpc admiral.api.cluster.v1.ClusterAPI.UpdateCluster
   */
  updateCluster: {
    methodKind: "unary";
    input: typeof UpdateClusterRequestSchema;
    output: typeof UpdateClusterResponseSchema;
  },
  /**
   * DeleteCluster permanently deletes a cluster record and revokes all
   * associated agent tokens. This action cannot be undone.
   *
   * Scope: `cluster:write`
   *
   * @generated from rpc admiral.api.cluster.v1.ClusterAPI.DeleteCluster
   */
  deleteCluster: {
    methodKind: "unary";
    input: typeof DeleteClusterRequestSchema;
    output: typeof DeleteClusterResponseSchema;
  },
  /**
   * CreateClusterToken creates a new Agent Token (AGT) bound to the specified
   * cluster. Scopes are auto-assigned and cannot be overridden. The response
   * includes the raw token secret, which is shown exactly once.
   *
   * Use this to create additional AGTs for an existing cluster (e.g., for
   * zero-downtime token rotation). The initial AGT is created automatically
   * by CreateCluster.
   *
   * Scope: `cluster:write`
   *
   * @generated from rpc admiral.api.cluster.v1.ClusterAPI.CreateClusterToken
   */
  createClusterToken: {
    methodKind: "unary";
    input: typeof CreateClusterTokenRequestSchema;
    output: typeof CreateClusterTokenResponseSchema;
  },
  /**
   * ListClusterTokens returns a paginated list of AGTs bound to the specified
   * cluster. Token secrets are never included.
   *
   * Scope: `cluster:read`
   *
   * @generated from rpc admiral.api.cluster.v1.ClusterAPI.ListClusterTokens
   */
  listClusterTokens: {
    methodKind: "unary";
    input: typeof ListClusterTokensRequestSchema;
    output: typeof ListClusterTokensResponseSchema;
  },
  /**
   * GetClusterToken retrieves a single AGT by ID.
   * Returns metadata only — the token secret is never included.
   *
   * Scope: `cluster:read`
   *
   * @generated from rpc admiral.api.cluster.v1.ClusterAPI.GetClusterToken
   */
  getClusterToken: {
    methodKind: "unary";
    input: typeof GetClusterTokenRequestSchema;
    output: typeof GetClusterTokenResponseSchema;
  },
  /**
   * RevokeClusterToken permanently revokes an AGT bound to this cluster.
   * The agent will receive a 401 on its next request. If this is the only
   * active AGT for the cluster, the agent will become disconnected.
   *
   * Scope: `cluster:write`
   *
   * @generated from rpc admiral.api.cluster.v1.ClusterAPI.RevokeClusterToken
   */
  revokeClusterToken: {
    methodKind: "unary";
    input: typeof RevokeClusterTokenRequestSchema;
    output: typeof RevokeClusterTokenResponseSchema;
  },
  /**
   * ReportClusterStatus receives a combined telemetry snapshot from a K8s agent.
   * The payload includes cluster-level metrics, per-workload status, and
   * Kubernetes events. Admiral splits this into three storage tiers on receipt.
   *
   * The cluster is identified by the agent token — the server resolves the
   * cluster from the AGT's binding. No cluster_id is required in the request.
   *
   * This endpoint is agent-facing and restricted to agent tokens.
   *
   * Scope: `cluster:status` | Token types: `agt`
   *
   * @generated from rpc admiral.api.cluster.v1.ClusterAPI.ReportClusterStatus
   */
  reportClusterStatus: {
    methodKind: "unary";
    input: typeof ReportClusterStatusRequestSchema;
    output: typeof ReportClusterStatusResponseSchema;
  },
  /**
   * ListWorkloads returns a paginated list of workloads running in a specific cluster.
   *
   * Scope: `cluster:read`
   *
   * @generated from rpc admiral.api.cluster.v1.ClusterAPI.ListWorkloads
   */
  listWorkloads: {
    methodKind: "unary";
    input: typeof ListWorkloadsRequestSchema;
    output: typeof ListWorkloadsResponseSchema;
  },
  /**
   * ReportWorkloadStatus receives workload-only telemetry from a K8s agent.
   * Used for incremental workload updates between full cluster status pushes.
   *
   * This endpoint is agent-facing and restricted to agent tokens.
   *
   * Scope: `cluster:status` | Token types: `agt`
   *
   * @generated from rpc admiral.api.cluster.v1.ClusterAPI.ReportWorkloadStatus
   */
  reportWorkloadStatus: {
    methodKind: "unary";
    input: typeof ReportWorkloadStatusRequestSchema;
    output: typeof ReportWorkloadStatusResponseSchema;
  },
  /**
   * GetRevisionBundle fetches the rendered artifact bundle for a workload
   * revision. The K8s agent calls this when it detects a new or updated
   * revision that needs to be applied to the cluster.
   *
   * The bundle contains pre-rendered Kubernetes manifests (from Helm template,
   * kustomize build, or raw manifests) ready for server-side apply. The agent
   * does not need to render anything — it applies the bundle as-is.
   *
   * The cluster is identified by the agent token's binding. Returns
   * PERMISSION_DENIED if the revision's target cluster does not match the
   * AGT's cluster binding. Returns NOT_FOUND if the revision does not exist
   * or has been cancelled.
   *
   * Scope: `cluster:deploy` | Token types: `agt`
   *
   * @generated from rpc admiral.api.cluster.v1.ClusterAPI.GetRevisionBundle
   */
  getRevisionBundle: {
    methodKind: "unary";
    input: typeof GetRevisionBundleRequestSchema;
    output: typeof GetRevisionBundleResponseSchema;
  },
  /**
   * ReportRevisionResult reports the outcome of applying a workload revision
   * to the cluster. The server transitions the parent Revision status
   * accordingly (APPLYING → SUCCEEDED or FAILED).
   *
   * The cluster is identified by the agent token's binding. Returns
   * PERMISSION_DENIED if the revision's target cluster does not match the
   * AGT's cluster binding.
   *
   * Scope: `cluster:deploy` | Token types: `agt`
   *
   * @generated from rpc admiral.api.cluster.v1.ClusterAPI.ReportRevisionResult
   */
  reportRevisionResult: {
    methodKind: "unary";
    input: typeof ReportRevisionResultRequestSchema;
    output: typeof ReportRevisionResultResponseSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_admiral_api_cluster_v1_cluster, 0);

