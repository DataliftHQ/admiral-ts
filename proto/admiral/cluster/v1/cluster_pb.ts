// @generated by protoc-gen-es v2.11.0 with parameter "target=ts"
// @generated from file admiral/cluster/v1/cluster.proto (package admiral.cluster.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import { enumDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv2";
import { file_buf_validate_validate } from "../../../buf/validate/validate_pb";
import type { FieldMask, Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_field_mask, file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file admiral/cluster/v1/cluster.proto.
 */
export const file_admiral_cluster_v1_cluster: GenFile = /*@__PURE__*/
  fileDesc("CiBhZG1pcmFsL2NsdXN0ZXIvdjEvY2x1c3Rlci5wcm90bxISYWRtaXJhbC5jbHVzdGVyLnYxIpUDCgdDbHVzdGVyEhQKAmlkGAEgASgJQgi6SAVyA7ABARI4CgRuYW1lGAMgASgJQiq6SCdyJRg/MiFeW2Etel0oW2EtejAtOS1dezAsNjF9W2EtejAtOV0pPyQSHQoLZGVzY3JpcHRpb24YBCABKAlCCLpIBXIDGIAIEjcKBmxhYmVscxgFIAMoCzInLmFkbWlyYWwuY2x1c3Rlci52MS5DbHVzdGVyLkxhYmVsc0VudHJ5EhMKC2NsdXN0ZXJfdWlkGAYgASgJEj4KDWhlYWx0aF9zdGF0dXMYByABKA4yJy5hZG1pcmFsLmNsdXN0ZXIudjEuQ2x1c3RlckhlYWx0aFN0YXR1cxIuCgpjcmVhdGVkX2F0GAggASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBIuCgp1cGRhdGVkX2F0GAkgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBotCgtMYWJlbHNFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBIpgDCg1DbHVzdGVyU3RhdHVzEhMKC2s4c192ZXJzaW9uGAEgASgJEhIKCm5vZGVfY291bnQYAiABKAUSEwoLbm9kZXNfcmVhZHkYAyABKAUSFAoMcG9kX2NhcGFjaXR5GAQgASgFEhEKCXBvZF9jb3VudBgFIAEoBRIUCgxwb2RzX3J1bm5pbmcYBiABKAUSFAoMcG9kc19wZW5kaW5nGAcgASgFEhMKC3BvZHNfZmFpbGVkGAggASgFEh8KF2NwdV9jYXBhY2l0eV9taWxsaWNvcmVzGAkgASgDEhsKE2NwdV91c2VkX21pbGxpY29yZXMYCiABKAMSHQoVbWVtb3J5X2NhcGFjaXR5X2J5dGVzGAsgASgDEhkKEW1lbW9yeV91c2VkX2J5dGVzGAwgASgDEhcKD3dvcmtsb2Fkc190b3RhbBgNIAEoBRIZChF3b3JrbG9hZHNfaGVhbHRoeRgOIAEoBRIaChJ3b3JrbG9hZHNfZGVncmFkZWQYDyABKAUSFwoPd29ya2xvYWRzX2Vycm9yGBAgASgFIooFCghXb3JrbG9hZBIKCgJpZBgBIAEoCRISCgpjbHVzdGVyX2lkGAIgASgJEhEKCW5hbWVzcGFjZRgDIAEoCRIMCgRuYW1lGAQgASgJEgwKBGtpbmQYBSABKAkSOAoGbGFiZWxzGAYgAygLMiguYWRtaXJhbC5jbHVzdGVyLnYxLldvcmtsb2FkLkxhYmVsc0VudHJ5Ej8KDWhlYWx0aF9zdGF0dXMYByABKA4yKC5hZG1pcmFsLmNsdXN0ZXIudjEuV29ya2xvYWRIZWFsdGhTdGF0dXMSFQoNc3RhdHVzX3JlYXNvbhgIIAEoCRIYChByZXBsaWNhc19kZXNpcmVkGAkgASgFEhYKDnJlcGxpY2FzX3JlYWR5GAogASgFEhoKEnJlcGxpY2FzX2F2YWlsYWJsZRgLIAEoBRIfChdjcHVfcmVxdWVzdHNfbWlsbGljb3JlcxgMIAEoAxIdChVjcHVfbGltaXRzX21pbGxpY29yZXMYDSABKAMSGwoTY3B1X3VzZWRfbWlsbGljb3JlcxgOIAEoAxIdChVtZW1vcnlfcmVxdWVzdHNfYnl0ZXMYDyABKAMSGwoTbWVtb3J5X2xpbWl0c19ieXRlcxgQIAEoAxIZChFtZW1vcnlfdXNlZF9ieXRlcxgRIAEoAxI3Cgpjb250YWluZXJzGBIgAygLMiMuYWRtaXJhbC5jbHVzdGVyLnYxLkNvbnRhaW5lclN0YXR1cxIzCg9sYXN0X3VwZGF0ZWRfYXQYEyABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wGi0KC0xhYmVsc0VudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCToCOAEiYwoPQ29udGFpbmVyU3RhdHVzEgwKBG5hbWUYASABKAkSDQoFaW1hZ2UYAiABKAkSFQoNcmVzdGFydF9jb3VudBgDIAEoBRINCgVzdGF0ZRgEIAEoCRINCgVyZWFkeRgFIAEoCCJACg9PYmplY3RSZWZlcmVuY2USDAoEa2luZBgBIAEoCRIRCgluYW1lc3BhY2UYAiABKAkSDAoEbmFtZRgDIAEoCSLxAQoNV29ya2xvYWRFdmVudBILCgN1aWQYASABKAkSDAoEdHlwZRgCIAEoCRIOCgZyZWFzb24YAyABKAkSNgoJcmVnYXJkaW5nGAQgASgLMiMuYWRtaXJhbC5jbHVzdGVyLnYxLk9iamVjdFJlZmVyZW5jZRIPCgdtZXNzYWdlGAUgASgJEi4KCmZpcnN0X3NlZW4YBiABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEi0KCWxhc3Rfc2VlbhgHIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASDQoFY291bnQYCCABKAUiqgQKDldvcmtsb2FkU3RhdHVzEhEKCW5hbWVzcGFjZRgBIAEoCRIMCgRuYW1lGAIgASgJEgwKBGtpbmQYAyABKAkSPgoGbGFiZWxzGAQgAygLMi4uYWRtaXJhbC5jbHVzdGVyLnYxLldvcmtsb2FkU3RhdHVzLkxhYmVsc0VudHJ5EhgKEHJlcGxpY2FzX2Rlc2lyZWQYBSABKAUSFgoOcmVwbGljYXNfcmVhZHkYBiABKAUSGgoScmVwbGljYXNfYXZhaWxhYmxlGAcgASgFEh8KF2NwdV9yZXF1ZXN0c19taWxsaWNvcmVzGAggASgDEh0KFWNwdV9saW1pdHNfbWlsbGljb3JlcxgJIAEoAxIbChNjcHVfdXNlZF9taWxsaWNvcmVzGAogASgDEh0KFW1lbW9yeV9yZXF1ZXN0c19ieXRlcxgLIAEoAxIbChNtZW1vcnlfbGltaXRzX2J5dGVzGAwgASgDEhkKEW1lbW9yeV91c2VkX2J5dGVzGA0gASgDEj8KDWhlYWx0aF9zdGF0dXMYDiABKA4yKC5hZG1pcmFsLmNsdXN0ZXIudjEuV29ya2xvYWRIZWFsdGhTdGF0dXMSNwoKY29udGFpbmVycxgPIAMoCzIjLmFkbWlyYWwuY2x1c3Rlci52MS5Db250YWluZXJTdGF0dXMaLQoLTGFiZWxzRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgJOgI4ASKBAgoUQ3JlYXRlQ2x1c3RlclJlcXVlc3QSGwoJdGVuYW50X2lkGAEgASgJQgi6SAVyA7ABARI4CgRuYW1lGAIgASgJQiq6SCdyJRg/MiFeW2Etel0oW2EtejAtOS1dezAsNjF9W2EtejAtOV0pPyQSHQoLZGVzY3JpcHRpb24YAyABKAlCCLpIBXIDGIAIEkQKBmxhYmVscxgEIAMoCzI0LmFkbWlyYWwuY2x1c3Rlci52MS5DcmVhdGVDbHVzdGVyUmVxdWVzdC5MYWJlbHNFbnRyeRotCgtMYWJlbHNFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBIkUKFUNyZWF0ZUNsdXN0ZXJSZXNwb25zZRIsCgdjbHVzdGVyGAEgASgLMhsuYWRtaXJhbC5jbHVzdGVyLnYxLkNsdXN0ZXIiKQoRR2V0Q2x1c3RlclJlcXVlc3QSFAoCaWQYASABKAlCCLpIBXIDsAEBIkIKEkdldENsdXN0ZXJSZXNwb25zZRIsCgdjbHVzdGVyGAEgASgLMhsuYWRtaXJhbC5jbHVzdGVyLnYxLkNsdXN0ZXIiYAoTTGlzdENsdXN0ZXJzUmVxdWVzdBIOCgZmaWx0ZXIYASABKAkSEQoJcGFnZV9zaXplGAIgASgFEhcKCnBhZ2VfdG9rZW4YAyABKAlIAIgBAUINCgtfcGFnZV90b2tlbiJeChRMaXN0Q2x1c3RlcnNSZXNwb25zZRItCghjbHVzdGVycxgBIAMoCzIbLmFkbWlyYWwuY2x1c3Rlci52MS5DbHVzdGVyEhcKD25leHRfcGFnZV90b2tlbhgCIAEoCSJ9ChRVcGRhdGVDbHVzdGVyUmVxdWVzdBI0CgdjbHVzdGVyGAEgASgLMhsuYWRtaXJhbC5jbHVzdGVyLnYxLkNsdXN0ZXJCBrpIA8gBARIvCgt1cGRhdGVfbWFzaxgCIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5GaWVsZE1hc2siRQoVVXBkYXRlQ2x1c3RlclJlc3BvbnNlEiwKB2NsdXN0ZXIYASABKAsyGy5hZG1pcmFsLmNsdXN0ZXIudjEuQ2x1c3RlciIsChREZWxldGVDbHVzdGVyUmVxdWVzdBIUCgJpZBgBIAEoCUIIukgFcgOwAQEiFwoVRGVsZXRlQ2x1c3RlclJlc3BvbnNlIlMKFUJpbmRDbHVzdGVyVUlEUmVxdWVzdBIcCgpjbHVzdGVyX2lkGAEgASgJQgi6SAVyA7ABARIcCgtjbHVzdGVyX3VpZBgCIAEoCUIHukgEcgIQASJGChZCaW5kQ2x1c3RlclVJRFJlc3BvbnNlEiwKB2NsdXN0ZXIYASABKAsyGy5hZG1pcmFsLmNsdXN0ZXIudjEuQ2x1c3RlciKKAQogVXBkYXRlQ2x1c3RlckhlYWx0aFN0YXR1c1JlcXVlc3QSHAoKY2x1c3Rlcl9pZBgBIAEoCUIIukgFcgOwAQESSAoNaGVhbHRoX3N0YXR1cxgCIAEoDjInLmFkbWlyYWwuY2x1c3Rlci52MS5DbHVzdGVySGVhbHRoU3RhdHVzQgi6SAWCAQIQASJRCiFVcGRhdGVDbHVzdGVySGVhbHRoU3RhdHVzUmVzcG9uc2USLAoHY2x1c3RlchgBIAEoCzIbLmFkbWlyYWwuY2x1c3Rlci52MS5DbHVzdGVyIqYBChpVcHNlcnRDbHVzdGVyU3RhdHVzUmVxdWVzdBIcCgpjbHVzdGVyX2lkGAEgASgJQgi6SAVyA7ABARI5CgZzdGF0dXMYAiABKAsyIS5hZG1pcmFsLmNsdXN0ZXIudjEuQ2x1c3RlclN0YXR1c0IGukgDyAEBEi8KC3JlcG9ydGVkX2F0GAMgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCIdChtVcHNlcnRDbHVzdGVyU3RhdHVzUmVzcG9uc2UiNwoXR2V0Q2x1c3RlclN0YXR1c1JlcXVlc3QSHAoKY2x1c3Rlcl9pZBgBIAEoCUIIukgFcgOwAQEivgEKGEdldENsdXN0ZXJTdGF0dXNSZXNwb25zZRI+Cg1oZWFsdGhfc3RhdHVzGAEgASgOMicuYWRtaXJhbC5jbHVzdGVyLnYxLkNsdXN0ZXJIZWFsdGhTdGF0dXMSMQoGc3RhdHVzGAIgASgLMiEuYWRtaXJhbC5jbHVzdGVyLnYxLkNsdXN0ZXJTdGF0dXMSLwoLcmVwb3J0ZWRfYXQYAyABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wIp4BChZVcHNlcnRXb3JrbG9hZHNSZXF1ZXN0EhwKCmNsdXN0ZXJfaWQYASABKAlCCLpIBXIDsAEBEjUKCXdvcmtsb2FkcxgCIAMoCzIiLmFkbWlyYWwuY2x1c3Rlci52MS5Xb3JrbG9hZFN0YXR1cxIvCgtyZXBvcnRlZF9hdBgDIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAiGQoXVXBzZXJ0V29ya2xvYWRzUmVzcG9uc2UifwoUTGlzdFdvcmtsb2Fkc1JlcXVlc3QSHAoKY2x1c3Rlcl9pZBgBIAEoCUIIukgFcgOwAQESDgoGZmlsdGVyGAIgASgJEhEKCXBhZ2Vfc2l6ZRgDIAEoBRIXCgpwYWdlX3Rva2VuGAQgASgJSACIAQFCDQoLX3BhZ2VfdG9rZW4iYQoVTGlzdFdvcmtsb2Fkc1Jlc3BvbnNlEi8KCXdvcmtsb2FkcxgBIAMoCzIcLmFkbWlyYWwuY2x1c3Rlci52MS5Xb3JrbG9hZBIXCg9uZXh0X3BhZ2VfdG9rZW4YAiABKAkibQoaU3RvcmVXb3JrbG9hZEV2ZW50c1JlcXVlc3QSHAoKY2x1c3Rlcl9pZBgBIAEoCUIIukgFcgOwAQESMQoGZXZlbnRzGAIgAygLMiEuYWRtaXJhbC5jbHVzdGVyLnYxLldvcmtsb2FkRXZlbnQiMwobU3RvcmVXb3JrbG9hZEV2ZW50c1Jlc3BvbnNlEhQKDHN0b3JlZF9jb3VudBgBIAEoBSruAQoTQ2x1c3RlckhlYWx0aFN0YXR1cxIlCiFDTFVTVEVSX0hFQUxUSF9TVEFUVVNfVU5TUEVDSUZJRUQQABIhCh1DTFVTVEVSX0hFQUxUSF9TVEFUVVNfUEVORElORxABEiEKHUNMVVNURVJfSEVBTFRIX1NUQVRVU19IRUFMVEhZEAISIgoeQ0xVU1RFUl9IRUFMVEhfU1RBVFVTX0RFR1JBREVEEAMSHwobQ0xVU1RFUl9IRUFMVEhfU1RBVFVTX0VSUk9SEAQSJQohQ0xVU1RFUl9IRUFMVEhfU1RBVFVTX1VOUkVBQ0hBQkxFEAUqqQEKFFdvcmtsb2FkSGVhbHRoU3RhdHVzEiYKIldPUktMT0FEX0hFQUxUSF9TVEFUVVNfVU5TUEVDSUZJRUQQABIiCh5XT1JLTE9BRF9IRUFMVEhfU1RBVFVTX0hFQUxUSFkQARIjCh9XT1JLTE9BRF9IRUFMVEhfU1RBVFVTX0RFR1JBREVEEAISIAocV09SS0xPQURfSEVBTFRIX1NUQVRVU19FUlJPUhADQsYBChZjb20uYWRtaXJhbC5jbHVzdGVyLnYxQgxDbHVzdGVyUHJvdG9QAVo0Z28uYWRtaXJhbC5pby9zZGsvcHJvdG8vYWRtaXJhbC9jbHVzdGVyL3YxO2NsdXN0ZXJ2MaICA0FDWKoCEkFkbWlyYWwuQ2x1c3Rlci5WMcoCEkFkbWlyYWxcQ2x1c3RlclxWMeICHkFkbWlyYWxcQ2x1c3RlclxWMVxHUEJNZXRhZGF0YeoCFEFkbWlyYWw6OkNsdXN0ZXI6OlYxYgZwcm90bzM", [file_buf_validate_validate, file_google_protobuf_field_mask, file_google_protobuf_timestamp]);

/**
 * Cluster represents a registered Kubernetes cluster within a tenant.
 *
 * @generated from message admiral.cluster.v1.Cluster
 */
export type Cluster = Message<"admiral.cluster.v1.Cluster"> & {
  /**
   * Unique identifier for the cluster (UUID).
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * URL-safe, human-readable identifier (e.g., "prod-us-east-1"). Unique
   * within the tenant. Lowercase alphanumeric and hyphens only, must start
   * with a letter and end with an alphanumeric character (1-63 chars).
   *
   * @generated from field: string name = 3;
   */
  name: string;

  /**
   * Optional longer-form description of the cluster's purpose
   * (e.g., "Primary production cluster serving US East traffic").
   *
   * @generated from field: string description = 4;
   */
  description: string;

  /**
   * Arbitrary key-value labels for organizing and filtering clusters
   * (e.g., `{"region": "us-east-1", "cloud": "aws"}`).
   *
   * @generated from field: map<string, string> labels = 5;
   */
  labels: { [key: string]: string };

  /**
   * The Kubernetes kube-system namespace UID, bound at agent registration
   * using a first-write-wins strategy. Used to detect when a token is
   * accidentally deployed to a different physical cluster.
   *
   * @generated from field: string cluster_uid = 6;
   */
  clusterUid: string;

  /**
   * Derived health status based on agent connectivity and workload state.
   *
   * @generated from field: admiral.cluster.v1.ClusterHealthStatus health_status = 7;
   */
  healthStatus: ClusterHealthStatus;

  /**
   * When the cluster record was created.
   *
   * @generated from field: google.protobuf.Timestamp created_at = 8;
   */
  createdAt?: Timestamp;

  /**
   * When the cluster record was last updated.
   *
   * @generated from field: google.protobuf.Timestamp updated_at = 9;
   */
  updatedAt?: Timestamp;
};

/**
 * Describes the message admiral.cluster.v1.Cluster.
 * Use `create(ClusterSchema)` to create a new message.
 */
export const ClusterSchema: GenMessage<Cluster> = /*@__PURE__*/
  messageDesc(file_admiral_cluster_v1_cluster, 0);

/**
 * ClusterStatus contains the raw telemetry metrics for a cluster, as reported
 * by the K8s agent. This message is used in both the push payload
 * (ReportClusterStatusRequest) and the read response (GetClusterStatusResponse).
 *
 * Server-derived fields (health_status, agent connectivity) are NOT included
 * here â€” they live on the Cluster and Agent records respectively, and are
 * returned alongside this message in GetClusterStatusResponse.
 *
 * @generated from message admiral.cluster.v1.ClusterStatus
 */
export type ClusterStatus = Message<"admiral.cluster.v1.ClusterStatus"> & {
  /**
   * Kubernetes version reported by the agent (e.g., "1.29.2").
   *
   * @generated from field: string k8s_version = 1;
   */
  k8sVersion: string;

  /**
   * Total number of nodes in the cluster.
   *
   * @generated from field: int32 node_count = 2;
   */
  nodeCount: number;

  /**
   * Number of nodes in Ready condition.
   *
   * @generated from field: int32 nodes_ready = 3;
   */
  nodesReady: number;

  /**
   * Maximum number of pods the cluster can schedule.
   *
   * @generated from field: int32 pod_capacity = 4;
   */
  podCapacity: number;

  /**
   * Total number of pods across all namespaces.
   *
   * @generated from field: int32 pod_count = 5;
   */
  podCount: number;

  /**
   * Number of pods in Running phase.
   *
   * @generated from field: int32 pods_running = 6;
   */
  podsRunning: number;

  /**
   * Number of pods in Pending phase.
   *
   * @generated from field: int32 pods_pending = 7;
   */
  podsPending: number;

  /**
   * Number of pods in Failed phase.
   *
   * @generated from field: int32 pods_failed = 8;
   */
  podsFailed: number;

  /**
   * Total CPU capacity across all nodes, in millicores.
   *
   * @generated from field: int64 cpu_capacity_millicores = 9;
   */
  cpuCapacityMillicores: bigint;

  /**
   * Current CPU usage across all nodes, in millicores.
   *
   * @generated from field: int64 cpu_used_millicores = 10;
   */
  cpuUsedMillicores: bigint;

  /**
   * Total memory capacity across all nodes, in bytes.
   *
   * @generated from field: int64 memory_capacity_bytes = 11;
   */
  memoryCapacityBytes: bigint;

  /**
   * Current memory usage across all nodes, in bytes.
   *
   * @generated from field: int64 memory_used_bytes = 12;
   */
  memoryUsedBytes: bigint;

  /**
   * Total number of tracked workloads.
   *
   * @generated from field: int32 workloads_total = 13;
   */
  workloadsTotal: number;

  /**
   * Number of workloads in healthy state.
   *
   * @generated from field: int32 workloads_healthy = 14;
   */
  workloadsHealthy: number;

  /**
   * Number of workloads in degraded state.
   *
   * @generated from field: int32 workloads_degraded = 15;
   */
  workloadsDegraded: number;

  /**
   * Number of workloads in error state.
   *
   * @generated from field: int32 workloads_error = 16;
   */
  workloadsError: number;
};

/**
 * Describes the message admiral.cluster.v1.ClusterStatus.
 * Use `create(ClusterStatusSchema)` to create a new message.
 */
export const ClusterStatusSchema: GenMessage<ClusterStatus> = /*@__PURE__*/
  messageDesc(file_admiral_cluster_v1_cluster, 1);

/**
 * Workload represents a Kubernetes workload (Deployment, StatefulSet,
 * DaemonSet, etc.) as observed by the agent.
 *
 * @generated from message admiral.cluster.v1.Workload
 */
export type Workload = Message<"admiral.cluster.v1.Workload"> & {
  /**
   * Unique identifier for the workload within Admiral (UUID).
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * The cluster this workload belongs to (UUID).
   *
   * @generated from field: string cluster_id = 2;
   */
  clusterId: string;

  /**
   * Kubernetes namespace.
   *
   * @generated from field: string namespace = 3;
   */
  namespace: string;

  /**
   * Workload name.
   *
   * @generated from field: string name = 4;
   */
  name: string;

  /**
   * Kubernetes resource kind (e.g., "Deployment", "StatefulSet", "DaemonSet").
   *
   * @generated from field: string kind = 5;
   */
  kind: string;

  /**
   * Kubernetes labels on the workload.
   *
   * @generated from field: map<string, string> labels = 6;
   */
  labels: { [key: string]: string };

  /**
   * Derived health status.
   *
   * @generated from field: admiral.cluster.v1.WorkloadHealthStatus health_status = 7;
   */
  healthStatus: WorkloadHealthStatus;

  /**
   * Human-readable reason for the current status (e.g., "MinimumReplicasUnavailable").
   *
   * @generated from field: string status_reason = 8;
   */
  statusReason: string;

  /**
   * Number of desired replicas.
   *
   * @generated from field: int32 replicas_desired = 9;
   */
  replicasDesired: number;

  /**
   * Number of ready replicas.
   *
   * @generated from field: int32 replicas_ready = 10;
   */
  replicasReady: number;

  /**
   * Number of available replicas.
   *
   * @generated from field: int32 replicas_available = 11;
   */
  replicasAvailable: number;

  /**
   * CPU requests across all containers, in millicores.
   *
   * @generated from field: int64 cpu_requests_millicores = 12;
   */
  cpuRequestsMillicores: bigint;

  /**
   * CPU limits across all containers, in millicores.
   *
   * @generated from field: int64 cpu_limits_millicores = 13;
   */
  cpuLimitsMillicores: bigint;

  /**
   * Current CPU usage across all containers, in millicores.
   *
   * @generated from field: int64 cpu_used_millicores = 14;
   */
  cpuUsedMillicores: bigint;

  /**
   * Memory requests across all containers, in bytes.
   *
   * @generated from field: int64 memory_requests_bytes = 15;
   */
  memoryRequestsBytes: bigint;

  /**
   * Memory limits across all containers, in bytes.
   *
   * @generated from field: int64 memory_limits_bytes = 16;
   */
  memoryLimitsBytes: bigint;

  /**
   * Current memory usage across all containers, in bytes.
   *
   * @generated from field: int64 memory_used_bytes = 17;
   */
  memoryUsedBytes: bigint;

  /**
   * Status of individual containers in this workload.
   *
   * @generated from field: repeated admiral.cluster.v1.ContainerStatus containers = 18;
   */
  containers: ContainerStatus[];

  /**
   * When this workload's status was last updated.
   *
   * @generated from field: google.protobuf.Timestamp last_updated_at = 19;
   */
  lastUpdatedAt?: Timestamp;
};

/**
 * Describes the message admiral.cluster.v1.Workload.
 * Use `create(WorkloadSchema)` to create a new message.
 */
export const WorkloadSchema: GenMessage<Workload> = /*@__PURE__*/
  messageDesc(file_admiral_cluster_v1_cluster, 2);

/**
 * ContainerStatus describes the current state of a single container.
 *
 * @generated from message admiral.cluster.v1.ContainerStatus
 */
export type ContainerStatus = Message<"admiral.cluster.v1.ContainerStatus"> & {
  /**
   * Container name within the pod spec.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Container image reference (e.g., "registry.example.com/api:v2.1.4").
   *
   * @generated from field: string image = 2;
   */
  image: string;

  /**
   * Cumulative number of container restarts.
   *
   * @generated from field: int32 restart_count = 3;
   */
  restartCount: number;

  /**
   * Current container state (e.g., "running", "waiting", "terminated").
   *
   * @generated from field: string state = 4;
   */
  state: string;

  /**
   * Whether the container's readiness probe is passing.
   *
   * @generated from field: bool ready = 5;
   */
  ready: boolean;
};

/**
 * Describes the message admiral.cluster.v1.ContainerStatus.
 * Use `create(ContainerStatusSchema)` to create a new message.
 */
export const ContainerStatusSchema: GenMessage<ContainerStatus> = /*@__PURE__*/
  messageDesc(file_admiral_cluster_v1_cluster, 3);

/**
 * ObjectReference is a lightweight reference to a Kubernetes object.
 *
 * @generated from message admiral.cluster.v1.ObjectReference
 */
export type ObjectReference = Message<"admiral.cluster.v1.ObjectReference"> & {
  /**
   * Kubernetes resource kind (e.g., "Pod", "ReplicaSet").
   *
   * @generated from field: string kind = 1;
   */
  kind: string;

  /**
   * Kubernetes namespace.
   *
   * @generated from field: string namespace = 2;
   */
  namespace: string;

  /**
   * Object name.
   *
   * @generated from field: string name = 3;
   */
  name: string;
};

/**
 * Describes the message admiral.cluster.v1.ObjectReference.
 * Use `create(ObjectReferenceSchema)` to create a new message.
 */
export const ObjectReferenceSchema: GenMessage<ObjectReference> = /*@__PURE__*/
  messageDesc(file_admiral_cluster_v1_cluster, 4);

/**
 * WorkloadEvent represents a Kubernetes event related to a workload or its
 * child objects (pods, replicasets). Events are deduplicated by their K8s UID.
 *
 * @generated from message admiral.cluster.v1.WorkloadEvent
 */
export type WorkloadEvent = Message<"admiral.cluster.v1.WorkloadEvent"> & {
  /**
   * Kubernetes event UID, used for deduplication.
   *
   * @generated from field: string uid = 1;
   */
  uid: string;

  /**
   * Event type: "Normal" or "Warning".
   *
   * @generated from field: string type = 2;
   */
  type: string;

  /**
   * Short machine-readable reason (e.g., "BackOff", "FailedScheduling").
   *
   * @generated from field: string reason = 3;
   */
  reason: string;

  /**
   * The Kubernetes object this event is about.
   *
   * @generated from field: admiral.cluster.v1.ObjectReference regarding = 4;
   */
  regarding?: ObjectReference;

  /**
   * Human-readable event message.
   *
   * @generated from field: string message = 5;
   */
  message: string;

  /**
   * When this event was first observed.
   *
   * @generated from field: google.protobuf.Timestamp first_seen = 6;
   */
  firstSeen?: Timestamp;

  /**
   * When this event was most recently observed.
   *
   * @generated from field: google.protobuf.Timestamp last_seen = 7;
   */
  lastSeen?: Timestamp;

  /**
   * Number of times this event has occurred.
   *
   * @generated from field: int32 count = 8;
   */
  count: number;
};

/**
 * Describes the message admiral.cluster.v1.WorkloadEvent.
 * Use `create(WorkloadEventSchema)` to create a new message.
 */
export const WorkloadEventSchema: GenMessage<WorkloadEvent> = /*@__PURE__*/
  messageDesc(file_admiral_cluster_v1_cluster, 5);

/**
 * WorkloadStatus is the agent-reported status for a single workload within
 * a telemetry push payload.
 *
 * @generated from message admiral.cluster.v1.WorkloadStatus
 */
export type WorkloadStatus = Message<"admiral.cluster.v1.WorkloadStatus"> & {
  /**
   * Kubernetes namespace.
   *
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * Workload name.
   *
   * @generated from field: string name = 2;
   */
  name: string;

  /**
   * Kubernetes resource kind (e.g., "Deployment", "StatefulSet").
   *
   * @generated from field: string kind = 3;
   */
  kind: string;

  /**
   * Kubernetes labels on the workload.
   *
   * @generated from field: map<string, string> labels = 4;
   */
  labels: { [key: string]: string };

  /**
   * Number of desired replicas.
   *
   * @generated from field: int32 replicas_desired = 5;
   */
  replicasDesired: number;

  /**
   * Number of ready replicas.
   *
   * @generated from field: int32 replicas_ready = 6;
   */
  replicasReady: number;

  /**
   * Number of available replicas.
   *
   * @generated from field: int32 replicas_available = 7;
   */
  replicasAvailable: number;

  /**
   * CPU requests across all containers, in millicores.
   *
   * @generated from field: int64 cpu_requests_millicores = 8;
   */
  cpuRequestsMillicores: bigint;

  /**
   * CPU limits across all containers, in millicores.
   *
   * @generated from field: int64 cpu_limits_millicores = 9;
   */
  cpuLimitsMillicores: bigint;

  /**
   * Current CPU usage across all containers, in millicores.
   *
   * @generated from field: int64 cpu_used_millicores = 10;
   */
  cpuUsedMillicores: bigint;

  /**
   * Memory requests across all containers, in bytes.
   *
   * @generated from field: int64 memory_requests_bytes = 11;
   */
  memoryRequestsBytes: bigint;

  /**
   * Memory limits across all containers, in bytes.
   *
   * @generated from field: int64 memory_limits_bytes = 12;
   */
  memoryLimitsBytes: bigint;

  /**
   * Current memory usage across all containers, in bytes.
   *
   * @generated from field: int64 memory_used_bytes = 13;
   */
  memoryUsedBytes: bigint;

  /**
   * Derived health status.
   *
   * @generated from field: admiral.cluster.v1.WorkloadHealthStatus health_status = 14;
   */
  healthStatus: WorkloadHealthStatus;

  /**
   * Status of individual containers.
   *
   * @generated from field: repeated admiral.cluster.v1.ContainerStatus containers = 15;
   */
  containers: ContainerStatus[];
};

/**
 * Describes the message admiral.cluster.v1.WorkloadStatus.
 * Use `create(WorkloadStatusSchema)` to create a new message.
 */
export const WorkloadStatusSchema: GenMessage<WorkloadStatus> = /*@__PURE__*/
  messageDesc(file_admiral_cluster_v1_cluster, 6);

/**
 * CreateClusterRequest contains the parameters for creating a new cluster.
 *
 * @generated from message admiral.cluster.v1.CreateClusterRequest
 */
export type CreateClusterRequest = Message<"admiral.cluster.v1.CreateClusterRequest"> & {
  /**
   * Tenant the cluster belongs to (UUID).
   *
   * @generated from field: string tenant_id = 1;
   */
  tenantId: string;

  /**
   * URL-safe, human-readable identifier (e.g., "prod-us-east-1"). Must be
   * unique within the tenant. Lowercase alphanumeric and hyphens only.
   *
   * @generated from field: string name = 2;
   */
  name: string;

  /**
   * Optional longer-form description of the cluster's purpose.
   *
   * @generated from field: string description = 3;
   */
  description: string;

  /**
   * Arbitrary key-value labels for organizing and filtering clusters
   * (e.g., `{"region": "us-east-1", "cloud": "aws"}`).
   *
   * @generated from field: map<string, string> labels = 4;
   */
  labels: { [key: string]: string };
};

/**
 * Describes the message admiral.cluster.v1.CreateClusterRequest.
 * Use `create(CreateClusterRequestSchema)` to create a new message.
 */
export const CreateClusterRequestSchema: GenMessage<CreateClusterRequest> = /*@__PURE__*/
  messageDesc(file_admiral_cluster_v1_cluster, 7);

/**
 * CreateClusterResponse contains the newly created cluster.
 *
 * @generated from message admiral.cluster.v1.CreateClusterResponse
 */
export type CreateClusterResponse = Message<"admiral.cluster.v1.CreateClusterResponse"> & {
  /**
   * The created cluster. Health status will be PENDING.
   *
   * @generated from field: admiral.cluster.v1.Cluster cluster = 1;
   */
  cluster?: Cluster;
};

/**
 * Describes the message admiral.cluster.v1.CreateClusterResponse.
 * Use `create(CreateClusterResponseSchema)` to create a new message.
 */
export const CreateClusterResponseSchema: GenMessage<CreateClusterResponse> = /*@__PURE__*/
  messageDesc(file_admiral_cluster_v1_cluster, 8);

/**
 * GetClusterRequest identifies a cluster to retrieve.
 *
 * @generated from message admiral.cluster.v1.GetClusterRequest
 */
export type GetClusterRequest = Message<"admiral.cluster.v1.GetClusterRequest"> & {
  /**
   * The unique identifier of the cluster (UUID).
   *
   * @generated from field: string id = 1;
   */
  id: string;
};

/**
 * Describes the message admiral.cluster.v1.GetClusterRequest.
 * Use `create(GetClusterRequestSchema)` to create a new message.
 */
export const GetClusterRequestSchema: GenMessage<GetClusterRequest> = /*@__PURE__*/
  messageDesc(file_admiral_cluster_v1_cluster, 9);

/**
 * GetClusterResponse contains the requested cluster.
 *
 * @generated from message admiral.cluster.v1.GetClusterResponse
 */
export type GetClusterResponse = Message<"admiral.cluster.v1.GetClusterResponse"> & {
  /**
   * The cluster record, including server-derived health_status.
   *
   * @generated from field: admiral.cluster.v1.Cluster cluster = 1;
   */
  cluster?: Cluster;
};

/**
 * Describes the message admiral.cluster.v1.GetClusterResponse.
 * Use `create(GetClusterResponseSchema)` to create a new message.
 */
export const GetClusterResponseSchema: GenMessage<GetClusterResponse> = /*@__PURE__*/
  messageDesc(file_admiral_cluster_v1_cluster, 10);

/**
 * ListClustersRequest contains pagination and filter parameters.
 *
 * @generated from message admiral.cluster.v1.ListClustersRequest
 */
export type ListClustersRequest = Message<"admiral.cluster.v1.ListClustersRequest"> & {
  /**
   * Filter expression using the PEG filter DSL. Supported fields include
   * `tenant_id`, `health_status`, and label selectors.
   *
   * @generated from field: string filter = 1;
   */
  filter: string;

  /**
   * Maximum number of clusters to return per page.
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize: number;

  /**
   * Opaque pagination token from a previous response.
   *
   * @generated from field: optional string page_token = 3;
   */
  pageToken?: string;
};

/**
 * Describes the message admiral.cluster.v1.ListClustersRequest.
 * Use `create(ListClustersRequestSchema)` to create a new message.
 */
export const ListClustersRequestSchema: GenMessage<ListClustersRequest> = /*@__PURE__*/
  messageDesc(file_admiral_cluster_v1_cluster, 11);

/**
 * ListClustersResponse contains a page of clusters.
 *
 * @generated from message admiral.cluster.v1.ListClustersResponse
 */
export type ListClustersResponse = Message<"admiral.cluster.v1.ListClustersResponse"> & {
  /**
   * The list of clusters matching the filter.
   *
   * @generated from field: repeated admiral.cluster.v1.Cluster clusters = 1;
   */
  clusters: Cluster[];

  /**
   * Token to retrieve the next page. Empty when there are no more results.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;
};

/**
 * Describes the message admiral.cluster.v1.ListClustersResponse.
 * Use `create(ListClustersResponseSchema)` to create a new message.
 */
export const ListClustersResponseSchema: GenMessage<ListClustersResponse> = /*@__PURE__*/
  messageDesc(file_admiral_cluster_v1_cluster, 12);

/**
 * UpdateClusterRequest contains the cluster with updated fields.
 *
 * @generated from message admiral.cluster.v1.UpdateClusterRequest
 */
export type UpdateClusterRequest = Message<"admiral.cluster.v1.UpdateClusterRequest"> & {
  /**
   * The cluster with updated fields. The `id` field is required.
   * Only fields specified in `update_mask` are updated.
   *
   * @generated from field: admiral.cluster.v1.Cluster cluster = 1;
   */
  cluster?: Cluster;

  /**
   * The set of fields to update. If unset, all mutable fields are updated.
   * Supported fields: `name`, `description`, `labels`.
   *
   * @generated from field: google.protobuf.FieldMask update_mask = 2;
   */
  updateMask?: FieldMask;
};

/**
 * Describes the message admiral.cluster.v1.UpdateClusterRequest.
 * Use `create(UpdateClusterRequestSchema)` to create a new message.
 */
export const UpdateClusterRequestSchema: GenMessage<UpdateClusterRequest> = /*@__PURE__*/
  messageDesc(file_admiral_cluster_v1_cluster, 13);

/**
 * UpdateClusterResponse contains the updated cluster.
 *
 * @generated from message admiral.cluster.v1.UpdateClusterResponse
 */
export type UpdateClusterResponse = Message<"admiral.cluster.v1.UpdateClusterResponse"> & {
  /**
   * The updated cluster with all fields reflecting the current state.
   *
   * @generated from field: admiral.cluster.v1.Cluster cluster = 1;
   */
  cluster?: Cluster;
};

/**
 * Describes the message admiral.cluster.v1.UpdateClusterResponse.
 * Use `create(UpdateClusterResponseSchema)` to create a new message.
 */
export const UpdateClusterResponseSchema: GenMessage<UpdateClusterResponse> = /*@__PURE__*/
  messageDesc(file_admiral_cluster_v1_cluster, 14);

/**
 * DeleteClusterRequest identifies a cluster to delete.
 *
 * @generated from message admiral.cluster.v1.DeleteClusterRequest
 */
export type DeleteClusterRequest = Message<"admiral.cluster.v1.DeleteClusterRequest"> & {
  /**
   * The unique identifier of the cluster to delete (UUID).
   *
   * @generated from field: string id = 1;
   */
  id: string;
};

/**
 * Describes the message admiral.cluster.v1.DeleteClusterRequest.
 * Use `create(DeleteClusterRequestSchema)` to create a new message.
 */
export const DeleteClusterRequestSchema: GenMessage<DeleteClusterRequest> = /*@__PURE__*/
  messageDesc(file_admiral_cluster_v1_cluster, 15);

/**
 * DeleteClusterResponse is returned when the cluster has been successfully deleted.
 *
 * @generated from message admiral.cluster.v1.DeleteClusterResponse
 */
export type DeleteClusterResponse = Message<"admiral.cluster.v1.DeleteClusterResponse"> & {
};

/**
 * Describes the message admiral.cluster.v1.DeleteClusterResponse.
 * Use `create(DeleteClusterResponseSchema)` to create a new message.
 */
export const DeleteClusterResponseSchema: GenMessage<DeleteClusterResponse> = /*@__PURE__*/
  messageDesc(file_admiral_cluster_v1_cluster, 16);

/**
 * BindClusterUIDRequest sets the cluster_uid on a cluster record.
 *
 * @generated from message admiral.cluster.v1.BindClusterUIDRequest
 */
export type BindClusterUIDRequest = Message<"admiral.cluster.v1.BindClusterUIDRequest"> & {
  /**
   * The cluster to bind the UID to (UUID).
   *
   * @generated from field: string cluster_id = 1;
   */
  clusterId: string;

  /**
   * The kube-system namespace UID from the Kubernetes cluster.
   *
   * @generated from field: string cluster_uid = 2;
   */
  clusterUid: string;
};

/**
 * Describes the message admiral.cluster.v1.BindClusterUIDRequest.
 * Use `create(BindClusterUIDRequestSchema)` to create a new message.
 */
export const BindClusterUIDRequestSchema: GenMessage<BindClusterUIDRequest> = /*@__PURE__*/
  messageDesc(file_admiral_cluster_v1_cluster, 17);

/**
 * BindClusterUIDResponse contains the updated cluster after UID binding.
 *
 * @generated from message admiral.cluster.v1.BindClusterUIDResponse
 */
export type BindClusterUIDResponse = Message<"admiral.cluster.v1.BindClusterUIDResponse"> & {
  /**
   * The cluster with cluster_uid set.
   *
   * @generated from field: admiral.cluster.v1.Cluster cluster = 1;
   */
  cluster?: Cluster;
};

/**
 * Describes the message admiral.cluster.v1.BindClusterUIDResponse.
 * Use `create(BindClusterUIDResponseSchema)` to create a new message.
 */
export const BindClusterUIDResponseSchema: GenMessage<BindClusterUIDResponse> = /*@__PURE__*/
  messageDesc(file_admiral_cluster_v1_cluster, 18);

/**
 * UpdateClusterHealthStatusRequest updates the server-derived health status.
 *
 * @generated from message admiral.cluster.v1.UpdateClusterHealthStatusRequest
 */
export type UpdateClusterHealthStatusRequest = Message<"admiral.cluster.v1.UpdateClusterHealthStatusRequest"> & {
  /**
   * The cluster whose health status to update (UUID).
   *
   * @generated from field: string cluster_id = 1;
   */
  clusterId: string;

  /**
   * The new health status.
   *
   * @generated from field: admiral.cluster.v1.ClusterHealthStatus health_status = 2;
   */
  healthStatus: ClusterHealthStatus;
};

/**
 * Describes the message admiral.cluster.v1.UpdateClusterHealthStatusRequest.
 * Use `create(UpdateClusterHealthStatusRequestSchema)` to create a new message.
 */
export const UpdateClusterHealthStatusRequestSchema: GenMessage<UpdateClusterHealthStatusRequest> = /*@__PURE__*/
  messageDesc(file_admiral_cluster_v1_cluster, 19);

/**
 * UpdateClusterHealthStatusResponse contains the updated cluster.
 *
 * @generated from message admiral.cluster.v1.UpdateClusterHealthStatusResponse
 */
export type UpdateClusterHealthStatusResponse = Message<"admiral.cluster.v1.UpdateClusterHealthStatusResponse"> & {
  /**
   * The cluster with the updated health status.
   *
   * @generated from field: admiral.cluster.v1.Cluster cluster = 1;
   */
  cluster?: Cluster;
};

/**
 * Describes the message admiral.cluster.v1.UpdateClusterHealthStatusResponse.
 * Use `create(UpdateClusterHealthStatusResponseSchema)` to create a new message.
 */
export const UpdateClusterHealthStatusResponseSchema: GenMessage<UpdateClusterHealthStatusResponse> = /*@__PURE__*/
  messageDesc(file_admiral_cluster_v1_cluster, 20);

/**
 * UpsertClusterStatusRequest stores a telemetry snapshot for a cluster.
 *
 * @generated from message admiral.cluster.v1.UpsertClusterStatusRequest
 */
export type UpsertClusterStatusRequest = Message<"admiral.cluster.v1.UpsertClusterStatusRequest"> & {
  /**
   * The cluster this status belongs to (UUID).
   *
   * @generated from field: string cluster_id = 1;
   */
  clusterId: string;

  /**
   * The telemetry snapshot to store.
   *
   * @generated from field: admiral.cluster.v1.ClusterStatus status = 2;
   */
  status?: ClusterStatus;

  /**
   * When the agent generated this report.
   *
   * @generated from field: google.protobuf.Timestamp reported_at = 3;
   */
  reportedAt?: Timestamp;
};

/**
 * Describes the message admiral.cluster.v1.UpsertClusterStatusRequest.
 * Use `create(UpsertClusterStatusRequestSchema)` to create a new message.
 */
export const UpsertClusterStatusRequestSchema: GenMessage<UpsertClusterStatusRequest> = /*@__PURE__*/
  messageDesc(file_admiral_cluster_v1_cluster, 21);

/**
 * UpsertClusterStatusResponse acknowledges the telemetry upsert.
 *
 * @generated from message admiral.cluster.v1.UpsertClusterStatusResponse
 */
export type UpsertClusterStatusResponse = Message<"admiral.cluster.v1.UpsertClusterStatusResponse"> & {
};

/**
 * Describes the message admiral.cluster.v1.UpsertClusterStatusResponse.
 * Use `create(UpsertClusterStatusResponseSchema)` to create a new message.
 */
export const UpsertClusterStatusResponseSchema: GenMessage<UpsertClusterStatusResponse> = /*@__PURE__*/
  messageDesc(file_admiral_cluster_v1_cluster, 22);

/**
 * GetClusterStatusRequest identifies a cluster whose telemetry to retrieve.
 *
 * @generated from message admiral.cluster.v1.GetClusterStatusRequest
 */
export type GetClusterStatusRequest = Message<"admiral.cluster.v1.GetClusterStatusRequest"> & {
  /**
   * The unique identifier of the cluster (UUID).
   *
   * @generated from field: string cluster_id = 1;
   */
  clusterId: string;
};

/**
 * Describes the message admiral.cluster.v1.GetClusterStatusRequest.
 * Use `create(GetClusterStatusRequestSchema)` to create a new message.
 */
export const GetClusterStatusRequestSchema: GenMessage<GetClusterStatusRequest> = /*@__PURE__*/
  messageDesc(file_admiral_cluster_v1_cluster, 23);

/**
 * GetClusterStatusResponse contains the latest telemetry snapshot.
 *
 * @generated from message admiral.cluster.v1.GetClusterStatusResponse
 */
export type GetClusterStatusResponse = Message<"admiral.cluster.v1.GetClusterStatusResponse"> & {
  /**
   * Server-derived health status based on agent connectivity, node readiness,
   * and workload health.
   *
   * @generated from field: admiral.cluster.v1.ClusterHealthStatus health_status = 1;
   */
  healthStatus: ClusterHealthStatus;

  /**
   * Latest telemetry snapshot from the agent. Absent if no telemetry has
   * been reported yet.
   *
   * @generated from field: admiral.cluster.v1.ClusterStatus status = 2;
   */
  status?: ClusterStatus;

  /**
   * When the latest telemetry was reported by the agent.
   *
   * @generated from field: google.protobuf.Timestamp reported_at = 3;
   */
  reportedAt?: Timestamp;
};

/**
 * Describes the message admiral.cluster.v1.GetClusterStatusResponse.
 * Use `create(GetClusterStatusResponseSchema)` to create a new message.
 */
export const GetClusterStatusResponseSchema: GenMessage<GetClusterStatusResponse> = /*@__PURE__*/
  messageDesc(file_admiral_cluster_v1_cluster, 24);

/**
 * UpsertWorkloadsRequest stores or updates workload records from an agent push.
 *
 * @generated from message admiral.cluster.v1.UpsertWorkloadsRequest
 */
export type UpsertWorkloadsRequest = Message<"admiral.cluster.v1.UpsertWorkloadsRequest"> & {
  /**
   * The cluster these workloads belong to (UUID).
   *
   * @generated from field: string cluster_id = 1;
   */
  clusterId: string;

  /**
   * The workload statuses to upsert.
   *
   * @generated from field: repeated admiral.cluster.v1.WorkloadStatus workloads = 2;
   */
  workloads: WorkloadStatus[];

  /**
   * When the agent generated this report.
   *
   * @generated from field: google.protobuf.Timestamp reported_at = 3;
   */
  reportedAt?: Timestamp;
};

/**
 * Describes the message admiral.cluster.v1.UpsertWorkloadsRequest.
 * Use `create(UpsertWorkloadsRequestSchema)` to create a new message.
 */
export const UpsertWorkloadsRequestSchema: GenMessage<UpsertWorkloadsRequest> = /*@__PURE__*/
  messageDesc(file_admiral_cluster_v1_cluster, 25);

/**
 * UpsertWorkloadsResponse acknowledges the workload upsert.
 *
 * @generated from message admiral.cluster.v1.UpsertWorkloadsResponse
 */
export type UpsertWorkloadsResponse = Message<"admiral.cluster.v1.UpsertWorkloadsResponse"> & {
};

/**
 * Describes the message admiral.cluster.v1.UpsertWorkloadsResponse.
 * Use `create(UpsertWorkloadsResponseSchema)` to create a new message.
 */
export const UpsertWorkloadsResponseSchema: GenMessage<UpsertWorkloadsResponse> = /*@__PURE__*/
  messageDesc(file_admiral_cluster_v1_cluster, 26);

/**
 * ListWorkloadsRequest contains pagination and filter parameters for listing
 * workloads in a specific cluster.
 *
 * @generated from message admiral.cluster.v1.ListWorkloadsRequest
 */
export type ListWorkloadsRequest = Message<"admiral.cluster.v1.ListWorkloadsRequest"> & {
  /**
   * The cluster whose workloads to list (UUID).
   *
   * @generated from field: string cluster_id = 1;
   */
  clusterId: string;

  /**
   * Filter expression using the PEG filter DSL.
   *
   * @generated from field: string filter = 2;
   */
  filter: string;

  /**
   * Maximum number of workloads to return per page.
   *
   * @generated from field: int32 page_size = 3;
   */
  pageSize: number;

  /**
   * Opaque pagination token from a previous response.
   *
   * @generated from field: optional string page_token = 4;
   */
  pageToken?: string;
};

/**
 * Describes the message admiral.cluster.v1.ListWorkloadsRequest.
 * Use `create(ListWorkloadsRequestSchema)` to create a new message.
 */
export const ListWorkloadsRequestSchema: GenMessage<ListWorkloadsRequest> = /*@__PURE__*/
  messageDesc(file_admiral_cluster_v1_cluster, 27);

/**
 * ListWorkloadsResponse contains a page of workloads.
 *
 * @generated from message admiral.cluster.v1.ListWorkloadsResponse
 */
export type ListWorkloadsResponse = Message<"admiral.cluster.v1.ListWorkloadsResponse"> & {
  /**
   * The list of workloads.
   *
   * @generated from field: repeated admiral.cluster.v1.Workload workloads = 1;
   */
  workloads: Workload[];

  /**
   * Token to retrieve the next page. Empty when there are no more results.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken: string;
};

/**
 * Describes the message admiral.cluster.v1.ListWorkloadsResponse.
 * Use `create(ListWorkloadsResponseSchema)` to create a new message.
 */
export const ListWorkloadsResponseSchema: GenMessage<ListWorkloadsResponse> = /*@__PURE__*/
  messageDesc(file_admiral_cluster_v1_cluster, 28);

/**
 * StoreWorkloadEventsRequest stores Kubernetes events from an agent push.
 *
 * @generated from message admiral.cluster.v1.StoreWorkloadEventsRequest
 */
export type StoreWorkloadEventsRequest = Message<"admiral.cluster.v1.StoreWorkloadEventsRequest"> & {
  /**
   * The cluster these events belong to (UUID).
   *
   * @generated from field: string cluster_id = 1;
   */
  clusterId: string;

  /**
   * The events to store. Deduplicated by K8s event UID.
   *
   * @generated from field: repeated admiral.cluster.v1.WorkloadEvent events = 2;
   */
  events: WorkloadEvent[];
};

/**
 * Describes the message admiral.cluster.v1.StoreWorkloadEventsRequest.
 * Use `create(StoreWorkloadEventsRequestSchema)` to create a new message.
 */
export const StoreWorkloadEventsRequestSchema: GenMessage<StoreWorkloadEventsRequest> = /*@__PURE__*/
  messageDesc(file_admiral_cluster_v1_cluster, 29);

/**
 * StoreWorkloadEventsResponse acknowledges the event storage.
 *
 * @generated from message admiral.cluster.v1.StoreWorkloadEventsResponse
 */
export type StoreWorkloadEventsResponse = Message<"admiral.cluster.v1.StoreWorkloadEventsResponse"> & {
  /**
   * Number of new events stored (excluding duplicates).
   *
   * @generated from field: int32 stored_count = 1;
   */
  storedCount: number;
};

/**
 * Describes the message admiral.cluster.v1.StoreWorkloadEventsResponse.
 * Use `create(StoreWorkloadEventsResponseSchema)` to create a new message.
 */
export const StoreWorkloadEventsResponseSchema: GenMessage<StoreWorkloadEventsResponse> = /*@__PURE__*/
  messageDesc(file_admiral_cluster_v1_cluster, 30);

/**
 * ClusterHealthStatus represents the derived health state of a cluster.
 * The status is computed from agent connectivity, node readiness, and workload health.
 *
 * @generated from enum admiral.cluster.v1.ClusterHealthStatus
 */
export enum ClusterHealthStatus {
  /**
   * Default value. Must not be used.
   *
   * @generated from enum value: CLUSTER_HEALTH_STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Cluster record exists but no agent has registered yet.
   *
   * @generated from enum value: CLUSTER_HEALTH_STATUS_PENDING = 1;
   */
  PENDING = 1,

  /**
   * Agent connected, all nodes ready, less than 10% workloads degraded.
   *
   * @generated from enum value: CLUSTER_HEALTH_STATUS_HEALTHY = 2;
   */
  HEALTHY = 2,

  /**
   * Agent connected, some nodes not ready or workloads in error/degraded state.
   *
   * @generated from enum value: CLUSTER_HEALTH_STATUS_DEGRADED = 3;
   */
  DEGRADED = 3,

  /**
   * Agent connected, more than 25% nodes not ready or workloads in error state.
   *
   * @generated from enum value: CLUSTER_HEALTH_STATUS_ERROR = 4;
   */
  ERROR = 4,

  /**
   * No heartbeat received within 3x the heartbeat interval.
   *
   * @generated from enum value: CLUSTER_HEALTH_STATUS_UNREACHABLE = 5;
   */
  UNREACHABLE = 5,
}

/**
 * Describes the enum admiral.cluster.v1.ClusterHealthStatus.
 */
export const ClusterHealthStatusSchema: GenEnum<ClusterHealthStatus> = /*@__PURE__*/
  enumDesc(file_admiral_cluster_v1_cluster, 0);

/**
 * WorkloadHealthStatus represents the derived health state of a single workload.
 *
 * @generated from enum admiral.cluster.v1.WorkloadHealthStatus
 */
export enum WorkloadHealthStatus {
  /**
   * Default value. Must not be used.
   *
   * @generated from enum value: WORKLOAD_HEALTH_STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * All desired replicas ready, no CrashLoopBackOff, restarts stable.
   *
   * @generated from enum value: WORKLOAD_HEALTH_STATUS_HEALTHY = 1;
   */
  HEALTHY = 1,

  /**
   * Some replicas not ready, restarts increasing, or pods pending over 5 minutes.
   *
   * @generated from enum value: WORKLOAD_HEALTH_STATUS_DEGRADED = 2;
   */
  DEGRADED = 2,

  /**
   * Zero ready replicas, all containers CrashLoopBackOff, or deployment stuck.
   *
   * @generated from enum value: WORKLOAD_HEALTH_STATUS_ERROR = 3;
   */
  ERROR = 3,
}

/**
 * Describes the enum admiral.cluster.v1.WorkloadHealthStatus.
 */
export const WorkloadHealthStatusSchema: GenEnum<WorkloadHealthStatus> = /*@__PURE__*/
  enumDesc(file_admiral_cluster_v1_cluster, 1);

